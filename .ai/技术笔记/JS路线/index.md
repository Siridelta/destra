# Destra JavaScript 路线

> 本文档库旨在循序渐进地介绍 Destra 项目 JavaScript 路线的设计思路与最终实现的技术方案。

## 简介

本部分详细阐述了 Destra 项目当前核心的 JavaScript 技术路线。该路线旨在通过具体的工程实践，将项目“数学表达自然性、依赖关系透明性、高组合性”的核心设计原则予以实现。

为了实现数学表达的自然性，我们选择采用一种通过 JavaScript 的**模板字符串**字面量来编写“表达式领域特定语言 (`Expr DSL`)”的方案。

其核心设计则围绕着一个**双类型模式** (`expr` 与 `expl`) 展开，旨在通过清晰的节点类型区分，在标准的 JavaScript 语法内自然地表达数学结构与依赖关系。

为了提升开发者体验，我们引入了**构建时预处理器**，它能够将简洁的“创作形式”（如箭头函数）转换为信息完备的“标准形式”，实现了从简到繁的渐进增强。

在设计哲学上，我们确立了**“默认模式”与“Genshin模式”并行的双模式策略**。“默认模式”作为当前开发重点，旨在提供一个高度封装、易于模块化组合的开发框架；而远期的“Genshin模式”则保留了深入 Desmos 底层、进行极限操作的灵活性。

## 内容目录

- [默认模式](./默认模式/) - 当前主推的默认模式，包含了“Expr DSL”与“双类型模式”等核心设计的详细方案。
- [Genshin模式](./Genshin模式/) - 远期的 Genshin 模式，旨在完整建模 Desmos 的所有底层机制。（待创建）
- [工程化与多版本并行开发方案](./工程化与多版本并行开发方案.md) - 项目为支持多版本并行开发而设计的工程化方案。

---

## 技术方案概述

### 核心方案：基于模板字符串的 Expr DSL

为了实现数学表达的自然性，我们首先需要解决一个问题：如何在原生不支持运算符重载的 JavaScript 中，让用户能方便地书写数学公式？

我们的方案是利用 JavaScript 的**模板字符串**，创建一种“表达式领域特定语言 (`Expr DSL`)”。这是一种在 JS 社区经过充分实践的成熟范式。它允许用户这样编写代码：

```javascript
const a = expr`1 + 3`;
const b = expr`pi ^ 2`;
const c = expr`${a} + ${b}`;      // 使用插值语法来引用其他表达式，可让 Destra 记录表达式间的依赖关系
```

### `expr` 与 `expl` 的双类型模式

进一步分析 Desmos，我们发现并非所有公式的“类型”都相同。有些只是一个纯粹的数学表达式（如 `x^2+y^2=1` 绘制方程，或`nCr(2, 10)` 计算二项式分布），而另一些则是一个带名字的“变量/函数定义”（如 `a=5`，`f_1(x) = [1, ..., x]` 等）。

同时我们也不难想象到，在用户构建复杂数学逻辑的过程中，会需要复用一些表达式节点，但这些表达式节点也不一定需要在 Desmos 里成为有定义的变量，而是只在 JS/Destra 的模型里存在，在 Desmos 图表里把其中的内容复制代入到每一个引用它的公式里。

为了在我们的模型中精确地反映这种区别，我们引入了**双类型模式 (Dual-Type Pattern)**：

-   `expr` (expression): 用于表示一个纯粹的、无名的**表达式**。
-   `expl` (explicit statement): 用于表示一个带名字的**显式声明**。

```javascript
// a 既是一个可被后续引用的表达式，也是一个名为 "a" 的变量定义，“变量定义”型的公式，其内容是 1+3
const a = expl`a = 1 + 3`;

// eq 是一个方程型的公式，它没有名字，也无法被后续引用
const eq = expr`x^2 + y^2 = 4`;

// b 既是是一个纯粹的表达式，其内容是 a + 2 * x^2，没有名字，不会
const b = expr`${a} + 2 * x^2`;
```

这里需要澄清一下几个概念的范围，建议阅读 [03-公式类型与符号系统.md](../../Desmos建模/03-公式类型与符号系统.md) 以获得更完整的理解：

- 可作为 Desmos 一行公式的内容的类型：变量/函数定义，方程/不等式等，纯表达式
- 可不作为 Desmos 一行公式的内容的类型：仅纯表达式。
- 可在 Destra 模型中被后续引用的类型：变量/函数定义（as expl），纯表达式（as expr）
    - 方程/不等式等类型在数学逻辑上也没有被后续引用的需求，可以认为它们"封顶"了
- 可在 Desmos 中被后续引用的类型：仅变量/函数定义
    - Destra 图表模型里的纯表达式节点在编译时会被内联 (inline)，其内容会被复制并重复代入到每一行公式引用它的地方。如果它没有进入公式列表成为公式，那么在 Desmos 里它就只会在各处以内联形式存在；但如果它进入了公式列表成为公式，那么在 Desmos 里会保留一条以它为内容的公式节点，带有用户在它身上设置的所有显示属性。
- expl 可创建的类型：变量/函数定义
- expr 可创建的类型：纯表达式，方程/不等式等

- 这些 Destra 对象类型是否进入公式列表、是否成为一条公式，取决于它们本身有没有加入 Destra 的一个最终公式列表对象中，以及也取决于它们的下游引用有没有加入公式列表中。
    - 方程/不等式等无法在 Destra 层后续引用，无法具名，如果它们没有进入公式列表成为公式，那么就会被完全忽略。
    - 变量/函数定义可以在 Destra 层被后续引用，必须具名（因为要能在 Desmos 层里继续被引用）；即使它们没有进入公式列表成为公式，如果下游有公式引用它们并进入公式列表，那么它们也会被一并加入公式列表，成为一条 Desmos 公式，以便以 Desmos 变量/函数的形式被下游引用。但如果它和它的所有下游引用都没有进入公式列表，那么它们就会被完全忽略。
    - 纯表达式可以在 Destra 层被后续引用，无法具名。在 Destra 层里它们可被下游引用，但编译至 Desmos 后会变成内联形式，其内容会被复制并重复代入到每一行公式引用它的地方。如果它和它的下游没有进入公式列表，那么它会被完全忽略。如果它没有进入公式列表成为公式，但它有下游进入公式列表，那么在 Desmos 里它就只会在各处以内联形式存在；但如果它进入了公式列表成为公式，那么除了各处内联形式之外，在 Desmos 里会保留一条以它为内容的公式节点，带有用户在它身上设置的所有显示属性，但它和其他位置的内联表达式内容之间已经没有任何关系。

| 是否进入公式列表 | 本体进入 | 本体未进入,下游进入 | 本体、下游都未进入 |
|----------------|:--------:|:-----------------:|:----------------:|
| **变量/函数定义 by expl** | ✅成为公式             | ✅成为公式        | ❌被忽略        |
| **纯表达式 by expr**     | ✅成为公式             |   内联            | ❌被忽略        |
| **方程/不等式等 by expr**| ✅成为公式             | ❌ 无下游，被忽略  | ❌ 被忽略       |


### 3. 体验优化：预处理器 与 “创作/标准”形式

``const a = expl`a = 1 + 3`;`` 的这种设计能够保证 Destra 知道这个表达式大致想要在 Desmos 里使用什么变量名称（即 `a`），但在日常开发中，变量名 `a` 出现了两次，显得很冗余。为了追求极致的开发者体验 (DevEx)，我们引入了**构建时预处理器 (Build-Time Preprocessor)**。

预处理器的引入，将我们的代码明确地划分为了两种形式：

-   **创作形式 (Authoring Form)**：开发者在日常编写的、简洁直观的代码。它本身是语法合法的 JavaScript，但其“真实意图”需要通过预处理器来解读。
-   **标准形式 (Canonical Form)**：经过预处理器转换后，生成的语义完备、供 Destra 核心 API 使用的规范化代码。

预处理器的工作就是将“创作形式”转换为“标准形式”，例如：

**场景1：变量定义的自动推断**
```javascript
// 创作形式：开发者只需这样写
const a = expl`1 + 3`;

// 标准形式：预处理器会自动转换为
const a = expl`a = 1 + 3`;
/*
注：这实际上不准确。
在默认模式方案（见后文）里实际上会转换为另一种形式：
const a = expl`a = 1 + 3`.id("a", true); 
这里仅作示例。
*/
```

**场景2：纯表达式保持不变**
```javascript
// 创作形式
const b = expr`pi ^ 2`;

// 标准形式
const b = expr`pi ^ 2`;
```

**场景3：函数定义的语法糖**
```javascript
// 创作形式：开发者可以使用风格更现代的箭头函数语法
const duplicate = expl`(L) => L.join(L)`;

// 标准形式：预处理器会将其转换为 DSL 字面量里包含函数名的函数定义语法
const duplicate = expl`duplicate(L) = L.join(L)`;
/*
注：默认模式方案里会转为：
const duplicate = expl`(L) => L.join(L)`.id("duplicate", true);
还是把箭头符号保留下来了 lol
其实 DSL 怎么设计都行看起来通顺就Ok
*/
```
通过这种方式，我们在不牺牲 API 严谨性的前提下，为开发者提供了最大程度的便利。

### 4. 路线分叉：默认模式 与 Genshin 模式

### 设计哲学分歧与双模式策略

在上述所有设计（Expr DSL, 双类型模式, 预处理器）之后，Destra 项目在设计哲学上遇到了一个重大的设计哲学分歧，为此我们当前的对策是实施“默认模式”与“Genshin模式”的双轨制策略。这一划分旨在平衡快速开发、框架易用性与保留 Desmos 底层操作的灵活性之间的关系。

#### 模式一：默认模式 (Default Mode)

**默认模式** 是 Destra 库的主要开发方向和推荐使用方式。其核心目标是提供一个**高度封装、专注于表达式组合与复用的工具框架**。它旨在简化 Desmos 图表的构建过程，让用户可以像编写模块化代码一样来组织复杂的数学逻辑。

- **当前状态**: **优先开发中**。
- **详情**: [./默认模式/](./默认模式/)

#### 模式二：Genshin 模式

**Genshin模式**（命名源于社区玩笑，意指追求极致的“黑科技”玩法）代表了 Destra 项目的探索性方向。其目标是提供一个能够从**各个细节深度操作 Desmos 表达式对象的底层工具集**，完整建模 Desmos 的所有机制。

该模式将致力于完整建模 Desmos 的所有机制，保留其全部的灵活性和自由度，包括：

-   支持悬空依赖与“事后补全”定义。
-   完整实现强上下文绑定语句（`with`, `for`）的强制替换功能。
-   探索并支持盲文模式等高级特性。

- **当前状态**: **概念和远期规划阶段**，待创建文档。它的设计和实现难度远高于默认模式，并且其高度的灵活性可能会与默认模式的封装框架产生冲突。在默认模式成熟之前，不会作为开发重点。

### 当前策略：优先开发默认模式

鉴于项目当前的紧迫需求和技术可行性，我们将**集中全部精力优先开发和完善“默认模式”**。这能让我们以最快的速度交付一个稳定、可用、能解决核心问题的 Destra 核心库；同时为未来的深度探索保留了空间。

### 待讨论和设计的技术问题

基于我们对 Desmos 声明式与动态上下文模型的深入理解，以下是 destra.js需要解决的关键技术问题。

#### 1. 表达式的动态与上下文相关性建模

Desmos 的核心是一种“延迟执行”的声明式系统，一个表达式节点的最终结构和值，会受到其下游节点的动态影响。这对我们的建模提出了严峻挑战。

-   **如何表示“不完整片段”**: Desmos 允许 `c = a + b` 这样的“不完整片段”作为一等公民存在，即便 `a` 和 `b` 当下未定义。我们的表达式对象需要能够优雅地表示这种“悬空依赖”的状态。

-   **如何实现“下游影响上游”**: `y = b with a = 100` 这样的下游节点，会逆着依赖图改变上游 `b = a * 2` 的解析。这意味着我们不能构建一个静态的、一次性求值的依赖图。求值过程必须是动态的，并且要感知完整的求值路径。

#### 2. 符号映射与作用域管理

此问题比最初设想的“长变量名缩写”要深刻得多。它关系到如何将 JavaScript 的词法作用域映射到 Desmos 独特的、由上下文动态修改的单一全局命名空间。

-   当用户在不同的 JS 函数中都使用了名为 `i` 的局部变量（如循环变量）时，我们的系统必须能将它们正确地映射到 Desmos 中不同的局部上下文变量 `i`，或转换为不会冲突的全局符号。
-   **待决策问题**: *默认模式应采用何种策略来管理JS变量名与Desmos符号名之间的映射，以避免冲突并保持可读性？是采用全局计数器，还是基于作用域的哈希命名，或是其他更复杂的机制？*

#### 3. 属性系统的集成

Desmos 公式的可视化属性（如颜色、线宽）本身也可以是表达式，动态依赖于其他公式。

-   我们的 `expl` 和 `expr` 对象不仅要能代表一个数学结构，还需要能附带这些可动态求值的属性。这意味着属性系统本身就是依赖图的一部分。
-   **待决策问题**: *默认模式的API应如何设计，以支持将表达式动态绑定到可视化属性上？是采用链式调用 `.setColor(expr`...`)`，还是通过配置对象 `{ ..., color: expr`...` }` 的方式？*

#### 4. 预处理器实现

预处理器的任务现在更加明确：它需要将用户编写的、符合直觉的 JavaScript 代码（如箭头函数），准确地转换为能够被我们上述动态表达式模型所理解的内部结构。

### 主要技术挑战

#### 1. 核心挑战：实现上下文动态绑定

这无疑是最大的技术挑战。我们需要设计并实现一个超越静态 DAG 的求值模型。在该模型中，一个节点的求值必须考虑到从它出发、直至最终输出节点的整条路径上所有的“上下文语句节点”（如 `with`, `for`, 函数调用等）。这在现有的前端框架或响应式系统中没有成熟的先例。

#### 2. API 设计：在封装与灵活性之间取得平衡

默认模式旨在简化操作、易于上手。我们必须在 API 设计上做出关键权衡：应该在多大程度上封装 Desmos 的底层复杂性？例如，完全隐藏“不完整片段”会使 API 更简单，但可能限制了高级用户实现某些创造性效果。这是默认模式设计的核心矛盾。

#### 3. 性能：管理复杂的依赖更新

由于“下游影响上游”，一个下游上下文的微小变化，可能会沿着依赖图向上触发大量节点的重新解析。一个朴素的实现可能会导致性能雪崩。我们需要设计高效的缓存策略和精确的“脏检查”算法，确保只有真正受影响的子图才会被重新计算。

## 相关文档

- [项目总览](../../项目总览.md) - Destra 项目的完整介绍
- [技术笔记](../index.md) - Destra 的技术概述
- [PSADestra 项目总览](../../PSADestra%20项目总览.md) - PSADestra 项目的介绍 