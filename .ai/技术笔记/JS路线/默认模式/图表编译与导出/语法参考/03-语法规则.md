# 语法完整列举 (Complete Grammar Reference)

### 2.1 字面量语法 / 基本类型语法 (Literal Syntaxes / Syntaxes of Basic Types)

上文已经详细介绍了各类公式子类型及其对应字面量语法，这里不再赘述。

### 2.2 顶级语法 / 公式类型语法 (Top Level Syntaxes / Syntaxes of Formula Types)

一个公式的顶级语法，不同的顶级语法决定了该公式的公式类型——Destra 也依赖该语法特征，对模板字面量进行非语法解析的粗粒度扫描，并决定该公式的公式类型，生成对应的 Destra 公式对象。

另可参考[03-公式类型与符号系统.md](../../../../../Desmos建模/03-公式类型与符号系统.md)。

#### 2.2.1 变量定义 (Variable Definitions)

变量定义的语法为 `变量名 = 表达式`，例如 `a = 1`。详见 [核心API与命名机制.md](../../../核心API与命名机制.md)。

#### 2.2.2 函数定义 (Function Definitions)

Desmos 里函数定义的语法大致为 `函数名(参数列表) = 表达式`，例如 `f(x) = x^2`。

Destra 里函数定义可以使用多种语法：
```javascript
const f1 = expl`f1(x) = x^2`;
const f2 = expl`(x, y) => x^2 + y^2`;
const f3 = Func`x, y` (({x, y}) => expr`${x}^2 + ${y}^2`);
```

详见 [核心API与命名机制.md](../../../核心API与命名机制.md)。

#### 2.2.3 显式方程 (Explicit Equations)

显式方程的语法为 `因变量 = 表达式`，例如 `y = x^2`，`V = 4/3 * pi * R^3`。

需要让以下两种情况之一成立：

- 等号左侧的因变量为一个未定义变量。等号右侧的表达式需要依赖另一个未定义变量，且只依赖1个未定义变量。

- 等号左侧的因变量为 x, y 这两个保留变量(3D 计算器里为 x, y, z三个保留变量)中的一个。等号右侧的表达式可以依赖 x, y 保留变量中剩余的至多 1 个(3D 计算器里为 x, y, z三个保留变量中剩余的至多 2 个)。

- 等号左侧的因变量为 r。等号右侧的表达式至多可以依赖 theta （3D 计算器里为 theta 和 z）保留变量。此时表示极坐标方程（3D 计算器里若涉及 z 则为柱坐标方程，未涉及 z 则为 xy 平面上的极坐标方程，此时也可以通过勾选“拓展到3D”选项拓展为柱坐标方程）。

- 等号左侧的因变量为 rho。等号右侧的表达式至多可以依赖 phi 和 theta 2 个保留变量。此时仅限 3D 计算器可用，表示球坐标方程。

#### 2.2.4 隐式方程 / 不等式 (Implicit Equations / Inequalities)

隐式方程 / 不等式的语法为 `表达式 = 表达式`，例如 `x^2 + y^2 = 4`，

或 `表达式 < 表达式` 等等，不等号可为 `>`, `<`, `>=`, `<=`。例如 `y > sin(x)`。

两边的表达式仅可依赖 x, y 这两个保留变量，3D 计算器里为 x, y, z三个保留变量。

如果顶级运算符使用的是不等号，即使该公式符合显式方程的形式，也会被视为隐式方程 / 不等式。

#### 2.2.5 回归（Regression）

回归的语法为 `因变量 ~ 表达式`，例如 `y ~ x`，`y ~ m x + b`。

因变量需为一个已定义的变量，表达式可以依赖若干未定义变量。

回归公式的作用在于基于已知序列数据（源于已定义变量，需为列表），反解、“回归”出各个回归参数（即未定义变量）。回归公式本身会对这些未定义变量施加定义效果，为它们赋值，使它们变为已定义变量，可供后续表达式使用。

### 2.3 运算符 (Operators)

DSL 支持 Desmos 所有的数学运算符。

### 2.3.1 算术运算符 (Arithmetic Operators)

按优先级从高到低排列如下：

- 阶乘: `!` (如 `5!`)
- 指数: `^` (如 `x^2`)。Desmos 里 LaTeX 内容通常对指数运算有完整的括号结构，但在 Destra 里我们需要指定其结合性。我们指定指数运算符为右结合运算符。
- n次根号: `rootof` (如 `3 rootof (x^2 - 4)` 为 `cbrt(x^2 - 4)`)。为右结合运算符。
  - 这是 Destra 提供的语法糖，会转换为 `x^(1/n)` 形式。
- 一元负号: `-` (如 `-x`)；一元正号: `+` (如 `+x`)。
- 乘除/百分比/模: `*`, `/`, `%of` (如 `5 %of 100`), `%`。为左结合运算符。
  - 关于百分比，Desmos 里不支持 `5%` 这样的写法，只能写 `5 %of 100`。键入 `%` 会自动转换为 `%of`。
  - Desmos 里的模运算需要使用 `mod` 函数，例如 `mod(5, 3)` 表示 5 除以 3 的余数。但是因为上方留出了单独 `%` 运算符的空缺，我们可以在 Destra 里支持 `5 % 3` 表示取模/取余数的语法，并编译时转为 mod 函数调用形式。
- 加减: `+`, `-`。为左结合运算符。

### 2.3.2 比较与逻辑运算符 (Comparison and Logical Operators)
**原生支持**:
- 大于/小于: `>`, `<`
- 大于等于/小于等于: `>=` (`\ge`), `<=` (`\le`)
- 等于: `=`, `==`
  - 在 Desmos 条件表达式中使用单等号 `=` 即可表示相等判断；但是在 Destra 里布尔值需要能够作为中间值使用，使用单等号会和显式/隐式方程语法冲突，因此如果需要将等号视为相等判断，需要显式使用 `==` 语法，或者在两边加上括号（位于括号内的等号不会被检测为方程候选），否则会被视为方程。

优先级: 低于加减法。

这些运算符可以连接使用：
- Desmos 语法：
  ```
  0 < a_1 < a_2 < 2
  0 < a_1 < a_2 > a_3
  ```
- Destra 语法：
  ```javascript
  const a1 = expl`a_1`;
  const a2 = expl`a_2`;
  const a3 = expl`a_3`;
  const bool1 = expl`0 < ${a1} < ${a2} < 2`;
  const bool2 = expl`0 < ${a1} < ${a2} > ${a3}`;
  ```

**关于布尔逻辑组合**:
Desmos 原生并不直接支持 C 风格的 `&&`, `||` 运算符用于布尔值运算。通常我们需要利用分段表达式语法，比较运算符连接，或算术表达式混合来间接实现布尔逻辑。
*注: 未来的 Destra 预处理器可能会支持 `&&`, `||`, `!` 等语法糖并自动转换为 Desmos 兼容格式。*

### 2.4 属性访问语法 (Property Access Syntaxes) 与 函数调用语法 (Function Call Syntaxes)

- **普通函数调用语法**:
  - 普通函数调用语法为 `函数名(参数列表)`，例如 `count(L)`。

- **属性访问语法**:
  - 对于点或特定对象，可以用点运算符访问其属性，语法为 `对象.属性`。
  - 优先级：最高。
  - **属性列表**:
    - x, y, z 坐标：`.x`, `.y`, `.z`。取点的 x, y, z 坐标。

值得注意的是，部分函数也可以用属性访问的风格 / 使用点运算符调用。如 `L.count` 等价于 `count(L)`。

但是并非所有属性访问语法都支持普通函数调用语法，也并非所有内置函数都支持这种看似属性访问的风格。这些内置函数在支持 `L.count` 形式的同时必定也支持 `L.count()` 形式。因此这些内置函数更应该看作支持拓展函数语法的函数。

因此我们可以区分属性和支持拓展函数语法的内置函数。属性只支持 `P.x` 点运算符访问，而支持拓展函数语法的内置函数支持 `count(L)`, `L.count`, `L.count()` 全部三种形式。

- **拓展函数语法**:
  - 拓展函数语法为 `接收者.函数名(参数列表)` 或 `接收者.函数名`，例如 `L.count()`, `L.count`。
  - 优先级：最高。

### 2.5 分段表达式 (Piecewise Expressions)

Desmos 使用大括号 `{}` 语法来表示分段函数或条件限制。

**语法**: `{ 条件: 值, 默认值 }` 或 `{ 条件1: 值1, 条件2: 值2, ... }`

```javascript
// if x > 0 then 1 else -1
expr`{${x} > 0: 1, -1}`

// if x > 0 then 1 else if x < 0 then -1 else 0
expr`{${x} > 0: 1, ${x} < 0: -1, 0}`
```

在 Destra 里我们即把“条件”部分抽象成了布尔值类型。

**域限制用法**:

Desmos 里还有一种可以“限制定义域”的语法：
- Desmos 语法：`y = x {x > 0}`
- Destra 语法：``expr`y = x {x > 0}` ``
- 结果：仅在 x > 0 范围内绘制 y = x直线。

**默认值**:

但是上面的语法本质上也是分段表达式，利用了它的一些高级特性。

在每个分支里可以省略其`: 值`部分，此时如果计算匹配到该分支，则输出值为 1。如果没有匹配到任何分支，并且在末尾没有指定默认值，则输出值为 `undefined`。Desmos 里会把 undefined 值进行不绘制处理。

上面的例子本质上是: `y = (x * {x > 0: 1, undefined})`，即，限定定义域其实就是乘以一个分段表达式。

在 x > 0 的区域，是 `x * 1` = `x`，因此绘制的是 `y = x`。

在 x <= 0 的区域，是 `x * undefined` = `undefined`，因此绘制的是 `y = undefined`，即不绘制。（注：无论是 Desmos 还是 Destra 都不支持直接写 undefined 字面量，undefined 值需要通过间接方式构造。）

因此我们可以用它实现一些其他的操作，如：
- Desmos 语法：`y = x {x < 0, x > 1}`
- Destra 语法：``expr`y = x {x < 0, x > 1}` ``
- 结果：不在 [0, 1] 区间内绘制直线，因为该区间内无法匹配到任何分支。

**分支优先级**:

靠前的分支优先匹配。

### 2.6 上下文与作用域语句 (Scope Syntaxes)

虽然 Destra 提供了 `For`, `With`, `Sum`, `Int`, `Func` 等工厂函数来通过 JS 回调构建这些结构，但在 Expr DSL 中，你也可以直接使用类似 Desmos 原生语法的语法来创建这些结构。

另可参考[上下文语句创建.md](../../../上下文语句创建.md)。

上下文变量会覆盖 x, y, z, r, rho, theta, phi 这些保留变量。

#### 2.6.1 For 表达式 / 列表推导 (For Expression / List Comprehension)
语法: `[表达式 for 变量 = 列表]`，`(表达式 for 变量 = 列表)`。顶级可以省略 `[]` 或 `()` 包裹。
优先级: 仅高于加减法。

```javascript
expr`[x^2 for x = [1...10]]`
// 多变量
expr`(x + y for x = [1...5], y = [1...5])`
expr`(i, j) for i = [1...10], j = [1...10]`
```

#### 2.6.2 With 表达式 (Let Binding)
语法: `表达式 with 变量 = 值`
优先级: 仅高于加减法。

```javascript
expr`a^2 + b^2 with a = sin(x), b = cos(x)`
```

Desmos 里，对 for, with 表达式支持顶级省略 `[]` 或 `()` 包裹的写法。Destra 里为了支持这种写法，在检测到唯一的顶级（不在任何括号层级内）等号时，将首先尝试解析为 for/with 表达式（识别 for/with 关键字、推导变量、等号 3 个元素），如果解析失败，则尝试解析为方程。

#### 2.6.3 求和与求积 (Sum & Product)
语法: `sum(变量=下界, 上界) 表达式` / `prod(变量=下界, 上界) 表达式`
优先级: 仅高于加减法。

```javascript
expr`sum(n=1, 10) n^2`
expr`prod(n=1, 10) n`
```
*注: Desmos 输入框中输入 `sum` 会自动变为求和符号 $\sum$。DSL 中直接写 `sum` 即可。*

#### 2.6.4 积分 (Integrals)
语法: `int(下界, 上界) 表达式 d变量` / `int(下界, 上界) d变量 表达式`
优先级: 仅高于加减法。

```javascript
expr`int(0, 1) x^2 dx`
```
注:
- Destra 对 `dx` 的位置进行宽松处理（允许 `dx` 前置），并会在解析时自动把 `dx` 移至最后，将这种写法转换为 Desmos 认为正确的写法。
- Desmos 和 Destra 里对省略乘号的连乘表达式支持比较有限，这里的 dx 是少数支持连乘的地方之一。
- 前置/后置的判据是 `int(l, u)`和`dx`之间是否有表达式内容。

#### 2.6.5 微分算子

在 Desmos 里微分算子是一个非常特殊的特性。但在默认模式里为了简单起见我们将其简化为一个类似上下文语句的语法。

语法: `d/d变量 表达式`
优先级: 仅高于上下文语法。

```javascript
expr`d/dx x^2` // 等价于 expr`x`
```

### 2.7 列表索引

- **列表索引 (Indexing)**:
  
  支持对列表使用方括号进行索引。索引从 1 开始。
  - Desmos 语法: `L[1]`;
  - Destra 语法: ``expr`${L}[1]` ``
  
  支持对列表进行切片，按索引构造出新的列表。
  - Desmos 语法: 
    ```
    L[[1...5]]
    L[[1, 3, 5]]
    L[1...5]    // 中括号可以省略
    L[1, 3, 5]
    ```
  - Destra 语法: 
    ```javascript
    expr`${L}[[1...5]]`      // 切片，取第 1 到 5 个元素
    expr`${L}[[1, 3, 5]]`  // 取第 1, 3, 5 个元素
    expr`${L}[1...5]`      // 中括号可以省略
    expr`${L}[1, 3, 5]`
    ```

- **列表过滤 (Filtering)**:
  支持对列表进行过滤，按条件（事实上是布尔值列表）构造出新的列表。
  - Desmos 语法: `L[L > 5]`;
  - Destra 语法: ``expr`${L}[${L} > 5]` ``

### 2.8 in 运算符

语法: `变量定义 in 下界:步长:上界`。

见[属性与样式API.md](../../../属性与样式API.md)。

Destra 中，用于指定变量定义的滑动条属性。

下界、步长、上界可以省略。

步长省略时，两个冒号可以简写为一个冒号。

### 2.9 空白与注释

Destra 的解析器对空格不敏感。你可以在 DSL 中随意添加空格换行以增加可读性。

此外，Destra 的解析器支持 **JS 风格的单行注释** (`//`)，这些注释会在编译阶段被剔除，不会传递给 Desmos。

```javascript
expr`
  [
    x^2, // 抛物线
    x    // 直线
  ]
`
```

### 2.10 省略乘号的连乘表达式支持

- 在小括号、中括号后方接表达式，在大括号前后接表达式，支持连乘。
- 在积分语法中，前置/后置的 dx 和表达式之间留有空白，支持连乘。
- **数值后接任何表达式**：数值字面量后方如果紧跟**任何**合法的、能开始一个表达式的符号（如标识符、内置函数、括号、列表、插值占位符等），都支持省略乘号连乘。
  - 例：`2x`, `2sin(x)`, `2${var}`, `2(x+1)`, `2[1,2]` 均合法。
  - 可以间隔空白，也可以不间隔空白，只要不引起歧义（如 `pi x` 必须间隔空白才可被视为 `pi * x`，`pix`会整体解析为新的标识符/变量名 `pix`）。

### 2.11 省略括号的函数调用支持

- 三角函数: `sin`, `cos`, 等等。
- `log`, `ln`。

实验中观察到优先级可能在乘除与上下文语法之间。

在 desmos 里检测到太复杂的结构似乎会拒绝使用省略括号用法，特性尚不清楚。

所以为了简单起见目前我们仅支持在参数内容为一元正负号及以上表达式时使用省略括号用法。后方有接乘除号时将转为带括号形式。
