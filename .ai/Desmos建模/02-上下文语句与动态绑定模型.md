# 02 - 上下文语句与动态绑定模型

> **前置阅读**：请确保您已阅读 [01-声明式系统与并行计算.md](./01-声明式系统与并行计算.md)，理解了 Desmos 的声明式特性和基于依赖图 (DAG) 的计算模型。

本文档是 Desmos 建模工作的核心，旨在深入剖析 Desmos 中最独特、最强大的机制：**上下文语句 (Context Statement)**。

## 五种上下文语句

在 Desmos 中，有五种语法结构可以引入局部变量，从而创建一个特殊的计算上下文。它们分别是：

1.  **函数定义**
    -   **LaTeX**: `f\left(a\right)=c`
    -   **简化记法**: `f(a) = c`
    -   **示例**: `f(a, b) = a^2 + b^2`

2.  **求和**
    -   **LaTeX**: `\sum_{a=1}^{1}c`
    -   **简化记法**: `sum(a=1, 1) c`
    -   **示例**: `sum(i=1, n) 1/i`

3.  **积分**
    -   **LaTeX**: `\int_{0}^{\left[1...5\right]}cda`
    -   **简化记法**: `int(0, [1...5]) c da`
    -   **示例**: `int(0,1) e^x dx`

4.  **with 语句**
    -   **LaTeX**: `c\operatorname{with}a=3`
    -   **简化记法**: `c with a=3`
    -   **功能**: 将其内语句的依赖图中特定变量强制重新定义为给定值。
    -   **示例**:
        ```
        a = 1
        b = 2
        c = a^2 + b^2
        // 'c with ...' 会临时覆盖 a 和 b 的值来完成计算
        d = c with a=40, b=50 // d 的结果是 40^2 + 50^2 = 4100
        ```

5.  **for 语句**
    它主要有两种用法：列表生成和参数曲线。
    -   **用法一：列表生成**
        -   **LaTeX**: `c\operatorname{for}a=\left[1...3\right]`
        -   **简化记法**: `c for a=[1...3]`
        -   **功能**: 引入迭代变量（如 `a`），计算 `a` 等于某列表各项时内部表达式的值，最终输出一个包含各个返回值的新列表。
        -   **示例 1 (无强代换)**:
            ```
            // 计算 2^i mod 7 在 i=0到100的序列，最外层中括号可省略
            mod(2^i, 7) for i=[0, ..., 100]
            ```
        -   **示例 2 (有强代换)**:
            ```
            a = 0 // a=0 会形成一个用户可拖动的滑动条
            P = (1.2^a * cos(a), 1.2^a * sin(a)) // 定义了螺旋线上的一个点 P
            
            // 下面的 for 语句会强行代换 P 中的 a，
            // 模拟 a 在不同角度采样时 P 的位置，生成一系列点来展现螺旋线轨迹。
            P_list = P for a=[0, 0.1pi, ..., 5pi]
            ```
    -   **用法二：参数曲线**
        -   **LaTeX**: `\left(a,a^{2}\right)\operatorname{for}0<a<2`
        -   **简化记法**: `(a, a^2) for 0<a<2`
        -   **功能**: 创建一个“参数化点”类型，用于直接、准确地绘制参数曲线。
        -   **细节**:
            -   其输入值必须是一个点类型，如 `(x, y)`。
            -   `for` 后跟随的局部变量定义语句须为 `min < t < max` 的形式（`>` 和 `<` 也可为 `≥` 和 `≤`）。
            -   这种语句的输出值在 Desmos 的提示文本里被称为“参数化点”类型，这种类型无法参与绝大部分运算，主要只能被赋值或在“参数化点列表”中存取。
        -   **示例**:
            ```
            // 承接上例，将离散的点连接成光滑的参数曲线
            P_curve = P for 0 < a < 5pi
            ```

## “不完整片段”与两种绑定模型

在传统编程中，一个带有未定义变量的表达式 `a + b` 是无法独立存在的，它会立即报错。你必须将它包裹在一个函数 `function(a, b) { return a + b }` 中，才能“延迟”它的计算。

但在 Desmos 中，带有未定义依赖的表达式——我们称之为**“不完整片段” (Incomplete Fragment)**——是完全合法的、可被独立引用和复用的“一等公民”。

**示例1：定义并引用一个“不完整片段”**
```
c = a + b       // c 现在是一个“不完整片段”，因为它依赖未定义的 a 和 b
f(a, b) = c     // 这是合法的！函数 f 成功地引用了片段 c
                // Desmos 理解为 f(a, b) 的结构是 a + b
```
这证明了“不完整片段”`c` 可以像任何普通变量一样被自由传递和引用。

**示例2：将同一个“不完整片段”代入多个下游上下文**
```
c = a + 1                 // 定义“不完整片段” c
c_list = c for a = [1, 2, 3]     // c_list 的结果是 [2, 3, 4]
c_1 = c with a = 10           // c_1 的结果是 11
```
这里，同一个片段 `c` 被两个完全不同的下游结构（`for` 和 `with`）所复用，并且它们各自为 `c` 补上了缺失的定义，得到了不同的结果。这在传统编程中是不可想象的，除非 `c` 被预先定义为一个函数。

可见，Desmos 允许带有未定义依赖的**“不完整片段”**作为一等公民存在。上下文语句的核心功能，就是为这些“不完整片段”提供临时的、局部的定义。

根据它们“补全”片段的方式，这五种语句可以被清晰地分为两种绑定模型：

### 模式一：弱上下文绑定 (Weak Context Binding)

这种模式像一个有礼貌的助手，它会帮你补上表达式里缺失的定义，但绝不会“抢夺”已经明确的定义。

-   **来源**: 函数定义, `sum`, `int`
-   **行为**: 只绑定上游片段中**尚未被定义**的符号（即“填洞”）。如果一个符号在上游片段中已经指向了一个全局定义，弱绑定不会干涉它。

### 模式二：强上下文绑定 (Strong Context Binding)

这种模式则像一个霸道的指令，它会强制性地替换其内部表达式的某个符号，无论那个符号之前指向哪里。

-   **来源**: `with`, `for`
-   **行为**: **强制替换**上游片段中的同名符号，其效力会**覆盖**掉任何已经存在的全局定义。

## 下游如何影响上游：对“作用域”的颠覆

传统编程中的作用域是**隔离的、单向的**。一个内部作用域可以读取外部变量，但它无法改变外部作用域的行为。

**传统编程的“遮蔽”效应：**
```javascript
let a = 1;
let b = a * 2; // b 的值立即被计算并固定为 2

// 定义一个函数，它的参数 a 会“遮蔽”全局的 a
let x = ((a, c) => a + b + c)(100, 0.1);
// 在函数内部，a 是 100，b 依然是 2。
// lambda 表达式无法“回到过去”去影响 b 的计算。
// x 的结果是 100 + 2 + 0.1 = 102.1
```
参数 `a` 只是一个与全局 `a` 同名的、新的局部变量，它起到了**遮蔽 (shadow)** 作用，但无法干涉上游。

然而，在 Desmos 中，这种隔离被打破了。一个处于**下游**的结构，可以沿着依赖关系图**向上追溯**并影响上游片段的解析。

**Desmos 的“追溯”效应：**
```
a = 1
b = a * 2

// 'with a = 100' 是一个下游节点
// 但它会沿着依赖图向上追溯到 b，并影响 b 的解析
y = b with a = 100 

// 在计算 y 时，Desmos 会这样分析：
// 1. y 依赖 b。
// 2. b 的结构是 a * 2。
// 3. 应用下游 'with' 语句的规则，将 b 结构中的 a 临时替换为 100。
// 4. 因此，b 被临时解析为 100 * 2 = 200。
// y 的最终结果是 200。
```
这就是“下游覆盖上游”感觉的来源。它揭示了 Desmos 的本质：这里没有被层层隔离的作用域，只有一个统一的、全局的依赖关系图。

## 新模型：一个包含“上下文语句节点”的依赖图

这个“下游影响上游”的现象，揭示了我们必须放弃传统的“全局/局域”作用域观念。我们提出一个更精确的模型：

1.  **抛弃“全局/局域”概念**：在 Desmos 中，所有符号和表达式都存在于一个巨大的、统一的**依赖关系图 (DAG)**。公式列表和符号集合可以类比为这张图的 SLP(Straight-Line Program, 直线程序)表征。
2.  **引入“上下文语句节点”**：我们不再称 `with`, `for`, `sum`, 函数定义等为“作用域语句”，而是改称为**“上下文语句节点” (Context Statement Node)**，就像其他表达式节点一样存在于依赖图中。
3.  **上下文的链式叠加**：这些“上下文语句节点”存在于依赖图的下游。它们的功能是为所有它们所依赖的**上游节点**，追加一套临时的解析规则。当一个节点被多个上下文节点嵌套时，这些规则会**链式叠加**，共同决定最终的解析行为。

## 附录：边界规则与限制

实验发现：

1. 为避免二义性，Desmos 对上下文语句的嵌套施加了严格的规则：

    -   **禁止同名局部变量嵌套**: 任何两个引入**同名**上下文变量的上下文语句（无论类型）都不能相互嵌套。例如 `sum(i=1, 5) ... sum(i=1, 10) ...` 会直接报错。
    -   **`with` 语句的特殊限制**: `with` 语句只能嵌套一层，无论其代换变量名是否重合。但如果中间嵌套了一层以上的函数定义，则这个检查会被阻断，不会报错，也就是说实际上是“在同一层函数定义上下文 / 全局作用域内，with 语句不支持嵌套”。
        ```
        f(p) = p with p = q
        b = f(a) with a = 10 // 不会报错
        ```

除此之外上下文语句可以自由组合嵌套。

2.  **函数定义的严格性**: 函数定义体在定义时会立即检查所有依赖（包括所有分支），任何未定义的依赖都会导致**“阻断性错误”**，使函数定义和所有对该函数的调用立即失败。
