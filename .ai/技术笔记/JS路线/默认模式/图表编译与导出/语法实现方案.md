# 语法实现方案 (Based on Chevrotain)

本文档详细描述如何使用 Chevrotain 实现 Destra Expr DSL 的解析器。

## 1. 总体架构

解析过程分为三个阶段：
1.  **预处理 (Preprocessing)**: 将 Template Strings (`strings`, `values`) 转换为单一的 "Source String"，并将插值替换为特殊的占位符 Token。
2.  **词法分析 (Lexing)**: 将 Source String 转换为 Token Vector。
3.  **语法分析 (Parsing)**: 构建 CST (Concrete Syntax Tree)。
4.  **AST 构建 (Visiting)**: 将 CST 转换为 Destra 内部的 AST，并还原插值对象。

## 2. 词法分析 (Lexer)

### 2.1 占位符策略
使用特殊模式 `§_PH_(\d+)_§` 替换插值。
- Token: `Placeholder`
- Pattern: `/§_PH_\d+_§/`

### 2.2 Token 定义优先级 (从高到低)

由于 Chevrotain 使用 "First Match" 原则，顺序至关重要。

1.  **Whitespace**: `/\s+/` (Skipped)
2.  **Comment**: `/\/\/.*/` (Skipped)
3.  **Placeholder**: `§_PH_..._§`
4.  **Numbers**:
    - `NumberLiteral`: `/(\d+(\.\d*)?|\.\d+)/` (不支持科学计数法 e，因为 e 是常量)
5.  **Keywords (Context & Operators)**:
    - `For`: "for"
    - `With`: "with"
    - `In`: "in"
    - `Sum`: "sum"
    - `Prod`: "prod"
    - `Int`: "int"
    - `Diff`: "d/d" (用于 d/dx)
    - `Of`: "%of"
    - `RootOf`: "rootof"
6.  **Desmos Constants/Reserved**: (可选，或者作为 Identifier 处理)
    - `Pi`: "pi"
    - `Tau`: "tau"
    - `Infinity`: "infinity" | "infty"
    - `Theta`: "theta"
    - `Phi`: "phi"
    - ...
7.  **Operators**:
    - `Action`: "->"
    - `LessEq`: "<=" | "\\le"
    - `GreaterEq`: ">=" | "\\ge"
    - `Equal`: "=" | "==" (注意顺序，== 在 = 前)
    - `NotEqual`: "!=" (如果有)
    - `Less`: "<"
    - `Greater`: ">"
    - `Tilde`: "~" (Regression)
    - `RangeDots`: "..."
    - `Plus`: "+"
    - `Minus`: "-"
    - `Multiply`: "*"
    - `Divide`: "/"
    - `Power`: "^"
    - `Bang`: "!"
8.  **Punctuation**:
    - `LParen`: "("
    - `RParen`: ")"
    - `LBracket`: "["
    - `RBracket`: "]"
    - `LBrace`: "{"
    - `RBrace`: "}"
    - `Comma`: ","
    - `Colon`: ":"
    - `Dot`: "." (Property access)
9.  **Identifiers**:
    - `Identifier`: `/[a-zA-Z_][a-zA-Z0-9_]*/` (覆盖所有函数名和变量名)

## 3. 语法规则 (Parser Rules)

### 3.1 顶层规则 (Root Rules)

我们需要一个统一的入口 `Formula`，但根据 `expr` 和 `expl` 的不同，可能需要支持部分解析。

```typescript
// 伪代码

Formula
  = Definition        // x = ... or f(x) = ...
  | Regression        // y ~ ...
  | EquationOrExpression
```

- **Definition**: `Identifier` [ `LParen` Params `RParen` ] `Equal` `Expression`
- **Regression**: `Identifier` `Tilde` `Expression`
- **EquationOrExpression**:
    - 这里比较棘手，因为 `x^2 + y^2 = 1` 是方程，`1 + 1` 是表达式。
    - 策略：统一解析为 `ComparisonExpression`。
    - 如果顶层操作符是 `=`, `<`, `>`, `<=`, `>=`，则视为方程/不等式。
    - 否则视为普通表达式（后续分析阶段可能将其提升为显式方程，如 `x^2` -> `y=x^2`）。

### 3.2 表达式优先级 (Precedence) - 从低到高

1.  **ContextStatement**:
    - `Expression` `For` ...
    - `Expression` `With` ...
    - `Sum`/`Prod` ...
    - `Int` ...
    - `Diff` ...
    - *注：For/With 的优先级非常低，仅高于加减？参考文档说是“仅高于加减”。需仔细核对。文档说 "For ... 优先级仅高于加减法"。这意味着 `a * b for ...` 解析为 `a * (b for ...)` 还是 `(a * b) for ...`？*
    - *修正：Desmos 中 `1 + 2 for ...` 是 `1 + (2 for ...)`。所以 Context 的优先级很低。*
    - *建议层级*: `ContextExpression` 是基础。
    - `ComparisonExpression` (包含 `=`, `<`, `>`) -> 依赖 `ActionExpression`
    - `ActionExpression` (`->`) -> 依赖 `AdditiveExpression`
    - `AdditiveExpression` (`+`, `-`, `Context`) -> *Wait, if For is higher than +/-?*
    - *根据文档*: "Context 优先级仅高于加减法" => 比乘法低，比加法高？
    - 让我们重新梳理文档中的优先级列表：
        1. 属性/函数调用
        2. 阶乘/索引
        3. 指数
        4. 根号
        5. 一元 +/-
        6. 省略括号函数
        7. 乘除
        8. **上下文 (For/With/Sum/Int/Diff)**
        9. 加减
        10. 动作 (->)
        11. 比较/赋值 (=, <, ...)

    **Parser Rule Hierarchy (Top down):**

    - **Formula**
    - **ComparisonExpression** (`=`, `<`, `~` for regression if handled here)
    - **ActionExpression** (`->`)
    - **AdditiveExpression** (`+`, `-`)
    - **ContextExpression** (`For`, `With`, `Sum`, `Int`, `Diff`)
        - 注意：`For` 和 `With` 是后缀/中缀结构 (`Expr for Var=List`)
        - `Sum`/`Int` 是前缀结构 (`sum(...) Expr`)
        - 这里需要处理好递归。
    - **MultiplicativeExpression** (`*`, `/`, `%of`)
    - **ImplicitMulExpression** (省略括号的函数调用, e.g. `sin x`)
    - **UnaryExpression** (`-`, `+`)
    - **RootExpression** (`rootof`)
    - **PowerExpression** (`^`)
    - **PostfixExpression** (`!`, `[...]` Indexing)
    - **AtomicExpression**
        - `Number`
        - `Identifier` (Variable)
        - `Placeholder`
        - `FunctionCall` (`Id(...)`)
        - `Parenthesis` (`(...)`)
        - `List` (`[...]`)
        - `Piecewise` (`{...}`)
        - `String` (Color hex?)

### 3.3 关键结构细节

#### Context Statements
- **For**: `Expression` "for" `AssignmentList`
- **With**: `Expression` "with" `AssignmentList`
- **Sum/Prod**: "sum" `LParen` `Assignment` `RParen` `Expression`
- **Int**: "int" `LParen` `Expression` `Comma` `Expression` `RParen` `Expression` "d" `Identifier` (需处理 `dx` 位置)

#### List & Ranges
- `[ 1, 2, 3 ]`
- `[ 1, ..., 10 ]`
- `[ 1, 3, ..., 10 ]`
- 规则：`LBracket` `ListElements` `RBracket`
- `ListElements`: `Expression` ( `Comma` `Expression` )* [ `RangeDots` `Expression` ]

#### Function Call vs Property Access
- `Identifier` `LParen` ... `RParen`
- `Atomic` `Dot` `Identifier`

## 4. AST 设计 (Visiting)

CST 产生后，Visitor 将其转换为 AST。

### 4.1 AST 节点类型 (简化)
- `Literal`: Number, String
- `Identifier`: Symbol name
- `Placeholder`: Reference to `Expl`/`Expr` object
- `BinaryExp`: op, left, right
- `UnaryExp`: op, arg
- `CallExp`: callee, args
- `ListExp`: elements
- `RangeExp`: start, next?, end
- `PiecewiseExp`: branches [(condition, value)], default
- `ContextExp`: type (sum/for...), variables, body
- `Definition`: variable, value
- `Regression`: dependent, expression

### 4.2 类型推断与后期处理
在 AST 构建完成后，执行 `analyzeAST(ast)`：
1.  **FormulaType 判定**:
    - 如果根节点是 `Definition` -> `FormulaType.Definition` / `Function`
    - 如果根节点是 `Regression` -> `FormulaType.Regression`
    - 如果根节点是 `BinaryExp` 且 op 是 `=`, `<`, `>`... -> `FormulaType.Equation` / `Inequality`
    - 否则 -> `FormulaType.Expression`
2.  **隐式显式方程判定**:
    - 如果类型是 `Expression`，且 AST 中包含对 `x` (2D) 或 `x, y` (3D) 的引用，且不包含其他未定义变量 -> 标记为 "ImplicitExplicit" (将在导出时补全 `y = ...`)。
3.  **Regression 参数提取**:
    - 遍历 Regression 右侧 AST。
    - 收集所有 `Identifier`。
    - 排除：保留变量 (x, y...)、内置函数、Math 常量。
    - 排除：在 Regression 作用域内定义的 Context 变量。
    - 剩余的即为回归参数。

## 5. 实现计划

1.  **Lexer**: 定义所有 Token。
2.  **Parser**: 实现各级优先级规则。
3.  **Visitor**: 实现 CST -> AST 映射。
4.  **Integration**: 替换 `expr-dsl-new/index.ts` 中的工厂逻辑。
