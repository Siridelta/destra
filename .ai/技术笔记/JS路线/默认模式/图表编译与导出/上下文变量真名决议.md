# 上下文变量真名决议

> 本文档是 [编译与导出](./index.md) 流程中 "Step 3: 上下文变量真名决议" 的详细实现方案。它解决了在 DAG 依赖结构下，如何为上下文变量分配全局唯一或上下文安全的 Latex 真名。

## 概念定义与方向说明

在深入讨论之前，必须明确“上游/下游”和“父/子”等方向性概念，因为在 Destra 中存在两种反向的图结构：

1.  **数据依赖方向 (Data Dependency)**:
    *   方向: `User <- Dependency` (用户 <- 依赖)。
    *   例如 `A = B + 1`，则 `A` 依赖 `B`。`A` 是 B 的**下游**。
    *   在图中箭头通常画为 `A <- B`；JS 对象里引用方向相反，`A` 持有对 `B` 的引用。

2.  **上下文覆盖方向 (Context Coverage)**:
    *   方向: `Outer Context -> Inner Content` (外层 -> 内层)。
    *   例如 `S1 = Sum(n1, S0); S0 = Sum(n0, body(n1, n0))`，`S1` 提供了变量 `n1`，`S0` 提供了变量 `n0` 给 `body(n1, n0)` 使用。
    *   从数据依赖看，`S1` 依赖 `S0`, `S0` 依赖 `body(n1, n0)` (`S1 <- S0 <- body(n1, n0)`)，`S1` 是 `S0` 的下游。
    *   但从上下文作用域看，`S1` 是 `S0` 的**外层/祖先 (Ancestor)**，`S0` 是 `S1` 的**内层/子 (Child)**。上下文环境是**逆着数据依赖箭头**传播的。

**本文档中的约定**:
*   **Scope DAG**: 节点为 Scope (CtxExp/AST Clause)。边 $S_{parent} \to S_{child}$ 代表 $S_{parent}$ 物理上包裹了 $S_{child}$。
*   **上游/Parent (Scope)**: 指上下文覆盖关系中的外层/祖先（对应数据依赖图中的下游）。
*   **下游/Child (Scope)**: 指上下文覆盖关系中的内层/子（对应数据依赖图中的上游）。
*   **传播 (Propagation)**: 指上下文环境信息（如已占用的变量名）从 Scope Parent 向 Child 流动。

---

## 核心挑战：DAG 下的命名一致性

由于 Destra 允许公式复用，一个公式对象可能同时被多个外层 Context 引用。

```javascript
// Scope F (For i, j)
const F = expl.For`i=[1...10], j=[1...10]`(({i, j}) => expr`${i}^2 + ${j}^2`)

// Path A: A (Sum i) -> F
const A = expl.Sum`i=1, 10`(i => expr`${F}[ (${i} - 1) * 10 + 1]`)
// Path B: B (Sum j) -> F
const B = expl.Sum`j=1, 10`(j => expr`${F}[ (1 - 1) * 10 + ${j}]`)

// root entry:
const root = expr`${A} + ${B}`;
```

在此场景下：
1.  **Scope 共享**: `F` 在逻辑上同时是 `A` 和 `B` 的子 Scope。这构成了一个 **Scope DAG**（而非 Tree）。
2.  **命名静态性**: `F` 最终生成的 Latex 代码是静态唯一的。这意味着 `F` 内部选用的变量名（如 `i` 或 `i_{1}`）必须同时在 `Path A` 和 `Path B` 中合法。
3.  **约束聚合**: `F` 必须避让 `A` 中定义的 `i`，同时也必须避让 `B` 中定义的 `j`。

---

## 解决方案：Scope DAG 与约束聚合

我们采用 **拓扑真名决议 (Topological Name Resolution)** 算法。

在每个 Formula 的 Sidecar State 里记录 `state.ctxNameResolution: CtxNameResolutionState` 组分，
```typescript
interface CtxNameResolutionState {
    inDegree: number;  // 拓扑排序 - 入度记录
    users: Set<Formula>;  // 使用者集合 (backtracking, 与公式里定义的 deps 依赖项集合方向相反，反向引用)

    closestScopes: Set<ScopeNode>;  // 最近的 Scope 节点集合（见下文）
    overrideOutputClosestScopes: WeakMap<Formula, Set<ScopeNode>>;  // 对每个 dep Formula 覆盖性输出哪些 Scope Nodes（见下文）
}
```

### Phase 1: 构建 Scope DAG (Scope Propagation)

首先，我们需要基于数据依赖图构建出一个平行、精简（只包含必要节点）、且精细（包含AST内部上下文语句节点）的 Scope DAG。由于 AST 内部可能包含复杂的嵌套结构，这一步必须深入 AST 层面。

**输入**: Formula 依赖图 (经过 Step 1.5 验证合法)。
**输出**: Scope DAG (节点为 `ScopeNode`, 边为 `Parent -> Child`)。

**ScopeNode 定义**:
*   `Root`: 全局根节点，对应 Formula 依赖图的根节点（可能会少于 Graph.roots，为出度为0的真正“根”的节点）。
*   `CtxExpScope`: 对应 `CtxExp` 公式对象。
*   `InternalClauseScope`: 对应 AST 内部的 Context Clause (如 `sum(...)`)。

```typescript
interface ScopeNode {
    id: string;  // 唯一标识符
    type: "Root" | "CtxExpScope" | "InternalClauseScope" | "FuncExplScope";
    name: string;  // Destra 变量名，ID / 上下文变量名 / AST 内变量名
    realname: string;  // 决议后的真名
    children: Set<ScopeNode>;  // 子节点集合
    parents: Set<ScopeNode>;  // 父节点集合
}
interface RootScopeNode extends ScopeNode {
    type: "Root";
}
interface CtxExpScopeNode extends ScopeNode {
    type: "CtxExpScope";
    context: CtxExp;
}
interface FuncExplScopeNode extends ScopeNode {
    type: "FuncExplScope";
    context: FuncExpl | CtxFuncExpl;
}
interface InternalClauseScopeNode extends ScopeNode {
    type: "InternalClauseScope";
    context: CtxClauseASTNode;
    host: Formula;
}
```

**构建算法**:
1.  **倒序拓扑排序 (Reverse Topological Sort)**: 对 Formula 依赖图进行拓扑排序，然后倒转序列，即一个 `User` 排在其所有 `Dependency` 之前。
    *   首先自顶向下遍历公式依赖图，寻找第一批入度为 0 的节点（指数据依赖的入度为0，即没有依赖项），加入队列，同时加入输出序列的头部。
    *   分批处理，每次循环处理一批入度为 0 的节点，移出队列，并 backtrack 所有下游 users，将下游的 inDegree 减 1。如果减 1 后 inDegree 为 0，则加入队列，同时加入输出序列的末尾。
    *   重复上述过程，直到队列为空。
    *   同时记录所有出度为0的节点，构建 Roots 集合，供后续使用。
    *   将得到的输出序列倒转，供后续使用。
    *   **输出**: `RTSeriesFormula: Formula[]`, `roots: Set<Formula>`。

2.  **Scope 覆盖信息传播 & Scope DAG 构建**: 按拓扑倒序顺序，传播式地计算和记录每个 Formula 节点 / 关键 AST 节点 处于哪些上下文作用域内，这些信息即为一个关键节点的"Scope 覆盖信息"；同时构建 ScopeNode 和 Scope DAG。
    *   CtxNameResolutionState 释义：
        *   理论上我们应该记录一个 `scopes: Set<ScopeNode>`，代表该公式处于哪些上下文语境当中，体现为 Scope DAG 里的 Scope 节点集合。
        *   但实际上，我们不需要记录它所处的所有上下文语境。我们只需要构建 Scope DAG，然后在 Scope DAG 里按拓扑倒序决议真名，所有外层语境的作用自然就会叠加到 Scope Node 上。
        *   因此我们只需要记录一个 `closestScopes` 集合，它代表了 Scope DAG 里所有从根到本公式的路径上最末端、最靠近本公式的 Scope 节点的集合。

        ```typescript
        interface CtxNameResolutionState {

            // 最近的 Scope 节点集合，表示 Scope DAG 里所有从根到本公式的路径上最末端、最靠近本公式的 Scope 节点的集合。
            // 它是传播的“前沿”，对新建的 Scope Node 节点如何接入 Scope DAG （以哪些节点为 Parent）提供指导。
            closestScopes: Set<ScopeNode>;  
            
            // 由于 Internal AST 型 Formula 对象的特殊性，它向各 dep 输出的信息会有差异性/特异性
            // 需要额外记录，对每个 dep Formula 重载性输出哪些 Scope Nodes
            overrideOutputClosestScopes: WeakMap<Formula, Set<ScopeNode>>;  
        }
        ```
    
    *   建立 `rootScopeNodes` 集合，包含所有 Root Formula 创建的 Root ScopeNode 节点。

    *   按照排序依次遍历每个 Formula `F`:
        *   传播 `scopes` = $\bigcup_{U \in Users(F)} U.outputScopes(to \ F)$。
            *   $U.outputScopes(to \ F) = U.scopes \cup U.additionalOutputScopes(to \ F)$。
        *   传播 `closestScopes` = $\bigcup_{U \in Users(F)} U.outputClosestScopes(to \ F)$。
            *   $U.outputClosestScopes(to \ F) = U.overrideOutputClosestScopes(to \ F) \ ?? \ U.closestScopes$。
        *   如果 `F` 是 `CtxExp`:
            *   创建一个新的 ScopeNode `CtxExpScope S`。
            *   建立边: $\forall P \in closestScopes, P \to S$。
            *   `S.context` 属性设置为 `F`。
        *   如果 `F` 是 `FuncExpl`:
            *   创建一个新的 ScopeNode `FuncExplScope S`。
            *   建立边: $\forall P \in closestScopes, P \to S$。
            *   `S.context` 属性设置为 `F`。
        *   如果 `F` 包含 Internal AST:
            *   在 AST 上进行精细传播，传播 `overrideOutputClosestScopes` 集合，初始化为空集合，在传播分叉上创建新的集合对象，不要传递旧有集合的引用。
            *   遇到 Context Clause AST 节点时:
                *   创建 `InternalClauseScope S`。
                *   `S.context` 属性设置为 AST 节点。
                *   `S.host` 属性设置为 `F`。
                *   建立边: $\forall P \in overrideOutputClosestScopes \ ?? \ closestScopes, P \to S$。
                *   重写 `overrideOutputClosestScopes` 集合为 `S`。
            *   AST 中的插值节点 (`Substitution`) 负责将当前的 Scope 集合传递给依赖的 Formula。在插值节点停止，返回设置该 dep Formula 在 `F` 中的 `overrideOutputClosestScopes`。
    *   在创建 Scope Node 时同时把 Scope Node 加入到一个新的拓扑倒序序列中 `RTSeriesScopeNode: ScopeNode[]`，遍历顺序可以保持序列为 Scope DAG 的拓扑倒序，用于后续真名决议。

    *   **输出**: `RTSeriesScopeNode: ScopeNode[]`, `rootScopeNodes: Set<ScopeNode>`。

### Phase 2: 真名决议 (Resolution)

在构建好的 Scope DAG 上进行命名分配。

**算法**:
1.  按 `RTSeriesScopeNode` 的拓扑顺序依次遍历每个 Scope Node (Parent -> Child)，依次决议每个 Scope Node 的真名。
2.  **Constraint Aggregation (约束聚合)**:
    *   对于每个 Scope 节点 `N`:
    *   计算 **禁止名称集合**: $Forbidden(N) = \bigcup_{P \in Parents(N)} (Forbidden(P) \cup Used(P))$。
    *   *解释*: 节点 `N` 必须避让所有父节点路径上已经使用的名字，以及父节点本身被禁止使用的名字（传递性）。
3.  **Name Assignment (命名分配)**:
    *   对于 `N` 中定义的每个变量 `v`:
        *   **Case A: 强制命名 (Forced)**:
            *   如果用户指定了 `realname`，检查是否在 $Forbidden(N)$ 中。
            *   若冲突，报错（或尝试自动后缀？通常强制命名意味着用户后果自负，报错更安全）。
            *   若无冲突，分配该名字。
        *   **Case B: 自动命名**:
            *   候选名 = `v.originalName`。
            *   如果候选名在 $Forbidden(N)$ 或本节点已分配集合中，尝试添加后缀 `_{2}`, `_{3}`... 直到无冲突。
    *   将分配的名字加入 `Used(N)`。

---

## 关键细节

### 1. Shadowing/Overriding 和避让原则

如果有一个子域的变量名与（一个或以上）父域重名，那么子域必须同时避让所有父域的变量名。

在 Desmos 里如果不做避让，有时候 Desmos 会展现出覆盖/Shadowing效果，有时候会展现出覆盖/Overriding效果，有些时候会报错。

并且用户的逻辑里可能就是要指定使用上下文语句覆盖链里的某一个特定语句节点的那个变量名，而不是其他语句节点的那个变量名。这些选择完全可能与 Desmos 的重名覆盖特性对抗。

因此，Destra 默认策略是**主动避让 Shadowing**，即在一条上下文语句链里，总是生成唯一名字。

### 2. Internal AST 的处理
Internal AST (DSL) 中的变量名虽然只在局部有效，但也参与全局的避让逻辑。
*   例如 `sum(n=1,10, n^2)`。
*   虽然 `n` 实际上只在 `n^2` 里有效，但在生成 Latex 时，如果有外层变量也叫 `n`，Desmos 可能会产生 Shadowing 歧义。
*   因此，Internal Scope 同样作为 DAG 节点参与上述流程。

### 3. Sidecar State 存储
计算结果（Realname）将存储在 Formula 的 Sidecar State 中，供后续 Latex 生成步骤直接读取。

```typescript
// state.ts
interface CtxVarState {
    realname?: string; // 决议后的真名
}

interface ASTNodeState {
    // 对于 Internal AST 中的变量定义节点
    realname?: string;
}
```

### 4. 为什么不使用全局唯一命名？
虽然全局唯一命名（如 `v_1`, `v_2`...）工程上最简单，但它严重损害了 Latex 的可读性。Destra 的目标是生成“像人类手写一样的”公式。
通过 **Scope DAG + 约束聚合**，我们实现了：
*   **可读性**: 在无冲突时保留短名字（如 `i`, `n`）。
*   **安全性**: 在 DAG 复杂复用场景下，自动退化为带后缀的安全名字，杜绝歧义。

### 5. 优化：惰性聚合与 Expl 边界
*   **Expl 边界**: 具名公式 (`Expl`) 是静态编译单元。一旦经过 Expl，Scope 传播是否可以简化？
    *   Expl 内部的 Latex 是固定的。这意味着 Expl 内部的 Scope 决议必须在 Expl 自身编译时完成，且结果对于所有引用者是**不变的**。
    *   这实际上将 Scope DAG 切分成了若干个子图。每个 Expl 是一个子图的根。
    *   **但是**，Expl 内部引用的 **自由变量 (Free Variables)**（即来自 Expl 外部 Context 的变量）的命名，是由外部决定的。
    *   **修正**: Expl 内部定义的变量名是固定的（相对于 Expl 自身）。但如果 Expl 引用了外部 CtxVar，该 CtxVar 的名字由外部决议。
    *   我们的算法天然涵盖了这一点：Expl 只是 DAG 中的一个普通节点，Scope 传播会穿透它。

---

## 总结

Step 3 通过构建 **Scope DAG** 并执行 **拓扑约束聚合**，在保证数学含义正确（无歧义）的前提下，最大程度地保留了变量命名的可读性。这虽然比 Scope Tree 或全局唯一命名复杂，但对于一个旨在生成高质量 Desmos 图表的框架来说，是必要的投入。
