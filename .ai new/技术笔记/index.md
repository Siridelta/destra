# Destra 技术笔记

> 本文档库是 Destra 项目的核心技术区域，旨在循序渐进地介绍项目的设计思路与各类可能的最终实现技术方案。

## 简介

这里集中存放所有的技术相关文档。我们建议您从下文的“Destra 设计基础”开始阅读，它将引导您理解项目最核心的设计由来。在理解了共通的设计基础后，您可以进一步深入阅读各个具体技术路线的实现细节。

如果想要理解项目演进过程中的技术决策背景，请参考[技术设计记录](../技术设计记录/)目录下的相关文档。

## 内容目录

-   [JS路线](./JS路线/) - 当前主推的 JavaScript 技术路线，包含了“默认模式”等核心设计的详细方案。
-   [Julia路线](./Julia路线/) - 项目早期的 Julia 技术路线，相关文档已归档于此，作为历史参考。

---

## Destra 技术方案概述

Destra 项目的起点非常纯粹：**我们希望用一种通用的编程语言，以代码的形式来创建、组织和管理复杂的 Desmos 图表**，从而获得代码所带来的模块化、可复用性、版本控制等强大能力。

想象一下这个场景：用户不通过 Desmos 的原始 UI 来编辑图表公式内容，而是在浏览器旁边打开一个 IDE，在里面编写一套代码，如果可以的话我们甚至能做到热更新，让浏览器里的图表实时跟随代码内容更新，用户实时看到图表的变化并调试修改。用户甚至能调用来自其他开发者开发的，封装了数学计算逻辑的“轮子”或库来编程这些项目。

我们让用户的操作空间，从 Desmos 的 UI 和公式列表构成的原生空间，提升到了一个更加自由、灵活、可扩展的编程空间；而我们则提供了一个能够把后者空间映射回前者空间，甚至能够实时进行这些映射更新的工具。

首先 Desmos 本身有几个对我们来说很关键的特性：

1.  **最终产物是固定的**：无论我们的代码如何组织，最终交付给 Desmos 的**唯一**产物是一个特定结构的 **State JSON 对象**。
2.  **世界是扁平的**：Desmos 没有模块或命名空间，所有变量都存在于一个单一的全局列表“公式列表”中。这个列表的每个元素都是一个“公式”，每个公式如果是声明式公式，就会有一个与之关联的符号名称。这意味着**命名冲突**是一个从起点就必须解决的核心问题。（同时 Desmos 符号名称的合法范围要比编程共识里的变量名合法范围窄的多，因此开发一个转换名称和解决冲突的机制显得更加必要了）
3.  **语言是声明式的**：在 Desmos 中，`y = x + 1` 是一个永恒的“关系”声明，而非一次性的“计算”指令。
4.  **计算依赖于关系网 (DAG)**：所有公式组成了一张依赖关系图。一个值的改变会顺着这张网传播。

以及，为了明确一下概念，say，在一个用户从 Destra 到 Desmos 的开发场景中，Desmos 图表的信息以三种形式存在：

1.  **Destra 模型**：这是 Destra 项目内部的模型，本质是 JS 代码和内存对象，包含了所有公式、变量、函数等信息的结构化表示。

2.  **Desmos State JSON**：这是 Desmos 图表的序列化格式，也是我们最终需要生成的目标格式。它包含了图表的所有信息，包括表达式、样式、设置等。

> Desmos State JSON 来源于 Desmos 官方提供的一对 API `calcualtor.getState()` 和 `calculator.setState(state)`，官方建议不要变动 State JSON 的内容，而只是把它用作与存档管理对接的 API —— 但是我们社区普遍不管！深入分析 Desmos State JSON 的功能和结构，给予了我们由代码对象确定性地转化为 Desmos 图表的可能。

3.  **Desmos 内部数据**：Desmos 内部所存储的数据和机制，这是我们无法直接访问，但需要理解其工作原理来设计我们的建模系统，基本上代表了最终待呈现给用户的 Desmos 图表数据。

### 工具的核心构成

基于对 Desmos 特性的理解，我们可以推导出，任何想要以代码形式操作 Desmos 的工具，都必须包含以下几个核心的“桥梁”部件：

1.  **一种“表达式对象”**：我们必须将代码中的公式转换为结构化的数据对象，这个对象必须能承载其**数学内容**和**依赖关系**，以便后续构建关系网；同时也应该有一个代表 Desmos “公式列表” 的对象，用于以类似 Desmos 的公式列表的方式集合所有公式，用于导出。
2.  **一套“命名策略”**：必须有一套机制，将我们代码中模块化的、有层次的变量名，**翻译**成 Desmos 中扁平的、唯一的、不会冲突的最终名称。
3.  **一个“构建/编译”过程**：必须有一个明确的步骤，负责收集所有表达式对象、分析依赖关系、运行命名策略，并最终将这一切**翻译**成最终的 State JSON 对象。
4.  **一套支持“实时预览”的 DevEx 支持体系**：必须有一套机制，能够支持用户进行这种“在 IDE 中编写代码，在浏览器中实时预览代码的运行结果”的工作流，例如一个 Dev Server，并提供相应的调试和修改功能。

### 决策：技术路线的选择

在明确了我们必须构建的工具形态后，下一个问题就是：**用什么语言来实现最合适？**

项目早期曾考虑并尝试过 **Julia** 路线。Julia 强大的元编程能力和为科学计算而生的特性，使其在理论上非常适合构建此类符号计算系统。

然而，经过深入评估，我们最终将重心**转向了 JavaScript**。主要原因有三：
1.  **生态系统与开发者基础**：JavaScript 拥有无与伦比的社区、工具链（如 Vite）和开发者基础，这极大地降低了项目的参与门槛和工程化难度。
2.  **与 Web 的无缝集成**：Desmos 是一个 Web 应用。使用 JS 可以直接在浏览器环境中运行，与目标平台天然同构，避免了编译到 WebAssembly (WASM) 等跨语言操作带来的复杂性。
3.  **PSADestra 项目协同**：与同样基于 Web 技术的 PSADestra 项目集成时，统一使用 JS 技术栈能实现最高效的协同开发。
4.  **基于模板字符串的成熟 DSL 范式**：虽然 JS 在语言层面（如无法重载运算符）不如 Julia 适合数学表达，但 JS 社区已广泛采用“模板字符串”来创建内嵌式领域特定语言（DSL），并拥有 `styled-components` (CSS) 和 `lit-html` (HTML) 等大量成功先例。这条路线证明了我们可以为 `Expr DSL` 提供成熟的工具链支持（如语法高亮、自动补全），从而扬长避短，在享受 JS 巨大生态优势的同时，获得媲美原生数学语言的开发体验。

因此，当前 Destra 项目以 **JavaScript** 为主要技术路线进行开发，未来再考虑开发 Julia 路线。

两个路线的详细技术文档请参考：

- [JS路线](./JS路线/) - 当前主推的 JavaScript 技术路线，包含了“默认模式”等核心设计的详细方案。
- [Julia路线](./Julia路线/) - 项目早期的 Julia 技术路线，相关文档已归档于此，作为历史参考。

### 大致功能目标

基于以上设计基础，我们可以进一步明确，任何一个成熟的 Destra 技术方案，都应致力于实现以下几个核心功能目标：

1.  **核心建模能力**：
    -   **表达式建模**：提供强大而灵活的 API 来在代码中表示 Desmos 的各类表达式（变量、函数、方程等）。
    -   **依赖关系管理**：自动分析和处理表达式之间的依赖关系，构建稳定、无冲突的计算图。

2.  **模块化与分发**：
    -   **封装与复用**：支持用户将一组相关的数学逻辑封装成可复用的组件或库。
    -   **分享与分发**：提供清晰的模块化机制，让用户能方便地通过 npm 等渠道分享和分发自己的创作，共建社区生态。

3.  **可视化与交互配置**：
    -   **属性设置**：允许用户通过代码精细地控制公式的各类属性，包括计算属性（如滑动条范围）和显示属性（如颜色、线宽、点样式等）。
    -   **图表全局设置**：提供配置整个图表区（Graph Settings）的能力，如坐标轴范围、角度单位等。

4.  **开发者体验 (DevEx) 与工具链**：
    -   **实时预览工作流**：提供开发服务器（Dev Server）等工具，实现“在 IDE 中编写代码，在浏览器中实时预览图表”的无缝开发体验。
    -   **生态集成**：与 PSADestra 等外部工具深度集成，并为 IDE 提供语法高亮、错误提示等增强支持。

5.  **性能与可伸缩性**：
    -   **性能优化**：确保在处理大规模、高复杂度的图表时，依然能保持高效的编译速度和流畅的运行性能。

