# 属性与样式API

> 本文档详细阐述 Destra “默认模式”中两类核心属性——计算属性（Slider）与显示属性（样式）——的设计理念与 API。

在 Destra 中，表达式的属性被明确地划分为两大类，它们的行为和设计理念截然不同，这直接指导了 API 的设计。

## 1. 核心原则：计算图不可变，可视化图可变

我们通过对 Desmos 行为的深入分析，可以用两种等价的视角来理解这个模型：

**1. 双依赖图表征**:
这是从整个系统的宏观结构出发的模型。

-   **计算依赖图 (Calculation Graph)**:
    *   **内容**: 包含公式的数学内容以及 **Slider 属性** (`min`, `max`, `step`)。
    *   **特性**: 这是一个严格的、禁止循环的依赖图。任何在此图上产生循环依赖的操作都会导致 Desmos 报错。
    *   **API 设计**: 因此，这部分对应的 API 必须设计为**不可变的**，在表达式创建时一次性定义。

-   **可视化依赖图 (Visualization Graph)**:
    *   **内容**: 包含所有**显示属性**（颜色、线宽、点大小等）和**标签内容**。
    *   **特性**: 这是一个次级的、更宽松的图。它的更新发生在计算图完成之后，它所依赖的是计算图的**最终输出值**，而非其内部结构，并且计算依赖图没有反向依赖（即两个图在一起没有构成循环）。因此，它允许出现表面上看似“一个表达式依赖另一个表达式，但是样式上反过来依赖，好像循环了”的依赖，但实际上没有循环。
    *   **API 设计**: 这部分对应的 API 可以被设计为**可变的**，允许在表达式创建后随时、动态地进行修改。

**2. 分层节点表征**:
这是从单个公式节点的内部结构出发的模型。

-   可以认为一个顶层的“公式节点”下辖两个子节点：
    *   **内容定义节点**：包含符号名、数学表达式和 **Slider 属性**。所有跨公式的计算依赖都指向这类节点，而非顶层的公式节点。
    *   **元数据节点**：包含**显示属性**和标签等。它们依赖于内容定义节点的计算结果，但没有反向的依赖边，因此不会在计算图中产生循环。

**统一的结论**:
这两种模型都导向了同一个结论：Slider 属性必须在表达式创建时定义且不可变，而显示属性可以在创建后自由、动态地修改。

这个核心原则——**计算不可变，样式可变**——是理解后续 API 设计的关键。

## 2. Slider 属性的不可变 API 设计

由于 Slider 属性是计算图的一部分且不可变，它不适合使用链式方法（如 `.setMin(0)`）进行修改。我们决定将其作为表达式定义的一部分，在 **`Expr DSL`** (表达式领域特定语言) 中进行声明。

为了在 Expr DSL 中定义 Slider，我们引入 `in` 作为分隔词，将主表达式与 Slider 定义分开。

**语法**: ``expl`[表达式] in [最小值] : [步长] : [最大值]` ``

```javascript
// 创建一个名为 n 的表达式，其值为 1
// 同时为其定义 Slider 属性：范围 [0, 10]，步长 0.1
const n = expl`1 in 0 : 0.1 : 10`;
```
这种设计将 Slider 的定义与其数值紧密绑定，符合其作为计算图一部分的“不可变”特性。

## 3. 显示属性的可变 API 设计

与 Slider 属性相反，显示属性被设计为高度灵活、可动态修改的。其 API 设计的核心是**读写分离**与 **Editor 模式**，在概念清晰度、API 表面积和灵活性之间取得了理想的平衡。

### 3.1 核心原则：读写分离

-   **读取**: 依靠读取 `expr.style` 及其所有子属性（如 `expr.style.point.size`）来获取样式数据。这些属性都是**只读的数据访问器**。它们返回纯净的、可序列化的数据。
-   **写入**: 所有修改操作都必须通过一个明确的“编辑会话”来启动。这个会话会提供一个功能强大的 **`Editor`** 对象，用于进行原子化的修改。

### 3.2 最终 API 设计：核心入口 + 便利快捷方式

1.  **核心修改入口**: `expr.style(editor => { ... })`
    这是功能最全面的入口。它接受一个回调函数，并向其提供一个 `Style Editor`，允许用户在回调中进行任意复杂的、多层次的原子化修改。

    ```javascript
    myPoint.style(s => {
        s.point.size = 12;
        s.label.text = "Origin";
        s.color = "rgb(255,0,0)";
    });
    ```

2.  **便利快捷方式**:
    *   **一级属性快捷入口**: 为常用的一级属性（如 `point`, `label`）提供直接的修改方法，以减少代码嵌套。
        ```javascript
        // 等效于 myPoint.style(s => { s.point(p => { ... }) })
        myPoint.point(p => {
            p.size = 12;
            p.opacity = 0.8;
        });
        ```

    *   **属性更新快捷方式**: `expr.style({ ... })` 和 `expr.point({ ... })` 接受一个对象，并将其与现有样式进行**深层合并 (Deep Merge) + 更新**，作为 “edit/update” 语义的简便写法。
        ```javascript
        // 将 point.size 设置为 12, 其他 point 属性不变
        myPoint.point({ size: 12 });

        // 同时修改颜色和标签
        myPoint.style({
            color: "blue",
            label: { text: "My Point" }
        });
        ```
        > 注意：此快捷方式只用于 “edit/update” 功能。完整的 “set/rewrite” 功能必须通过在 `Editor` API 内部进行赋值来完成。

### 3.3 `Editor` 对象详解

`Editor` 是进行样式修改的核心交互句柄，它被设计为一个功能强大的混合类型对象。

-   **混合类型**: `Editor` 的子属性（如 `editor.point`）本身也是一个 `Editor`，它既可以被读取（`editor.point.size`），也可以作为函数被调用（`editor.point(...)`），还可以调用其自身的方法 (`editor.point.set(...)`)。
    - 同时这使得 `Editor` 可以模拟为"其上层 field 的一个可链式调用的方法"，对链式调用写法友好。例如，`styleEditor.point({ size: 12 })` 看似是调用了一个 `styleEditor` 对象身上的 `point` 方法，但实际上是 `styleEditor.point` 属性上，作为一个代表 "point 字段" 的 `Editor` 对象，被作为函数调用了，传入一个对象作为参数，调用完后返回上层 `styleEditor` 对象，方便继续“链式调用”。

-   **安全的深层路径创建**: 访问 `Editor` 上一个不存在的属性（如 `editor.a.b.c`）会自动创建路径上的中间对象，从而避免繁琐的空值检查。

-   **赋值 API (`set/rewrite` 语义)**:
    `editor.field = value;` 或 `editor.field.set(value)`
    这会完全覆写 `field` 的内容。

-   **删除 API (`delete` 语义)**:
    `delete editor.field;` 或 `editor.field.delete()`
    这会从样式对象中移除 `field` 属性。
    > 注意：`editor.field = undefined` 会触发 `set` 语义，而不是 `delete` 语义。

-   **可调用体 API (`edit/update` 语义)**:
    `editor` 自身可以作为函数调用，提供两种便捷的 `edit/update` 签名，并支持链式调用：
    1.  **回调形式**: `editor(e => { ... })`
        在回调里再次提供 `Editor` 对象，允许用户在回调函数中开辟新的操作域进行有组织的多层操作。
        ```javascript
        // 链式调用示例
        myLine.style(s => {
            s.color("red") // 调用可调用体，传入字符串，是 set 的快捷方式
             .width(4);    // 返回 s，继续链式调用
        });
        ```
    2.  **对象合并形式**: `editor({ ... })`
        接受一个对象，作为深层合并的简便写法。

-   **数据导出**: `editor.toJSON()`
    提供 `.toJSON()` 方法，允许从 `Editor` 中获取一个纯净、可序列化的数据对象，方便在会话内部快速地进行一次真实的“查看”，而不用走顶层 `style` 只读属性 API。该方法也能被 `JSON.stringify()` 自动调用。
