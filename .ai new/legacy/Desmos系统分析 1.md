# Desmos 公式系统分析（新版）

> 这是一份基于大量小实验后的“最小概念集”重写稿，目标是把 Desmos 的名称解析与作用域行为讲清楚，便于在 Bernard 的两表模型里实现、组合与检查。

## 写在前面

- 我们不引入“模块作用域”。组合发生在构建前/构建时（JS 对象直接组合、插值引用）和构建后（统一重命名）。组合完成后，模块这个概念在导出产物里自然消散。
- 真正决定“标识符指向哪儿”的，是“上下文绑定层”（Context C），而不是单纯的“静态作用域树”。同一段公式 AST，被放进不同的上下文，名字的指向会变。

## 最小概念集

- 符号表 S：记录全局“已定义”的名字 → 定义式（变量/函数）。
- 公式表 F：记录每条公式及其 AST。 
- 上下文绑定层 C：描述当前节点所处的绑定环境（函数参数、sum/int 的局部名；with/for 的代换/迭代）。
- 名称解析 R(name | AST, S, C)：在上下文 C 中解析名字，决定依赖边的落点。

直观上：S 给“全局定义”，F 给“语法与节点”，C 决定“这一次在这里怎么指向”。

## 四类“带作用域/绑定”结构与两种绑定模式

结合实验，我们把四类结构归到两种绑定语义：

### A. 填洞绑定（hole-filling，不覆盖已有解析）

- 函数参数：`f(a, b) = …`
- 求和：`sum(a = 1, n) expr`
- 积分：`int(lo, hi) expr da`

语义：只捕获“尚未解析为具体符号”的自由名；如果子表达式里的名字已经解析到了全局定义，就不改向到这些局部名。

例子（口语化简写）：

```text
c = a + b
f(a, b) = c
```

- 若无全局 `a,b` 定义：`f` 体内通过“填洞”把 `a,b` 绑定到参数，成功。
- 若存在全局 `a = 2`：在函数体构成时，`c = a + b` 可能先被外层解析部分固化为 `2 + b`；参数只会填剩下的洞，不会“抢回”已解析到全局的 `a`。

这解释了“函数/∑/∫ 不会抢名字”的观感。

### B. 代换绑定（substitution/override，覆盖已有解析）

- with：`expr with a = 3`
- for（列表迭代/参数曲线）：`expr for a = [..]` 或 `(xExpr, yExpr) for 0 < a < 2`

语义：在该上下文里对同名引用强行改向，覆盖原本已解析到的全局定义，呈现“临时代换”的效果；`for` 还会把结果提升为列表或“参数化点”集合。

这解释了“with/for 会抢名字”的观感。

## 名称解析顺序（可实现的统一规则）

建议在 Bernard 中按以下次序实现 name-resolution，能复现实验现象：

1. 先应用代换绑定（with/for）：若命中同名，直接改向（覆盖）。
2. 若未被代换：保持当前指向（若已解析到全局定义则保持）。
3. 若仍是自由名：尝试由填洞绑定（函数参数、∑、∫）捕获。
4. 若仍未解析：保留为“未定义依赖”。
5. 错误敏感点：函数定义体若最终仍含“未定义依赖”（注意条件表达式会把所有分支都算依赖），则函数定义失败，并产生阻断性错误，后续对该函数的调用全部失败。

备注：这条顺序兼容你观察到的“条件表达式把未走到的分支也算依赖”的现象，以及“with/for 真正覆盖、函数/∑/∫ 只填洞”的差异。

## 嵌套与冲突规则（按实测归纳）

- 同名局部绑定在嵌套里直接报错：`scopedClause(a, ... scopedClause(a, ...) ...)` 禁止。
- with 不允许 2 层以上嵌套：`(expr with b=2) with a=1` 报错。
- for 允许多层，但同名冲突不允许。
- 函数不是一等公民：不能在函数里定义函数；但函数体内可以自由使用 with/for/sum/int（遵守上面的冲突规则）。

这些规则意味着：上下文 C 是一条可叠加的“绑定链”，但叠加时有“同名即非法”的硬约束；不同绑定类型（填洞/代换）在解析顺序里有不同优先级。

## 条件表达式与阻断性错误

- 经验法则：条件表达式把所有分支的依赖都算进来（即使永远不会走到某分支）。
- 影响：在函数定义体里，这会把“潜在未定义”的名也计入依赖，从而触发定义期错误；一旦失败，后续所有对该函数的调用都会失败（阻断性）。

## for 的两种形态

- 列表迭代：`expr for a = [1...3]`，把 `a` 当作迭代变量代换到 `expr`，产出列表。
- 参数曲线（“参数化点”）：`(xExpr, yExpr) for 0 < a < 2`，`a` 取区间，产出“参数化点”类型（只能被赋值或在点列表中存取，不参与大多数运算）。

两者在名称解析层面都是“代换绑定 + 扩展”，差别主要在“结果类型”和“绑定源（列表 vs 区间）”。

## 组合（模块复用）在两表模型中的落地

不引入“模块作用域”，但引入“接口观念”，以便组合时静态检查：

- provides：该组公式最终导出的已定义符号集合（全局可见）。
- requires：该组公式在其内部上下文解析之后，仍未被满足的自由名集合。

组合流程（摘要）：

1. 合并符号表 S，按既定策略做冲突重命名（仅限“全局导出名”）。
2. 把一方的 provides 满足另一方的 requires，重新做一遍名称解析（含代换/填洞）。
3. 对所有“函数定义体”做闭包检查：若仍存在未定义依赖（含条件表达式收集的依赖），在输出前即报错，避免把“阻断性失败”留到 Desmos 才暴露。
4. with/for 的代换只在各自公式的本地上下文 C 中生效，不会“污染”跨公式的全局 S。

这套过程与“构建后统一重命名”的既定策略是兼容的。

## 可实现的数据结构草图

- ContextBinding C：
  - substitutionMap（代换映射，with/for）：name → Expr
  - holeParams（填洞集合，函数参数/∑/∫）：{name}
  - conflictCheck：构建时校验同名局部绑定是否重复
- NameResolution：
  - apply C → walk AST → 生成依赖边（标注边类型：全局/代换/填洞）
  - 统计 requires（解析失败/未定义的名）与 provides（本组定义集合）

## 开放实验清单（待补小样例钉死边界）

- 函数参数 vs 全局同名的四象限：是否总是“已解析到全局的不回抢；否则填洞”？
- sum/int 的“只填洞不覆盖”是否在包含复杂条件表达式时仍一致？
- with 的 1 层限制在复杂嵌套（for 内 with、函数体内 with、with 外再包一层 for）时的报错顺序与消息。

## 附：与旧版文档的差异

- 强调“上下文绑定层 C”为一等概念，用统一的“名称解析顺序”收敛行为差异。
- 把四类语法折叠成“两种绑定模式”（填洞/代换），描述更简。
- 明确组合期需要的 provides/requires 与“函数体闭包检查”，避免阻断性错误延后暴露。

—— 以上作为 Bernard 的实现基线，后续可以按这个骨架把所有细节逐步落成“可执行的静态检查 + 名称解析”。


