# 上下文变量真名决议

> 本文档是 [编译与导出](./index.md) 流程中 "Step 3: 上下文变量真名决议" 的详细实现方案。它重点解决了混合嵌套作用域下的命名冲突问题。

在 Destra 中，上下文变量 (`CtxVar`) 的作用域不仅跨越了 DSL 字符串边界，还穿透了 Formula 对象之间的依赖关系。为了在 Desmos 的扁平命名空间中正确模拟这些嵌套作用域并避免冲突，我们需要引入一个专门的 **Scope Tree** 数据结构。

## 1. 核心数据结构：Scope Tree

Scope Tree 是一个独立于 AST 和 Dependency Graph 的树状结构，专门用于描述上下文变量的作用域层级。它将所有“作用域产生者”（无论是工厂创建的 Formula 还是内部 DSL 解析出的 AST 节点）统一抽象为树上的节点。

### 1.1 ScopeNode 定义

```typescript
// 概念定义
type ScopeNode = {
    id: number;                // 唯一ID，用于调试
    type: 'root' | 'factory' | 'internal';

    parent: ScopeNode | null;
    children: ScopeNode[];

    // 本作用域定义的变量决议表
    // Key: 原始变量名 (如 "i")
    // Value: 决议后的信息
    variables: Map<string, ResolvedVariable>;
}
// 数据源引用
& {
    type: 'root';
} & {
    type: 'factory';
    // 如果是 'factory' 类型，指向 CtxExp 公式对象
    sourceFormula: Formula;
} & {
    type: 'internal';
    // 如果是 'internal' 类型，指向 AST 节点 (如 SumClauseASTNode)
    sourceASTNode: any;
    // 如果是 'internal' 类型，同时记录该 AST 所属的 Formula 对象 (Host Formula)
    hostFormula: Formula;
}

interface ResolvedVariable {
    originalName: string;      // 原始名 "i"
    realname: string;          // 最终真名 "i_{1}"
    isForced: boolean;         // 是否被用户强制指定
    // 如果是 factory 类型，持有 CtxVar 引用以便反向查找
    sourceCtxVar?: CtxVar;
}
```

### 1.2 节点类型

1.  **Root Node**: 全局作用域，对应整个图表的根。
2.  **Factory Node**: 对应由 `For`, `Sum`, `Func` 等工厂函数创建的 `CtxExp` 公式对象。它的作用域覆盖其 `body` 属性所指向的表达式（及其下游依赖）。
3.  **Internal Node**: 对应 DSL 内部解析出的上下文语句 AST 节点（如 `sum(n=1,10) ...` 中的 `SumClauseASTNode`）。它的作用域覆盖其 `content` 子节点。

## 2. 编译流程详解

### Phase 1: 构建 Scope Tree (Tree Construction)

我们需要遍历 Formula 依赖图和每个 Formula 的 AST，来构建这棵树。由于 Factory 和 Internal 作用域可能互相嵌套，遍历过程是交织的。

**输入**: Graph Roots (Formulas)
**输出**: 完整的 Scope Tree

**遍历算法**:

1.  **初始状态**: 创建 Root ScopeNode。
2.  **递归遍历 (Visit Formula)**:
    *   输入: 当前 `Formula`, 当前 `ScopeNode` (parent)。
    *   如果当前 Formula 是 `CtxExp` (Factory)，先额外进行以下操作:
        *   创建一个新的 Child ScopeNode (Type: `factory`)，挂载到 parent 下。记录该节点定义的 `ctxVars`。
        *   使用新节点作为 parent，额外递归遍历其 `CtxExp.body` 表达式对象内容。
    *   解析 Formula 的 AST 内部内容（CtxExp 本身的 ast 数据为其定义头部的 ast 数据，可在这里用同样流程解析）:
        *   获取其缓存的 AST。
        *   调用 **Visit AST**，返回 children 添加到当前节点 children 列表中。

3.  **递归遍历 (Visit AST)**:
    *   输入: 当前 AST Node, 当前 `ScopeNode` (parent)。
    *   **分支 A**: 如果是上下文语句节点 (如 `SumClauseASTNode`):
        *   创建一个新的 Child ScopeNode (Type: `internal`)，挂载到 parent 下。
        *   记录该节点定义的变量名。
        *   **递归**: 使用新节点作为 parent，继续遍历 `ASTNode.content`。
    *   **分支 B**: 如果是插值节点 (Interpolation):
        *   找到插值对应的 Value (Formula)。
        *   **递归**: 使用**当前** parent，调用 **Visit Formula** 遍历该 Value。
    *   **分支 C**: 其他节点 -> 递归遍历子节点。

注：留意 expr-dsl/parse-ast/sematics/helpers.ts 导出的辅助函数（也在 expr-dsl/parse-ast/index.ts 导出），有一些如 `traceAST`，`traceSubstitution`，`traverse` 等工具函数可以帮助我们定位和遍历节点。

### Phase 2: 变量真名决议 (Resolution Pass)

为了满足“内部强制命名优先于外部自动命名”的需求（即外部自动命名需避让内部强制命名），我们需要分两步进行。

#### Step 1: 收集强制命名 (Collect Forced Names)

自底向上（或在构建树时）计算每个 ScopeNode 的 `subtreeForcedNames` 集合。该集合包含该节点及其所有子孙节点中被用户强制指定的变量真名。

#### Step 2: 自顶向下分配 (Top-down Assignment)

在构建好的 Scope Tree 上，执行自顶向下的遍历，分配最终的 `realname`。

**输入**: Scope Tree, 全局已占用名称集合 (Global Used Names - 来自 Step 2 全局变量决议，包含 Desmos Keywords)

**算法**:

1.  **递归决议 (Resolve Scope)**:
    *   输入: 当前 ScopeNode, `ancestorNames` (祖先已占用的名字)。
    *   **准备冲突检测集合**:
        *   `forbiddenNames` = `ancestorNames` U `this.subtreeForcedNames`。
        *   这意味着：通过自动生成的名字，既不能与祖先冲突，也不能抢占子孙节点强制要求的名字。
    *   **当前作用域处理**:
        *   创建 `currentScopeNames` 集合，用于传递给子节点，初始包含 `ancestorNames` 和本节点确定的所有 names。
        *   遍历本作用域定义的每个变量 `var`：
            *   **Case A: 强制命名 (Forced)**:
                *   `realname` = 用户指定名。如果与 `forbiddenNames` 冲突前面应已报错。
                *   将 `realname` 加入 `currentScopeNames`。
            *   **Case B: 自动命名 (Automatic)**:
                *   候选名 = `var.originalName`。
                *   **冲突检查**: 检查候选名是否在 `forbiddenNames` 或本作用域已分配的名字中。
                *   如果冲突，递增数字后缀 (`i` -> `i_{0}` -> `i_{1}` -> ...) 直到无冲突。
                *   确定 `realname`。
                *   将 `realname` 加入 `currentScopeNames`。
                *   保存结果到 `ScopeNode.variables` 映射表。
    *   **递归子节点**:
        *   对每个 child，调用 **Resolve Scope**，传入 `currentScopeNames`。

## 3. 特殊情况处理

### 3.1 强制命名 (Forced Realname)

用户可能希望强制指定上下文变量的 Latex 名称（例如为了配合特定的可视化脚本）。

*   **Factory 模式 (`CtxVar`)**:
    *   **API**: `ctxVar.realname('my_name')`。
    *   **存储**: 将强制名存储在 `CtxVar` 的 sidecar state 中。
    *   **Scope Tree 构建**: 读取 state 中的配置，设置 `ResolvedVariable.isForced = true`。

*   **Internal DSL**:
    *   目前暂不支持在 DSL 字符串中直接指定强制真名。建议需要精细控制命名的用户使用 Factory 模式。

*   **处理策略**: 
    在 Phase 2 (Resolution) 中，强制命名的变量具有最高优先级。
    *   **Shadowing**: 目前我们不允许 "shadowing" 行为（Desmos 本体的 shadowing 机制过于复杂），这意味着即使强制指定真名也不能彼此冲突。
    *   **Reservation**: 它会作为“保留字”传递给父级 Scope，迫使父级（及更上层）在自动分配同名变量时进行避让（重命名为 `i_{1}` 等）。


### 3.2 隐式依赖的 Scope
某些 Formula 可能被多个下游引用。在 Scope Tree 中，这意味着同一个 Formula 可能会出现在树的不同分支上吗？
*   **不是的**。Scope Tree 是**树**，不是图。虽然纯公式之间可以有菱形依赖，但是在上下文作用域路径中，（至少我们 Destra 默认模式所限制的逻辑里），即使一个 Formula 可以成为菱形依赖，它也不可能同时拿取和依赖来自两个不同上下文作用域的上下文变量，因为我们通过 Callback 创建身体表达式。
    *   如果一个 Formula `A` 被 `B` 和 `C` 同时引用（插值），且 `B` 和 `C` 处于不同的上下文路径中，那么 `A` 实际上拿取了来自两个 Callback 里所传入的上下文变量（CtxVar 对象），但是正常情况下 `A` 如果拿取上下文变量那么一定处于且只处于一个 Callback 里，因此不会出现这种情况。
    *   极端情况下（如果用户把一个 Callback 里传入的 CtxVar 对象传递到外部去）我们也需要编写逻辑在编译前先行排除外域上下文变量的依赖（本域下游的祖先域除外，注意这里并存两套相反的父子依赖关系，在 Formula 普通依赖路径里这个域/上下文语句是下游/子节点，但是在上下文路径里它反向向上游提供上下文变量，是祖先域）。
    *   由于祖先上下文语句位于下游，晚于本体上下文语句创建，因此无法在本体上下文语句的创建时检验外部上下文变量属于外域还是祖先域，只能在编译前统一检查。
    *   关于结构合法性的检查已移至 [Step 1.5](./结构合法性检查.md)，本步骤专注于命名决议。

### 3.3 修正后的 Scope Tree 遍历逻辑

正因为 Destra 的 DAG 特性，所有的“依赖”都是预先定义好的。

*   **Internal DSL**: `sum(n=1, 10) n^2`。`n` 的作用域仅限于 `n^2` 这段 AST。
*   **Factory**: `Sum(n => expr`${n}^2`)`。
    *   这里 `expr`${n}^2`` 是一个独立的 Formula。
    *   这个 Formula 内部有一个插值，插值的值是 `ctxVar n`。
    *   在 Latex 生成时，当遍历到 `expr`${n}^2`` 的插值 `n` 时，我们需要知道这个 `n` 对应哪个 Scope 的变量。
    *   **解决方案**: 不需要复杂的 Scope Tree 覆盖插值 Formula。
        *   每个 `CtxVar` 对象在创建时，虽然不知道它具体的 `realname`，但它是唯一的对象引用。
        *   我们在 **Resolution Pass** 中，主要是为了给每个 `CtxVar` 对象（以及 Internal DSL 中的 AST 变量节点）分配一个 `realname`。
        *   对于 Factory 创建的 `CtxVar`，它属于该 Factory Formula 的 Scope。
        *   对于 Internal DSL 创建的变量，它属于该 AST 节点的 Scope。

**简化的核心逻辑**:

Scope Tree 主要处理的是 **Internal DSL 的嵌套** 以及 **Factory 的嵌套**（如果 Factory 的 body 里面直接写了 DSL 字符串，而该字符串里又定义了上下文语句）。

*   对于通过 JS 变量传递引用 (`${n}`) 的情况，Latex 生成器只需查表：`Map<CtxVar, Realname>`。
*   对于 DSL 内部引用 (`sum(i=1,10) i^2`) 的情况，Latex 生成器需要查 Scope Stack。

因此，Scope Tree 构建器主要关注：
1.  **Factory Formula**: 它是一个 Scope，定义了 `CtxVar` 对象。
2.  **Internal AST**: 解析 AST，如果发现 Context Clause，创建 Scope，并记录其定义的变量名。

**Resolution Pass** 负责统一这两者：
1.  为 Factory 的 `CtxVar` 对象分配真名。
2.  为 Internal AST 的变量分配真名。
3.  确保嵌套时的名称避让。
