# Desmos 公式系统分析（重构版）

> 本文档旨在为 Bernard 项目提供一个清晰、准确且可操作的 Desmos 系统行为模型。它基于实际的实验观察，并用一套最小、最直观的概念来解释 Desmos 中看似复杂的名称解析和作用域规则。

## 核心思想：上下文决定一切

与许多传统编程语言不同，Desmos 中的一个符号（例如变量 `a`）究竟指向哪里，并非由外部层层嵌套的作用域决定，而是由**定义这个符号的公式本身所附加的“局部规则”**所决定。

同一个表达式，当被不同的结构“包裹”时，其内部符号的解析行为会发生改变。因此，我们理解 Desmos 行为的关键，在于理解这些“包裹”结构（如函数定义、`with` 语句等）如何改变其内部表达式的上下文。

基于这个核心思想，我们不再需要引入一个复杂的“模块作用域”概念。模块的组合问题，可以在理解了上下文机制后，通过更简单的构建时步骤来解决。

## 两种绑定模式：清晰划分作用域行为

通过实验，我们发现所有引入局部变量的“包裹”结构，其行为都可以被清晰地划分为两种模式：

### 模式一：填洞绑定 (Hole-filling Binding)

这种模式像一个有礼貌的助手，它会帮你补上表达式里缺失的定义，但绝不会“抢夺”已经明确的定义。

-   **适用结构**：
    -   函数定义: `f(a, b) = ...`
    -   求和: `sum(i = 1, n) ...`
    -   积分: `int(a, b) ... dx`

-   **行为**：
    1.  它会审视其“包裹”的表达式。
    2.  如果发现某个符号在全局中**没有被定义**（是一个“洞”），并且这个符号的名字和它自己引入的局部变量（如函数参数 `a`）同名，它就会把这个符号“认领”过来，将其绑定到自己的局部变量上。
    3.  但如果一个符号在表达式中已经明确指向了一个**全局定义**，那么“填洞绑定”结构就不会干涉它。

-   **经典实验佐证**：
    ```
    a = 2
    c = a + b
    f(b) = c
    ```
    在定义函数 `f(b)` 时，Desmos 会这样分析：
    1.  `f(b)` 的函数体是 `c`。
    2.  `c` 引用了全局定义 `c = a + b`。
    3.  在 `a + b` 这个表达式中，`a` 已经明确指向了全局定义的 `a = 2`，所以 `f(b)` 不会干涉 `a`，它依然是 `2`。
    4.  而 `b` 在全局没有定义，是一个“洞”。`f(b)` 发现自己的参数列表里正好有一个 `b`，于是它“填补”了这个洞，将表达式中的 `b` 绑定到了函数参数 `b`。
    5.  最终，`f(b)` 的有效函数体被解析为 `2 + b`。

### 模式二：代换绑定 (Substitution/Override Binding)

这种模式则像一个霸道的指令，它会强制性地替换其内部表达式的某个符号，无论那个符号之前指向哪里。

-   **适用结构**：
    -   `with` 语句: `... with a = 3`
    -   `for` 语句: `... for a = [1, 2, 3]`

-   **行为**：
    -   它会直接“劫持”其“包裹”的表达式中所有同名的符号，强制它们在当前上下文中指向 `with` 或 `for` 提供的新值。这种行为会**覆盖**掉任何已经存在的全局定义。

-   **简单示例**：
    ```
    a = 10
    y = (a + 1) with a = 2
    ```
    这里，即使全局已经定义了 `a = 10`，`with a = 2` 也会强制将其包裹的表达式 `(a + 1)` 中的 `a` 临时视为 `2`。因此 `y` 的计算结果是 `3`，而不是 `11`。`for` 语句的行为与此类似。

## 关键规则与边界情况

Desmos 为了避免二义性，设定了一些严格的规则。

1.  **禁止同名局部变量嵌套**
    Desmos 不允许两个引入同名局部变量的结构嵌套，例如 `sum(i=1, 5) ... sum(i=1, 10) ...` 这样的结构会直接报错。这大大简化了我们的分析模型，因为我们不需要处理复杂的局部变量覆盖问题。

2.  **`with` 语句的特殊限制**
    `with` 语句只能嵌套一层。形如 `(... with a=1) with b=2` 的结构是允许的，但 `((... with a=1) with b=2) with c=3` 会报错。

3.  **函数定义的严格性 与 “阻断性错误”**
    函数定义是 Desmos 中最严格的地方。
    -   **依赖预检查**: 在定义一个函数时，Desmos 会立刻检查其函数体（包括所有分支）的所有依赖。如果有任何一个依赖在全局找不到定义（也无法被参数“填洞”），函数定义就会**立即失败**。
    -   **阻断性**: 一旦一个函数定义失败，任何其他试图调用这个函数的公式也会跟着失败，无论调用的参数是什么。这个错误会像多米诺骨牌一样在依赖链上传播。
    -   **关键实验佐证**:
        ```
        // opq 是一个未定义的变量
        f(x) = {x > 0: 1, opq}  // 定义失败，因为 opq 未定义
        y = f(1)               // 跟着失败，即使 x>0 分支用不到 opq
        
        b = {1 > 0: 1, opq}    // 定义成功，b=1。
                               // 非函数定义上下文对未使用的分支更宽容。
        ```

## 对 Bernard 项目的指导意义

这套清晰的模型，为 Bernard 的模块组合与静态检查功能提供了坚实的理论基础。

### 模块组合策略

我们不需要“模块作用域”，组合过程可以在 Bernard 的构建阶段通过清晰的步骤完成：

1.  **合并与重命名**：将多个模块的公式集合并。如果出现全局同名符号冲突（例如两个模块都定义了变量 `a`），Bernard 负责进行系统性的重命名（例如 `module1_a`, `module2_a`）。
2.  **依赖连接**：合并后，原本在一个模块中“悬而未决”的依赖（`requires`），可能会被另一个模块提供的定义（`provides`）所满足。Bernard 在此时完成依赖图的连接。
3.  **最终静态检查 (关键步骤)**：在生成最终的 Desmos State JSON 之前，Bernard **必须**对所有函数定义进行一次最终的依赖闭包检查。利用我们上述的模型，检查每一个函数体，确保其所有依赖要么能在合并后的全局符号表中找到，要么能被其函数参数“填洞”。

这个检查步骤至关重要，它能将 Desmos 中会导致“阻断性错误”的问题，在 Bernard 的构建阶段就提前暴露给开发者，从而保证 Bernard 生成的图表是健壮和可预测的。

### 可实现的数据结构草图

在 Bernard 内部，可以这样对上下文进行建模：

-   `Context` 对象:
    -   `substitutionMap`: 存储来自 `with` 或 `for` 的强制代换规则。
    -   `holeParameters`: 存储来自函数、求和、积分的“填洞”参数名集合。

在进行依赖分析时，针对每一个表达式节点，递归地应用其外部所有 `Context` 提供的规则，就能精确地推导出其真实的依赖关系。


