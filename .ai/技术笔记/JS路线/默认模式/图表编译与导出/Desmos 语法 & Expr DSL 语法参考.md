# Desmos 语法 & Expr DSL 语法参考 (Desmos Grammar & Expr DSL Grammar Reference)

本文档详尽列出了 Desmos 中的所有语法与内置函数，以及为之设计的 Destra 的 Expr DSL 的所有语法与内置函数。

Destra 的 Expr DSL 设计原则是 **"所见即所得" (WYSIWYG)** 与 **"原生兼容"**：
1.  **所见即所得**: 基本上，你在 Desmos 网页版的公式输入框里怎么敲击键盘，在 Expr DSL 字符串里就怎么写。
2.  **插值增强**: 在此基础上，我们利用 JS 模板字符串的 `${...}` 插值功能，实现了对 JavaScript 变量的引用和依赖管理。

## 前言

### Desmos / Destra 语法展示

本文档需要同时展示 Desmos 语法与 Destra Expr DSL 语法。

Destra 语法使用 JS 代码形式直接展示，如：

```javascript
expr`x^2 / ${a}^2 + y^2 / ${b}^2 = 1`
```

这样也可以直观展示编写 Destra 代码时从 JS 层到 DSL 语法内部层的全部使用细节（如插值等），而不完全局限于 Expr DSL 范围内。

关于 Desmos 语法，Desmos 内部的信息标准是 LaTeX 形式，但是在我们文档里全部用 LaTeX 形式展示的话会很大程度上增加阅读难度（我个人认为 LaTeX 语法本身对人类远不友好），因此我们会使用一种更加简便的临时语法来展示 Desmos 端原生的公式内容。这个简便语法也会应用在本项目知识库的所有文档中，所以说我们尽量“意会”即可。

上面的 Destra 代码在展示其对应的 Desmos 公式内容时，我们将这样展示：

```
x^2 / a^2 + y^2 / b^2 = 1
```

注意：使用内联 markdown 语法来展示 Destra 模板字面量语法时，需前后用2个(以上)反引号包裹，并且需要按需与代码内容用空格分隔，以避免代码内容中的反引号和 markdown 语法标记混淆。如：``expr`x^2 / ${a}^2 + y^2 / ${b}^2 = 1` ``

### 标识符与 DSL 内部变量引用

在其他相关文档里有所提及，但在这里再次说明一下：

DSL 中出现的任何非内置标识符，都会被视为 DSL 内部变量引用。

目前可以使用 DSL 内部变量名的场景包括：上下文变量名、显式方程的未定义变量写法的自变量/因变量、回归公式的回归参数。其他情况下都使用模板字面量插值 `${...}` 来引用。

DSL 内部变量名在编译时会自动转换为 Desmos 兼容格式。

关于 Expr DSL 的背景可参考 [JS路线](../../../JS路线/index.md)。

关于 Destra 命名机制的细节可参考 [核心API与命名机制](../../核心API与命名机制.md)。

### 公式类型与子类型

参考 [.ai/Desmos建模/03-公式类型与符号系统.md](../Desmos建模/03-公式类型与符号系统.md)。

在 Desmos 语言环境里，数据在一定程度上具有类型（动态类型）。但是并不是所有在 Desmos 中的数据类型都能在 Destra 的 JS/TS 类型系统里建模。Destra 的类/类型系统只能建模部分 Desmos 类型信息，这是技术上面临限制并权衡后的结果。

为了描述这种局限性，我们引入 “公式类型” 与 “公式子类型” 的概念。公式类型层是可被静态分析、而后被 Destra 类/类型系统建模的类型信息，而公式子类型基本上是一个公式类型内的子级划分，无法被静态分析。

例如，“表达式”公式类型(`Expression extends Expr extends Formula`)下有 “数值”、“点”、“列表” 等子类型。当然这些子类型也可以同时视为“变量定义”公式类型(`VarExpl extends Expl extends Formula`)的子类型。

但是，在解析 Expr DSL 内容时，可以将公式子类型与创建数据的字面量语法联系起来，因此下文会详细介绍各类公式子类型及其对应字面量语法。

---

## 1. 公式子类型与对应字面量语法——完整列举 (Subtypes & Corresponding Literal Syntaxes)

### 1.1 表达式 - 数值 (Expression - Numbers)

#### 1.1.1 数值字面量 (Number Literal)

直接书写数字。支持十进制小数。

支持科学计数法 (E-notation)，例如 `1.2e5`。
*   注意：在 Desmos 中，并没有科学计数法这一独立的“数值字面量”类型，通常使用 `1.2 * 10^5` 这样的算术表达式来表示科学计数法。
*   Destra 为了方便使用，支持在 DSL 中使用科学计数法字面量。在编译时，它会被自动转换为 Desmos 所需的 `数值 * 10 ^ 指数` 的表达式形式。

Desmos 语法：
```
123
3.14159
-0.5
1.2 * 10^5  // 科学计数法在 Desmos 中的实际形态
1.2 * 10^-5
```

Destra 语法：
```javascript
expr`123`
expr`3.14159`
expr`-0.5`
expr`1.2e5`   // 语法糖
expr`1.2E-5`
```

#### 1.1.2 Desmos 内置常量 (Constants)

Desmos 内置的数学常量。

Destra 语法：
- pi ($\pi$): ``expr`pi` ``
- tau ($\tau$): ``expr`tau` ``
- e ($e$): ``expr`e` ``
- 无穷大 ($\infty$): ``expr`infinity` `` / ``expr`infty` ``
- 虚数单位 ($i$): ``expr`i` ``

在 Desmos 里：
- pi ($\pi$): 键盘键入`pi`或直接输入 $\pi$ 符号。
- tau ($\tau$): 键盘键入`tau`或直接输入 $\tau$ 符号。
- e ($e$): 键盘键入`e`。
- 无穷大 ($\infty$): 键盘键入`infinity`或`infty`，或直接输入 $\infty$ 符号。
- 虚数单位 ($i$): 键盘键入`i`。

还有一些不那么数学的常量：

Destra 语法：
- 宽度 (width): ``expr`width` ``
- 高度 (height): ``expr`height` ``

在 Desmos 里：
- 宽度 (width): $\operatorname{width}$。
- 高度 (height): $\operatorname{height}$。

注:

常量支持与前方的数值进行省略乘号的相乘。可以间隔空格，也可以不间隔。

#### 1.1.3 Desmos 保留变量 (Reserved Variables)

例如方程 `x^2 + y^2 <= 1 `中的 x 与 y，在 Desmos 里 x 与 y 这类变量有特殊的作用，它们不能被定义和赋予值，但是可以被引用，在绘制显式方程、隐式方程、隐式不等式等图象的场景里有至关重要的作用。

Destra 可以在 Expr DSL 中直接以字面量形式引用这些保留变量，并且在编译解析时会追踪各个表达式对这些保留变量的依赖情况（例如一个表达式是否依赖 x 或 y）。

Desmos 中的保留变量如下：

- x
- y
- z                        --- 限 3D 计算器
- t
- u                        --- 限 3D 计算器
- v                        --- 限 3D 计算器
- r
- theta ($\theta$)
- rho ($\rho$)             --- 限 3D 计算器
- phi ($\phi$)             --- 限 3D 计算器

Destra 里直接使用上述名称引用即可。

如[核心API与命名机制](../核心API与命名机制.md)中所述，在 DSL 内部使用希腊字母 unicode 字符会自动转换并视为对应的希腊字母别名（例如 `θ` -> `theta`）。

### 1.2 表达式 - 点 (Expression - Points)

Desmos 中点由圆括号包裹的元组表示。

Destra 语法：
```javascript
expr`(1, 2)`
expr`(${x}, ${y})`
expr`(1, 2, 3)` // 3D 点
```

Desmos 语法：
```
(1, 2)
(x, y)
(1, 2, 3) // 3D 点
```

### 1.3 表达式 - 列表 (Expression - Lists)

Desmos 强大的列表功能在 Destra 中完全保留。

有数种不同的方法来构造列表。

- **枚举构造**:
  直接写出列表元素。
  - Desmos 语法：
    ```
    [1, 2, 3]
    [a, b, c]
    ```
  - Destra 语法：
    ```javascript
    expr`[1, 2, 3]`
    expr`[${a}, ${b}, ${c}]`
    ```
- **范围构造 (Range)**:
  支持灵活的省略号 `...` 语法。
  - 基本语法：
    - 需要显式指定首项与末项。步长默认为 1。
      - Desmos 语法：`[1, ..., 10]`
      - Destra 语法：``expr`[1, ..., 10]` ``
      - 结果：`[1, 2, 3, ..., 10]`
    - 在首项后面可以显式指定第 2 项，通过这种方式来指定步长。
      - Desmos 语法：`[1, 3, ..., 11]`
      - Destra 语法：``expr`[1, 3, ..., 11]` ``
      - 结果：`[1, 3, 5, 7, 9, 11]`。"1" 和 "3" 决定了步长为 2。
    - 其实“末项”并非严格意义上的末项。这个例子里列表会在陈列到 11 之后停止，会超过“末项”位置上指定的 10，也就是说“末项”位置上的数值表达式指定的更多是一种“终止阈值”，并且会在首次达到或超过该阈值时停止。
      - Desmos 语法：`[1, 3, ..., 10]`
      - Destra 语法：``expr`[1, 3, ..., 10]` ``
      - 结果：`[1, 3, 5, 7, 9, 11]`

  - 其他扩展性语法：
    - 可以在 `...` 前后省略它与数字之间的逗号。
      - Ex.1
        - Desmos 语法：`[1...10]`
        - Destra 语法：``expr`[1...10]` ``
        - 结果：`[1, 2, 3, ..., 10]`
      - Ex.2
        - Desmos 语法：`[1, 3...11]`
        - Destra 语法：``expr`[1, 3...11]` ``
        - 结果：`[1, 3, 5, 7, 9, 11]`
    - 可以插入更多项——但是依然要让列表保持为等差数列。（所以这个特性其实没什么用）
      - Ex.1
        - Desmos 语法：`[2, 4, 6...10, 12, 14]`
        - Destra 语法：``expr`[2, 4, 6...10, 12, 14]` ``
        - 结果：`[2, 4, 6, 8, 10, 12, 14]`
      - Ex.2
        - Desmos 语法：`[1, 1, 1...10, 10, 10]` （尝试指定非等差数列，或分段式的规律）
        - Destra 语法：``expr`[1, 1, 1...10, 10, 10]` ``
        - 结果：报错：“范围必须是等差数列。”

### 1.4 表达式 - 多边形 (Expression - Polygons)

使用多边形函数 `polygon` 创建，作为一种独立的数据类型。`polygon` 函数的详细使用方式在后文介绍，这里简单展示其用例：

- Desmos 语法：`polygon((0, 0), (1, 0), (1, 1), (0, 1))`
- Destra 语法：``expr`polygon((0, 0), (1, 0), (1, 1), (0, 1))` ``
- 结果：一个多边形对象，可绘制出一个正方形。

注：3D 计算器不支持多边形类型。

<!-- Desmos 语法：
```
polygon((0, 0), (1, 0), (1, 1), (0, 1))   // 正方形，传入各个点
polygon([(0, 0), (1, 0), (1, 1), (0, 1)])   // 正方形，传入点列表
polygon(([0, 1, 1, 0], [0, 0, 1, 1]))   // 正方形，传入点列表的另一种写法（我个人在 Desmos 里更习惯这种写法因为能省一些打括号的次数）
```
Destra 语法：
```javascript
expr`polygon((0, 0), (1, 0), (1, 1), (0, 1))`   // 正方形，传入各个点
expr`polygon([(0, 0), (1, 0), (1, 1), (0, 1)])`   // 正方形，传入点列表
expr`polygon(([0, 1, 1, 0], [0, 0, 1, 1]))`   // 正方形，传入点列表的另一种写法
``` -->

### 1.5 表达式 - 颜色 (Expression - Colors)

颜色在 Desmos 中也是一种对象，可用于指定其他图像的颜色样式等。

Desmos 支持多种颜色函数，包括：
- `rgb(r, g, b)`
- `hsv(h, s, v)`，`okhsv(h, s, v)`
- `oklab(l, a, b)`
- `oklch(l, c, h)`
参见 [Custom Colors - Desmos Help Center](https://help.desmos.com/hc/en-us/articles/4406795899533-Custom-Colors)。

Destra 支持以上的颜色函数，同时还支持十六进制颜色字面量，将编译为 rgb 颜色函数调用。
```javascript
expr`rgb(255, 0, 0)`
expr`hsv(0, 1, 1)`
expr`okhsv(0, 1, 1)`
expr`oklab(0, 0, 0)`
expr`oklch(0, 0, 0)`
// Hex 字面量:
expr`#FF0000`    // 将编译为 "rgb(255, 0, 0)" (或者实际上是 `\operatorname{rgb}\left(255,0,0\right)`)
```

也可以构建颜色列表对象：

- Ex.1
  - Desmos 语法：`[rgb(255, 0, 0), rgb(0, 255, 0), rgb(0, 0, 255)]`
  - Destra 语法：``expr`[rgb(255, 0, 0), rgb(0, 255, 0), rgb(0, 0, 255)]` ``
  - 结果：一个颜色列表对象，分别为红色、绿色、蓝色。
- Ex.2
  - Desmos 语法：`hsv([0...360], 0.6, 1)`
  - Destra 语法：``expr`hsv([0...360], 0.6, 1)` ``
  - 结果：一个包含 360 个颜色值的列表对象，呈彩虹色。

颜色列表对象可用于指定列表式图象（如一系列多边形、一系列隐式不等式图形等）的颜色样式。

需要注意，Desmos 会强制要求一个颜色 / 颜色列表对象分配给一个变量（或作为表达式中间值），不允许一个颜色 / 颜色列表对象作为一条公式（“表达式”型）的计算结果而不被分配给一个变量。在 Destra 里等价于不允许一个 Expression 类型的 Expr 对象（而非 Expl 对象）直接接入最终的公式列表。

（但是这个我们其实也控制不了（）因为这玩意也很难静态分析，所以你们自己注意就行（））

<!-- 颜色列表对象也支持所有常规列表操作（见下文）。 -->

### 1.6 表达式 - 布尔值 (Expression - Booleans)

布尔值是比较表达式的结果。在 Desmos 里高度控制布尔值不能“直接出现”，布尔值不能存储为变量，只能作为中间值，必须被接入条件表达式中，但在 Destra 里我们仍然认为布尔值是一种子类型（“表达式”公式类型的子类型），并且可以存储于 Expr (Expression) 中——但你仍然需要后续把它接入条件表达式中。

比较运算符语法在下文介绍，这里简单展示创建布尔值的示例：
- Desmos 语法：`t_ime > 30`
- Destra 语法：``expr`${time} > 30` ``
- 结果：一个布尔值对象，表示时间大于 30。在 Desmos 里如果变量 `t_ime` 的值变为超过 30，则该布尔值为真，否则为假。

也有布尔值列表对象，这里展示一个实际应用示例：
- Desmos 语法：
  ```
  T = 0
  t_marks = [0...30]    // 参照值
  d_rawSquare(C, L) = polygon(C + L * [(1, 1), (1, -1), (-1, -1), (-1, 1)])  // 函数，绘制一个正方形，参数为中心点和边长
  p_rogressBar = { T > t_marks: d_rawSquare((-15 + t_marks, 0), 1) }
  ```
- Destra 语法：
  ```javascript
  const T = expl`0 in 0::`;   // 滑动条连续变化，无上限
  const tMarks = expr`[0...30]`;
  const drawSquare = (C, L) => expr`polygon(${C} + ${L} * [(1, 1), (1, -1), (-1, -1), (-1, 1)])`;
  const progressBar = expr`{${T} > ${tMarks}: ${drawSquare}((-15 + ${tMarks}, 0), 1)}`;
  ```

这里会绘制一个由一排正方形构成的“进度条”，每个正方形代表一个时间点。随着 T 的增长，正方形的数量会逐渐增加，直到达到 30 个。

在这里 ``${T} > ${tMarks}`` 是一个布尔值列表对象，表示时间是否大于 tMarks 中的各个时间点。这个布尔值列表对象会被用于条件表达式中，决定是否绘制对应的正方形。如果 T 大于 tMarks 中的某个时间点，则绘制对应的正方形，否则不绘制（计算为 undefined）。

progressBar 的最终结果是一个多边形列表对象，其中前几个元素为各个真实的多边形，剩余的元素为 undefined。

### 1.7 表达式 - 参数方程 (Expression - Parametrics)

依赖保留变量 t （或 u, v，限 3D 计算器），公式最终计算结果为点 / 点列表类型的表达式，会被绘制为参数方程；但是在错误提示里它仍然视为点类型。

依赖 t 的点类型表达式会被绘制为参数曲线。

依赖 u, v 的点类型表达式会被绘制为参数曲面。

除此之外，使用 for 表达式也可以创建参数方程——这将完全确定它是参数方程。

- Desmos 语法：`(cos a, sin a) for 0 < a < 2pi`
- Destra 语法：``expr`(cos ${a}, sin ${a}) for 0 < ${a} < 1` ``

### 1.8 表达式 - 动作 (Expression - Actions)

动作是一种用于更新 Desmos 变量状态的指令对象，使用它可以创建一些“迭代”，“模拟”主题的图表，甚至可以编写小型程序和游戏。动作可以作为一种“表达式”类型存储于变量中。

使用 `->` 创建动作：
- Desmos 语法：
  ```
  a = 0
  a -> a + 1
  A = a -> 2 * a
  ```
- Destra 语法：
  ```javascript
  const a = expl`0`;
  const action1 = expr`${a} -> ${a} + 1`;
  const action2 = expl`${a} -> 2 * ${a}`.id('A');
  ```
- 结果：
  - a 是一个可以被修改的变量，其初始值为 0。
  - action1 是一个动作对象，可令变量 a 的值加 1。
  - action2 / "A" 是一个动作变量，可令变量 a 的值乘以 2。

优先级: 低于比较运算符，高于逗号。

动作是关于某个变量的赋值操作。Desmos 里可以在公式列表 GUI 界面点击按钮执行已被解析的动作，或者在“计时器”功能里以定时执行动作。

动作可以不赋予变量，也可以赋予变量。

动作类型可以通过逗号连接，表示并联执行：

- Desmos 语法：
  ```
  a = 0
  b = 1
  A = a -> b
  B = b -> a + b
  C = A, B
  ```
- Destra 语法：
  ```javascript
  const a = expl`0`;
  const b = expl`1`;
  const A = expl`${a} -> ${b}`;
  const B = expl`${b} -> ${a} + ${b}`;
  const C = expl`${A}, ${B}`;
  ```
- 结果：
  a, b 为初始值为 0 和 1 的变量，A, B, C 为动作变量，可令变量 a 和 b 的值发生变化。

  需要注意的是，动作为并联执行，每次更新时动作表达式里所参照的变量值为变量被其他动作表达式更新前的值，而非被其他变量表达式更新后的值。可以把 Desmos 变量系统整体看作一个状态机，每执行一次 / 一批动作，状态机就向前进行一次更新 / 迭代。

  执行 C 动作后，a 和 b 的值会交替变化，
  
  执行一次后 a 的值为 1，b 的值为 1；

  执行两次后 a 的值为 1，b 的值为 2；

  执行三次后 a 的值为 2，b 的值为 3；

  执行四次后 a 的值为 3，b 的值为 5；

  不断执行下去，a 和 b 的值会按斐波那契数列增长。

使用逗号连接时，不允许两个目标变量相同的动作表达式连接，否则会报错。例如：
- Desmos 语法：
  ```
  a = 0
  A_1 = a -> a + 1
  A_2 = a -> a + 2
  A = A_1, A_2
  ```
- Destra 语法：
  ```javascript
  const a = expl`0`;
  const A1 = expl`${a} -> ${a} + 1`;
  const A2 = expl`${a} -> ${a} + 2`;
  const A = expl`${A1}, ${A2}`;
  ```
- 结果：尝试解析 A 时会报错，因为两个动作表达式都试图更新变量 a 的值，导致冲突。

### 1.9 表达式 - 提示音 (Expression - Tones)

提示音是一种用于播放正弦波声音的对象。当一个公式的求值结果为一个提示音 / 一个提示音列表时，可以播放该提示音 / 多个提示音。

使用 `tone` 函数创建提示音。第一个参数为频率，第二个参数（可选）为音量。
- Desmos 语法：`tone(440, 1)`
- Destra 语法：``expr`tone(440, 1)` ``
- 结果：一个提示音对象，表示频率为 440 Hz，相对音量为 1 的提示音。点击可以播放该提示音。

可以让提示音依赖于变量，将提示音对象开启播放，然后通过控制变量来实时调制提示音的频率和音量。

如：
- Desmos 语法：
  ```
  T = 0, 滑动条：0:1/12:1
  f = 440 * 2^T
  v = 1
  tone(f, v)
  ```
- Destra 语法：
  ```javascript
  const T = expl`0 in 0:1/12:1`;
  const f = expl`440 * 2^${T}`;
  const v = expl`1`;
  const tone1 = expl`tone(${f}, ${v})`;
  ```
- 结果：播放该提示音，播放 T 的滑动条动画，则频率随 T 的值变化，音量保持不变，可以听出一个上行音阶。

### 1.10 表达式 - 分布 (Expression - Distributions)

分布是一种用于描述概率分布的数学对象。在 Desmos 里，分布可以作为表达式类型存储于变量中。分布的主要用途是用于随机数的生成，或者直接绘制该分布的概率密度图象 / 累计分布图象。

使用各类分布函数创建分布对象，分布函数见下文介绍，这里简单展示一个示例：

- Desmos 语法：
  ```
  normaldist(0, 1)
  ```
- Destra 语法：
  ```javascript
  const dist = expl`normaldist(0, 1)`;
  ```
- 结果：一个分布对象，表示均值为 0，标准差为 1 的正态分布。

### 1.11 统计推断测试 (Expression - Statistical Tests)

新版更新之后这部分变的太复杂了 多引入了好几种子类型和一堆方法式函数。。。。。

反正对我们来说也是边缘功能 暂时不做了（）

---

## 2. 语法完整列举

### 2.1 字面量语法 / 基本类型语法 (Literal Syntaxes / Syntaxes of Basic Types)

上文已经详细介绍了各类公式子类型及其对应字面量语法，这里不再赘述。

### 2.2 顶级语法 / 公式类型语法 (Top Level Syntaxes / Syntaxes of Formula Types)

一个公式的顶级语法，不同的顶级语法决定了该公式的公式类型——Destra 也依赖该语法特征，对模板字面量进行非语法解析的粗粒度扫描，并决定该公式的公式类型，生成对应的 Destra 公式对象。

另可参考[03-公式类型与符号系统.md](../Desmos建模/03-公式类型与符号系统.md)。

#### 2.2.1 变量定义 (Variable Definitions)

变量定义的语法为 `变量名 = 表达式`，例如 `a = 1`。详见 [核心API与命名机制.md](../技术笔记/JS路线/默认模式/核心API与命名机制.md)。

#### 2.2.2 函数定义 (Function Definitions)

Desmos 里函数定义的语法大致为 `函数名(参数列表) = 表达式`，例如 `f(x) = x^2`。

Destra 里函数定义可以使用多种语法：
```javascript
const f1 = expl`f1(x) = x^2`;
const f2 = expl`(x, y) => x^2 + y^2`;
const f3 = Func`x, y` (({x, y}) => expr`${x}^2 + ${y}^2`);
```

详见 [核心API与命名机制.md](../技术笔记/JS路线/默认模式/核心API与命名机制.md)。

#### 2.2.3 显式方程 (Explicit Equations)

显式方程的语法为 `因变量 = 表达式`，例如 `y = x^2`，`V = 4/3 * pi * R^3`。

需要让以下两种情况之一成立：

- 等号左侧的因变量为一个未定义变量。等号右侧的表达式需要依赖另一个未定义变量，且只依赖1个未定义变量。

- 等号左侧的因变量为 x, y 这两个保留变量(3D 计算器里为 x, y, z三个保留变量)中的一个。等号右侧的表达式可以依赖 x, y 保留变量中剩余的至多 1 个(3D 计算器里为 x, y, z三个保留变量中剩余的至多 2 个)。

- 等号左侧的因变量为 r。等号右侧的表达式至多可以依赖 theta （3D 计算器里为 theta 和 z）保留变量。此时表示极坐标方程（3D 计算器里若涉及 z 则为柱坐标方程，未涉及 z 则为 xy 平面上的极坐标方程，此时也可以通过勾选“拓展到3D”选项拓展为柱坐标方程）。

- 等号左侧的因变量为 rho。等号右侧的表达式至多可以依赖 phi 和 theta 2 个保留变量。此时仅限 3D 计算器可用，表示球坐标方程。

#### 2.2.4 隐式方程 / 不等式 (Implicit Equations / Inequalities)

隐式方程 / 不等式的语法为 `表达式 = 表达式`，例如 `x^2 + y^2 = 4`，

或 `表达式 < 表达式` 等等，不等号可为 `>`, `<`, `>=`, `<=`。例如 `y > sin(x)`。

两边的表达式仅可依赖 x, y 这两个保留变量，3D 计算器里为 x, y, z三个保留变量。

如果顶级运算符使用的是不等号，即使该公式符合显式方程的形式，也会被视为隐式方程 / 不等式。

#### 2.2.5 回归（Regression）

回归的语法为 `因变量 ~ 表达式`，例如 `y ~ x`，`y ~ m x + b`。

因变量需为一个已定义的变量，表达式可以依赖若干未定义变量。

回归公式的作用在于基于已知序列数据（源于已定义变量，需为列表），反解、“回归”出各个回归参数（即未定义变量）。回归公式本身会对这些未定义变量施加定义效果，为它们赋值，使它们变为已定义变量，可供后续表达式使用。

### 2.3 运算符 (Operators)

DSL 支持 Desmos 所有的数学运算符。

### 2.3.1 算术运算符 (Arithmetic Operators)

按优先级从高到低排列如下：

- 阶乘: `!` (如 `5!`)
- 指数: `^` (如 `x^2`)。Desmos 里 LaTeX 内容通常对指数运算有完整的括号结构，但在 Destra 里我们需要指定其结合性。我们指定指数运算符为右结合运算符。
- n次根号: `rootof` (如 `3 rootof (x^2 - 4)` 为 `cbrt(x^2 - 4)`)。为右结合运算符。
  - 这是 Destra 提供的语法糖，会转换为 `x^(1/n)` 形式。
- 一元负号: `-` (如 `-x`)；一元正号: `+` (如 `+x`)。
- 乘除/百分比/模: `*`, `/`, `%of` (如 `5 %of 100`), `%`。为左结合运算符。
  - 关于百分比，Desmos 里不支持 `5%` 这样的写法，只能写 `5 %of 100`。键入 `%` 会自动转换为 `%of`。
  - Desmos 里的模运算需要使用 `mod` 函数，例如 `mod(5, 3)` 表示 5 除以 3 的余数。但是因为上方留出了单独 `%` 运算符的空缺，我们可以在 Destra 里支持 `5 % 3` 表示取模/取余数的语法，并编译时转为 mod 函数调用形式。
- 加减: `+`, `-`。为左结合运算符。

### 2.3.2 比较与逻辑运算符 (Comparison and Logical Operators)
**原生支持**:
- 大于/小于: `>`, `<`
- 大于等于/小于等于: `>=` (`\ge`), `<=` (`\le`)
- 等于: `=`, `==`
  - 在 Desmos 条件表达式中使用单等号 `=` 即可表示相等判断；但是在 Destra 里布尔值需要能够作为中间值使用，使用单等号会和显式/隐式方程语法冲突，因此如果需要将等号视为相等判断，需要显式使用 `==` 语法，或者在两边加上括号（位于括号内的等号不会被检测为方程候选），否则会被视为方程。

优先级: 低于加减法。

这些运算符可以连接使用：
- Desmos 语法：
  ```
  0 < a_1 < a_2 < 2
  0 < a_1 < a_2 > a_3
  ```
- Destra 语法：
  ```javascript
  const a1 = expl`a_1`;
  const a2 = expl`a_2`;
  const a3 = expl`a_3`;
  const bool1 = expl`0 < ${a1} < ${a2} < 2`;
  const bool2 = expl`0 < ${a1} < ${a2} > ${a3}`;
  ```

**关于布尔逻辑组合**:
Desmos 原生并不直接支持 C 风格的 `&&`, `||` 运算符用于布尔值运算。通常我们需要利用分段表达式语法，比较运算符连接，或算术表达式混合来间接实现布尔逻辑。
*注: 未来的 Destra 预处理器可能会支持 `&&`, `||`, `!` 等语法糖并自动转换为 Desmos 兼容格式。*

### 2.4 属性访问语法 (Property Access Syntaxes) 与 函数调用语法 (Function Call Syntaxes)

- **普通函数调用语法**:
  - 普通函数调用语法为 `函数名(参数列表)`，例如 `count(L)`。

- **属性访问语法**:
  - 对于点或特定对象，可以用点运算符访问其属性，语法为 `对象.属性`。
  - 优先级：最高。
  - **属性列表**:
    - x, y, z 坐标：`.x`, `.y`, `.z`。取点的 x, y, z 坐标。

值得注意的是，部分函数也可以用属性访问的风格 / 使用点运算符调用。如 `L.count` 等价于 `count(L)`。

但是并非所有属性访问语法都支持普通函数调用语法，也并非所有内置函数都支持这种看似属性访问的风格。这些内置函数在支持 `L.count` 形式的同时必定也支持 `L.count()` 形式。因此这些内置函数更应该看作支持拓展函数语法的函数。

因此我们可以区分属性和支持拓展函数语法的内置函数。属性只支持 `P.x` 点运算符访问，而支持拓展函数语法的内置函数支持 `count(L)`, `L.count`, `L.count()` 全部三种形式。

- **拓展函数语法**:
  - 拓展函数语法为 `接收者.函数名(参数列表)` 或 `接收者.函数名`，例如 `L.count()`, `L.count`。
  - 优先级：最高。

### 2.5 分段表达式 (Piecewise Expressions)

Desmos 使用大括号 `{}` 语法来表示分段函数或条件限制。

**语法**: `{ 条件: 值, 默认值 }` 或 `{ 条件1: 值1, 条件2: 值2, ... }`

```javascript
// if x > 0 then 1 else -1
expr`{${x} > 0: 1, -1}`

// if x > 0 then 1 else if x < 0 then -1 else 0
expr`{${x} > 0: 1, ${x} < 0: -1, 0}`
```

在 Destra 里我们即把“条件”部分抽象成了布尔值类型。

**域限制用法**:

Desmos 里还有一种可以“限制定义域”的语法：
- Desmos 语法：`y = x {x > 0}`
- Destra 语法：``expr`y = x {x > 0}` ``
- 结果：仅在 x > 0 范围内绘制 y = x直线。

**默认值**:

但是上面的语法本质上也是分段表达式，利用了它的一些高级特性。

在每个分支里可以省略其`: 值`部分，此时如果计算匹配到该分支，则输出值为 1。如果没有匹配到任何分支，并且在末尾没有指定默认值，则输出值为 `undefined`。Desmos 里会把 undefined 值进行不绘制处理。

上面的例子本质上是: `y = (x * {x > 0: 1, undefined})`，即，限定定义域其实就是乘以一个分段表达式。

在 x > 0 的区域，是 `x * 1` = `x`，因此绘制的是 `y = x`。

在 x <= 0 的区域，是 `x * undefined` = `undefined`，因此绘制的是 `y = undefined`，即不绘制。（注：无论是 Desmos 还是 Destra 都不支持直接写 undefined 字面量，undefined 值需要通过间接方式构造。）

因此我们可以用它实现一些其他的操作，如：
- Desmos 语法：`y = x {x < 0, x > 1}`
- Destra 语法：``expr`y = x {x < 0, x > 1}` ``
- 结果：不在 [0, 1] 区间内绘制直线，因为该区间内无法匹配到任何分支。

**分支优先级**:

靠前的分支优先匹配。

### 2.6 上下文与作用域语句 (Scope Syntaxes)

虽然 Destra 提供了 `For`, `With`, `Sum`, `Int`, `Func` 等工厂函数来通过 JS 回调构建这些结构，但在 Expr DSL 中，你也可以直接使用类似 Desmos 原生语法的语法来创建这些结构。

另可参考[上下文语句创建.md](../技术笔记/JS路线/默认模式/上下文语句创建.md)。

上下文变量会覆盖 x, y, z, r, rho, theta, phi 这些保留变量。

#### 2.6.1 For 表达式 / 列表推导 (For Expression / List Comprehension)
语法: `[表达式 for 变量 = 列表]`，`(表达式 for 变量 = 列表)`。顶级可以省略 `[]` 或 `()` 包裹。
优先级: 仅高于加减法。

```javascript
expr`[x^2 for x = [1...10]]`
// 多变量
expr`(x + y for x = [1...5], y = [1...5])`
expr`(i, j) for i = [1...10], j = [1...10]`
```

#### 2.6.2 With 表达式 (Let Binding)
语法: `表达式 with 变量 = 值`
优先级: 仅高于加减法。

```javascript
expr`a^2 + b^2 with a = sin(x), b = cos(x)`
```

Desmos 里，对 for, with 表达式支持顶级省略 `[]` 或 `()` 包裹的写法。Destra 里为了支持这种写法，在检测到唯一的顶级（不在任何括号层级内）等号时，将首先尝试解析为 for/with 表达式（识别 for/with 关键字、推导变量、等号 3 个元素），如果解析失败，则尝试解析为方程。

#### 2.6.3 求和与求积 (Sum & Product)
语法: `sum(变量=下界, 上界) 表达式` / `prod(变量=下界, 上界) 表达式`
优先级: 仅高于加减法。

```javascript
expr`sum(n=1, 10) n^2`
expr`prod(n=1, 10) n`
```
*注: Desmos 输入框中输入 `sum` 会自动变为求和符号 $\sum$。DSL 中直接写 `sum` 即可。*

#### 2.6.4 积分 (Integrals)
语法: `int(下界, 上界) 表达式 d变量` / `int(下界, 上界) d变量 表达式`
优先级: 仅高于加减法。

```javascript
expr`int(0, 1) x^2 dx`
```
注:
- Destra 对 `dx` 的位置进行宽松处理（允许 `dx` 前置），并会在解析时自动把 `dx` 移至最后，将这种写法转换为 Desmos 认为正确的写法。
- Desmos 和 Destra 里对省略乘号的连乘表达式支持比较有限，这里的 dx 是少数支持连乘的地方之一。
- 前置/后置的判据是 `int(l, u)`和`dx`之间是否有表达式内容。

#### 2.6.5 微分算子

在 Desmos 里微分算子是一个非常特殊的特性。但在默认模式里为了简单起见我们将其简化为一个类似上下文语句的语法。

语法: `d/d变量 表达式`
优先级: 仅高于上下文语法。

```javascript
expr`d/dx x^2` // 等价于 expr`x`
```

### 2.7 列表索引

- **列表索引 (Indexing)**:
  
  支持对列表使用方括号进行索引。索引从 1 开始。
  - Desmos 语法: `L[1]`;
  - Destra 语法: ``expr`${L}[1]` ``
  
  支持对列表进行切片，按索引构造出新的列表。
  - Desmos 语法: 
    ```
    L[[1...5]]
    L[[1, 3, 5]]
    L[1...5]    // 中括号可以省略
    L[1, 3, 5]
    ```
  - Destra 语法: 
    ```javascript
    expr`${L}[[1...5]]`      // 切片，取第 1 到 5 个元素
    expr`${L}[[1, 3, 5]]`  // 取第 1, 3, 5 个元素
    expr`${L}[1...5]`      // 中括号可以省略
    expr`${L}[1, 3, 5]`
    ```

- **列表过滤 (Filtering)**:
  支持对列表进行过滤，按条件（事实上是布尔值列表）构造出新的列表。
  - Desmos 语法: `L[L > 5]`;
  - Destra 语法: ``expr`${L}[${L} > 5]` ``

### 2.8 in 运算符

语法: `变量定义 in 下界:步长:上界`。

见[属性与样式API.md](../技术笔记/JS路线/默认模式/属性与样式API.md)。

Destra 中，用于指定变量定义的滑动条属性。

下界、步长、上界可以省略。

步长省略时，两个冒号可以简写为一个冒号。

### 2.9 空白与注释

Destra 的解析器对空格不敏感。你可以在 DSL 中随意添加空格换行以增加可读性。

此外，Destra 的解析器支持 **JS 风格的单行注释** (`//`)，这些注释会在编译阶段被剔除，不会传递给 Desmos。

```javascript
expr`
  [
    x^2, // 抛物线
    x    // 直线
  ]
`
```

### 2.10 省略乘号的连乘表达式支持

- 在小括号、中括号后方接表达式，在大括号前后接表达式，支持连乘。
- 在积分语法中，前置/后置的 dx 和表达式之间留有空白，支持连乘。
- **数值后接任何表达式**：数值字面量后方如果紧跟**任何**合法的、能开始一个表达式的符号（如标识符、内置函数、括号、列表、插值占位符等），都支持省略乘号连乘。
  - 例：`2x`, `2sin(x)`, `2${var}`, `2(x+1)`, `2[1,2]` 均合法。
  - 可以间隔空白，也可以不间隔空白，只要不引起歧义（如 `pi x` 必须间隔空白才可被视为 `pi * x`，`pix`会整体解析为新的标识符/变量名 `pix`）。

### 2.11 省略括号的函数调用支持

- 三角函数: `sin`, `cos`, 等等。
- `log`, `ln`。

实验中观察到优先级可能在乘除与上下文语法之间。

在 desmos 里检测到太复杂的结构似乎会拒绝使用省略括号用法，特性尚不清楚。

所以为了简单起见目前我们仅支持在参数内容为一元正负号及以上表达式时使用省略括号用法。后方有接乘除号时将转为带括号形式。

---

## 3. 运算符优先级——完整列举

按高到低排序：

- 属性访问 `.attr`, 拓展函数语法: `L.count()`, `L.count`。
- 阶乘: `!` (如 `5!`), 列表索引: `L[i]`, 函数调用: `f(x)`。
- 指数: `^` (如 `x^2`)。暂定其优先级低于阶乘。为右结合运算符。
- n次根号: `rootof` (如 `3 rootof (x^2 - 4)` 为 `cbrt(x^2 - 4)`)。暂定其优先级低于指数。为右结合运算符。
- 一元负号: `-` (如 `-x`)；一元正号: `+` (如 `+x`)。
- 可省略括号的函数调用: `sin`, `cos` 等。
- 乘除/百分比/模: `*`, `/`, `%of` (如 `5 %of 100`), `%`。为左结合运算符。
- 上下文语法：`for`, `with`, `sum`, `prod`, `int`; 以及微分算子`d/dx`。
  - 对于`for`, `with`, 检测其后方的所有比较运算符，直到其所在括号层级结束为止；子级括号层级的内容忽略。若有不符合`for`, `with`语法的比较运算符，则报错。
- 加减: `+`, `-`。为左结合运算符。
- 动作: `->`。
- 比较运算符，回归，定义: `>`, `<`, `>=`, `<=`, `=`, `==`, `~`, `=>`。
- 冒号: `:`。
- 逗号: `,`。
- in 运算符: `in`。

小、中、大括号即为通常用法，重置优先级。

## 4. 内置函数大全 (Built-in Functions Reference)

### 4.1 基础与微积分 (Basics & Calculus)
- `abs(x)`: 绝对值
- `sqrt(x)`: 平方根
- `cbrt(x)`: 立方根
- `exp(x)`: $e^x$
- `ln(x)`: $\ln x$，支持省略括号用法。
- `log(x)`: $\log_{10} x$，支持省略括号用法。
- `log(b, x)`: $\log_b x$

### 4.2 三角函数 (Trigonometry)
- **基础**: `sin`, `cos`, `tan`, `cot`, `sec`, `csc`
- **反三角**: `arcsin`/`asin`, `arccos`/`acos`, `arctan`/`atan`, `arccot`/`acot`, `arcsec`/`asec`, `arccsc`/`acsc`
  - *注: `arctan(y, x)` / `atan(y, x)` 支持两参数形式 (即其他领域里常称的 `atan2`)*
- **双曲**: `sinh`, `cosh`, `tanh`, `coth`, `sech`, `csch`
- **反双曲**: `arcsinh`/`asinh`, `arccosh`/`acosh`, `arctanh`/`atanh`, `arccoth`/`acoth`, `arcsech`/`asech`, `arccsch`/`acsch`
- 全部三角类函数支持省略括号用法（`arctan(y, x)` / `atan(y, x)` 除外）。

### 4.3 数论与组合 (Number Theory)
- `sign(x)`: 符号函数
- `round(x)`, `round(x, n)`: 四舍五入
- `floor(x)`: 向下取整
- `ceil(x)`: 向上取整
- `mod(a, b)`: 取模 (a % b)
- `gcd(a, b, ...)`, `gcd(L)`, `L.gcd`: 最大公约数。支持拓展函数语法。
- `lcm(a, b, ...)`, `lcm(L)`, `L.lcm`: 最小公倍数。支持拓展函数语法。
- `nCr(n, r)`: 组合数
- `nPr(n, r)`: 排列数

### 4.4 复数 (Complex Numbers)
- `real(z)`, `z.real`: 实部。支持拓展函数语法。
- `imag(z)`, `z.imag`: 虚部。支持拓展函数语法。
- `arg(z)`: 辐角
- `conj(z)`: 共轭

### 4.5 几何 (Geometry)
- `distance(p1, p2)`: 两点距离 (或点到线/线段距离)
- `midpoint(p1, p2)`: 中点
- `polygon(p1, p2, ...)`, `polygon(L)`: 构建多边形
- `length(vector/segment)`, `(vector/segment).length`: 向量/线段长度。支持拓展函数语法。

### 4.6 列表操作 (List Operations)
- `join`: 将元素和/或列表连接成一个大列表。
  - `join(x1 | L1, x2 | L2...)` (>= 2 个参数)
  - `L.join(x | L...)` (>= 1 个参数)，支持拓展函数语法。
  - `x.join(x1 | L1, x2 | L2...)` (>= 2 个参数) (注: 实验发现调用主体 x 居然会被忽略... 这是 Desmos 的有意设计吗?)
- `sort`: 排序。
  - `sort(L)`, `L.sort`: 升序排序。支持拓展函数语法。
  - `sort(L, keys)`, `L.sort(keys)`: 根据 keys 列表排序 L。支持拓展函数语法。
- `shuffle`: 随机打乱。
  - `shuffle(L)`, `L.shuffle`: 随机打乱。支持拓展函数语法。
  - `shuffle(L, seed)`, `L.shuffle(seed)`: 带种子打乱。支持拓展函数语法。
- `unique(L)`, `L.unique`: 去重。支持拓展函数语法。

### 4.7 统计 (Statistics)
- **聚合**:
  - `total(x1, x2, ...)`, `total(L)`, `L.total`: 求和。支持拓展函数语法。
  - `mean(x1, x2, ...)`, `mean(L)`, `L.mean`: 平均值。支持拓展函数语法。
  - `median(x1, x2, ...)`, `median(L)`, `L.median`: 中位数。支持拓展函数语法。
  - `min(x1, x2, ...)`, `min(L)`, `L.min`: 最小值。支持拓展函数语法。
  - `max(x1, x2, ...)`, `max(L)`, `L.max`: 最大值。支持拓展函数语法。
  - `count(x1, x2, ...)`, `count(L)`, `L.count`: 元素个数。支持拓展函数语法。
    - *注: 因为一些历史原因，在 2D 计算器里曾经使用 `length` 函数取列表的长度。Desmos 一直在鼓励用户迁移至新的 `count` 函数。现今只有在 2D 计算器里仍然可用 `length` 函数取列表的长度，但为了未来兼容性，我们将直接假定 `count` 为列表长度的函数，而 `length` 为其新版含义--计算矢量长度的函数。*
- **离散度**:
  - `stdev(x1, x2, ...)`, `stdev(L)`, `L.stdev`: 标准差 (样本/总体)。支持拓展函数语法。
  - `stdevp(x1, x2, ...)`, `stdevp(L)`, `L.stdevp`: 标准差 (样本/总体)。支持拓展函数语法。
  - `var(x1, x2, ...)`, `var(L)`, `L.var`: 方差 (样本/总体)。支持拓展函数语法。
  - `varp(x1, x2, ...)`, `varp(L)`, `L.varp`: 方差 (样本/总体)。支持拓展函数语法。
  - `mad(x1, x2, ...)`, `mad(L)`, `L.mad`: 绝对中位差。支持拓展函数语法。
- **相关性**:
  - `cov(L1, L2)`, `covp(L1, L2)`: 协方差
  - `corr(L1, L2)`: 相关系数
  - `spearman(L1, L2)`: Spearman 秩相关系数
- **分位数**:
  - `quantile(L, p)`, `L.quantile(p)`: 分位数。支持拓展函数语法。
  - `quartile(L, n)`, `L.quartile(n)`: 四分位数。支持拓展函数语法。

### 4.8 随机与分布 (Random & Distributions)
- **随机数**:
  - 基于 [0, 1) 均匀分布采样:
    - `random()`: [0, 1) 随机数
    - `random(n)`: 生成 n 个 [0, 1) 随机数
    - `random(n, seed)`: 生成 n 个 [0, 1) 随机数，种子为 seed。
  - 基于列表均匀分布采样:
    - `random(L)`, `L.random`: 从列表 L 中随机取样。支持拓展函数语法。
    - `random(L, n)`, `L.random(n)`: 从列表 L 中随机取 n 个样。支持拓展函数语法。
    - `random(L, n, seed)`, `L.random(n, seed)`: 从列表 L 中随机取 n 个样，种子为 seed。支持拓展函数语法。
  - 基于给定分布对象采样:
    - `random(D)`, `D.random`: 从分布 D 中随机取样。支持拓展函数语法。
    - `random(D, n)`, `D.random(n)`: 从分布 D 中随机取 n 个样。支持拓展函数语法。
    - `random(D, n, seed)`, `D.random(n, seed)`: 从分布 D 中随机取 n 个样，种子为 seed。支持拓展函数语法。
- **分布对象**:
  - `normaldist(mean, stdev)`
  - `tdist(df)`
  - `poissondist(lambda)`
  - `binomialdist(n, p)`
  - `uniformdist(min, max)`
- **分布函数**:
  - `pdf(D, x)`: 概率密度
  - `cdf(D, x)`: 累积分布
  - `inversecdf(D, p)`: 逆累积分布
  - `inversecdf(L, p)`: 基于列表 (离散分布) 的逆累积分布

关于随机种子: 请见 Desmos Help Center 的 [Statistics](https://help.desmos.com/hc/en-us/articles/4405633253389-Statistics) 页面 "Generating Random Values" > "A Note on Random Seeds" 章节。

### 4.9 其他杂项
- `tone(f)`, `tone(f, a)`: 播放频率为 f 音量为 a 的提示音。

### 4.10 统计检验 (Statistical Tests)

如前文所述，这里暂时省略。

---


