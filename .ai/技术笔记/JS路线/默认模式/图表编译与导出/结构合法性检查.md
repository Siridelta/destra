# 结构合法性检查

> 本文档是 [编译与导出](./index.md) 流程中 "Step 1.5: 结构合法性检查" 的详细方案。它位于 ID 索引构建之后，旨在确保图表的依赖结构符合 Destra 和 Desmos 的限制。并且出于优化考虑，大部分检查工作被前移至公式创建时计算。

由于 Destra 是 JS 库，通用编程语言能力带来的灵活性允许用户构建复杂的 JS 对象依赖图，但也会引入一些 Destra （至少默认模式）所不期望的、无法通过机制设计本身完美避免的极端情况。因此需要此步骤负责在编译早期手动识别并拦截这些非法结构。

**核心原则**: 一个上下文变量 (`CtxVar`) **只能**被其所属的 `CtxExp` (Factory Formula) 的 `body` 表达式及其下游依赖所引用（允许 body 表达式间接依赖 CtxVar 对象），因此从每个 CtxVar 对象出发，抵达所有可达 root formula 的所有可能的路径上，都必须经过一次其所属的 CtxExp 对象。

**违规场景示例**:

```javascript
// 1. 全局逃逸：CtxVar 被直接用作全局公式
let a_leak = null;
const v = expl.With`a=1`(({a}) => {
    a_leak = a;
    return a;
});
const leak = expr`${a_leak} + 1`; // leak 在 With 外部引用了 a_leak，导致 a 逃逸到全局

// 2. 交叉引用（菱形依赖逃逸）：; 
let leak_a = null;
// Path 1: Valid
const A = expl.With`a=1`(({a}) => {
    leak_a = a;
    const a_I1 = expl`${a}^2`;
    const a_I2 = expl`${a_I1}^3`;
    return a_I2;
}); 
// Path 2: Invalid - 此处 leak 逃逸到外部，导致 a 逃逸到另一个作用域。
// 但是 With 工厂无法对传入的非自源 ctxVar 进行检查，因为要允许本 with 语句的祖先域的 ctxVar 传递进来。
const B = expl.With`b=2`(({b}) => {
    const b_I1 = expl`${b}^2 + ${{leak_a}}`;
    const b_I2 = expl`${b_I1}^3 + 1`;
    return b_I2;
});

const C = expr`${A} + ${B}`; // 在 B 路径里依赖 leak 出来的 a，导致结构非法

// 菱形依赖路径：
// Path 1: ( a -> a_I1 -> a_I2 -)-> A -> C
// Path 2: ( a -)-> leak_a -(-> b_I1 -> b_I2 -)-> B -> C
```

**关于“菱形依赖”**:

在没有上下文语句的情况下，菱形依赖是 Desmos 和 Destra 里非常常见的现象，Destra 特性也天然支持构造菱形依赖。在添加上下文语句功能后，实际上既存在非法的菱形依赖结构，也存在合法的菱形依赖结构。

上面展示了一个非法的菱形依赖示例。这里再展示一个合法的菱形依赖示例：

```javascript
// 共同依赖
const base = expl`0 in 0:1:5`;

const A = expl.Sum`n=1, 5`(n => 
    expr`${base} ^ (2*${n} + 1)`
);
const B = expl.Sum`n=1, 5`(n => 
    expr`${base} ^ (2*${n})`
);
const C = expr`${A} - ${B}`; // 合法的菱形依赖
```

虽然 base 成为了共同的依赖，但我们利用 callback 编写上下文语句的设计，确保（或者说至少明面上引导了）用户只要编写的上下文语句（身体表达式）依赖于共同依赖（如 base），那么共同依赖一定位于 A 和 B 的 callback 外，也就是（常规手段下）一定无法拿取到 A 和 B 的 ctxVar 对象，base 一定没有 a 和 b 这些 ctxVar 对象的依赖，是“干净”的。

## 核心算法：创建时需求计算 (Creation-time Requirement Calculation)

我们将“合法性检查”前置到**公式创建阶段**。每个公式对象在创建时，会即时计算并存储其“合法性元数据”（`CtxValidityState`）。这使得大多数非法结构（如非法闭包、非法 With 嵌套）能在定义时即被拦截，而“变量逃逸”则推迟到编译时的 Root 检查。

### 1. 状态定义

在 `FormulaState` 中引入 `ctxValidity` 子状态：

```typescript
interface CtxValidityState {
    /**
     * 缺少的上下文集合 (Missing Requirements)
     * 代表该节点依赖了这些 Context 的变量，但尚未被这些 Context 包裹。
     * 集合元素为 CtxExp 对象。
     */
    missingCtxs: Set<CtxExp>;
    
    /**
     * 内部是否存在内联 With 语句 (Has Inline With)
     * 用于检测非法的 With 嵌套。
     * 当路径被 Expl (具名公式) 切断时，此属性重置为 false。
     */
    hasInlineWith: boolean;
}
```

### 2. 计算规则 (按节点类型)

#### 2.1 上下文变量 (CtxVar)
*   `missingCtxs`: `{ this.sourceCtx }` (依赖其定义者)
*   `hasInlineWith`: `false`

#### 2.2 普通表达式 (Expression)
*   `missingCtxs`: $\bigcup_{d \in deps} d.state.missingCtxs$
*   `hasInlineWith`: $\bigvee_{d \in deps} d.state.hasInlineWith$

#### 2.3 具名公式 (Expl) - 变量
*   `missingCtxs`: $\bigcup_{d \in deps} d.state.missingCtxs$ (允许需求穿透，成为“有孔”组件)
*   `hasInlineWith`: `false` (Expl 阻断 With 嵌套传播)

#### 2.4 上下文表达式 (CtxExp) - 通用逻辑
*   先计算 `body` 的需求 $R_{body}$。
*   **Requirement Satisfaction**: $NetMissing = R_{body} \setminus \{ this \}$
*   再合并 `head` (如 range 定义) 的需求 $R_{head}$。
*   `missingCtxs`: $NetMissing \cup R_{head}$
*   `hasInlineWith`: 继承 `body`，除非自身是 With。

#### 2.5 即时报错检查 (Instant Fail)

*   **非法闭包 (Illegal Closure)**:
    *   在创建 **FuncExpl** 或 **CtxFuncExpl** 时，计算完 $NetMissing$ 后，检查其中是否包含**非自身参数**的 Context。
    *   如果有，**立即报错**。Desmos 函数不支持闭包。
*   **非法 With 嵌套 (Illegal Nested With)**:
    *   在创建 **With** 类型的 `CtxExp` 时，检查 `body.state.hasInlineWith`。
    *   如果为 `true`，**立即报错**。Desmos 不支持 With 语句直接嵌套。
*   **定义自循环 (Self-Reference in Definition)**:
    *   在创建 `CtxExp` 时，检查 `head` 的依赖。如果依赖了本 Context 定义的变量，**立即报错**。

### 3. 编译时最终检查 (Step 1.5)

由于大部分检查已在创建时完成，Step 1.5 简化为对图表根节点的最终验收。

1.  **遍历验证**: 遍历 `Graph.root` 中的所有公式。】
    *   检查每个 Root 公式的 `state.missingCtxs`。
    *   **如果非空**: 报错 **CtxVar Leakage** (变量逃逸)。
    *   *解释*: 任何最终出现在图表中的公式，必须是“上下文自洽”的。如果它还缺少上下文（即依赖了未被满足的 CtxVar），说明发生了变量逃逸并在后面重新归入了公式依赖树，但是绕过了对应的 CtxExp。

---

### 4. 总结

该方案将 $O(N)$ 的遍历分散到了对象创建期，使得：
1.  **错误反馈更早**: 闭包和嵌套错误在定义行直接抛出，堆栈信息更友好。
2.  **编译极速**: 编译阶段只需检查 Root 节点的 Set 是否为空。
3.  **支持局部组件**: `Expl` 允许携带未满足的需求，只要最终使用它的环境能满足这些需求即可，增强了模块化能力。
4.  **多规则检查逻辑更清晰**: 将多个检查规则直接体现为 sidecar state 里的多个子状态数据，并统一在创建时等价遍历的框架内平行处理，更加直观。
