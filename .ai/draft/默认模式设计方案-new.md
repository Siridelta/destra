# Destra “默认模式”设计方案

> 本文档详细阐述 Destra 项目“默认模式”的具体技术设计。

**默认模式** 是 Destra 库的主要开发方向和推荐使用方式。其核心目标是提供一个**高度封装、专注于表达式组合与复用的工具框架**。它旨在简化 Desmos 图表的构建过程，让用户可以像编写模块化代码一样来组织复杂的数学逻辑。

## 适用场景

适用于需要构建大型、复杂、可维护的 Desmos 图表的开发者，特别是那些希望将软件工程的最佳实践（如模块化、封装、代码复用）应用于数学可视化创作的场景。

## 核心设计决策

为了实现上述目标，默认模式在设计上有明确的取舍，它在 Desmos 原生灵活性的基础上，增加了工程化的确定性与可维护性。

### 1. 依赖管理：禁止悬空依赖

严格禁止任何形式的悬空依赖。一个表达式被创建时，它所依赖的所有符号必须已经定义。这确保了依赖图在任何时候都是完整和确定的，从而简化了分析和计算过程。

### 2. 上下文语句：统一为弱绑定回调模式

为了消除歧义并增强封装性，所有上下文语句都将采用统一的“弱绑定”实现模式。它们只负责为其内部作用域提供局部变量，而不影响任何上游表达式的结构。这种模式确保了作用域的清晰隔离，杜绝了“下游影响上游”的复杂情况。

### 3. 命名、封装与模块化机制

开发一套强大的命名、封装与模块化机制，设计“中间名”在 JS 环境的灵活但短暂的命名 与 Desmos 环境的严格命名范围之间建立桥梁，并支持代码的组织与分发。

---

## 命名、封装与模块化机制

默认模式的核心是一套强大的命名、封装与模块化机制，它解决了 JS 环境的灵活性与 Desmos 环境的严格性之间的矛盾，并为代码的组织与分发提供了健壮的解决方案。

### 1. 三层命名系统

为了解耦代码中的临时变量和图表中的最终符号，我们引入一个三层命名系统：

-   **JS 变量名**: 用户在代码中声明的变量名，如 `myObjectVelocity`。它仅在代码的上下文中有效，且会被预处理器用于推断初始的 Destra ID。
-   **Destra ID (主键)**: 一个全局唯一的字符串标识符，是表达式在 Destra 系统中的**真正身份**。它与物理文件结构解耦，由开发者通过 API 进行组织和维护，是实现模块化的基石。
-   **Desmos 变量名 (真名)**: 最终生成到 Desmos 图表中的符号名。Destra 会默认根据 Destra ID 生成可读的变量名并自动解决冲突，也允许用户通过特定 API 强制指定它。

### 2. 核心原则：拥抱可变性与工具链增强

-   **ID 体系与文件结构解耦**: 库作者负责主动维护一个稳定的、与物理文件结构**异构**的逻辑 ID 体系。这意味着代码文件的移动和重命名，不会影响库的公共 API 契约。
-   **拥抱可变 API**: 为了能在批量操作（如添加命名空间）中维持对象间的依赖引用关系，ID 操作 API 被设计为**可变的 (Mutable)**，即直接修改对象自身，而非返回新对象。
-   **工具链增强 DevEx**: 我们不依赖静态类型系统传递所有动态信息，而是通过强大的**外部 IDE 插件（Volar）**来动态计算和展示表达式的最终 ID 等信息，以提升开发者体验。

### 3. 核心 API

#### a. 表达式创建

-   ``expl`...` ``: 创建一个具名声明（statement）。
-   ``expr`...` ``: 创建一个可内联的公式片段（expression）。

**隐式 ID 分配**: 在创作形式下，预处理器会自动将 JS 变量名作为初始的 Destra ID。

```javascript
// 经预处理器转换后，
// a 的初始 Destra ID 会被自动设置为 "a"
const a = expl`1`; 
```

#### b. ID 组织与批量操作

-   `group({ a, b, ... })`: 核心辅助函数，用于将一组表达式或 `builder` 聚合为一个逻辑单元，以进行后续的批量操作。

-   `.idPrepend(segment: string)`: **可变 API**，为 `group` 内所有对象的 ID 路径**前置**一个 ID 段（segment）。所有 ID 段均通过点号 (`.`) 连接。

```javascript
// my-lib/physics.js
import { expl, group } from 'destra';

let position = expl`0`;
let velocity = expl`9.8`;
let gravity = expl`...`;

// 使用 group 和 idPrepend 构建逻辑 ID 树
const physics = group({
    position,
    velocity,
    gravity,
}).idPrepend('my-lib.physics');

// 此时，velocity 对象的最终 Destra ID 变为 "my-lib.physics.velocity"
// 注意：该操作直接修改了 velocity 对象本身

export { position, velocity, gravity }; // 推荐使用扁平导出
```

#### c. 强制命名 API

-   `.id("unique-id")`: 手动覆盖自动生成的 Destra ID，用于精确控制或处理特殊情况。
-   `.realname("desmos_name")`: 强制指定最终的 Desmos 变量名，用于实现依赖特定变量名的高级功能（如键盘 Hack）。

#### d. 动态表达式与 `builder`

-   `builder(callback)`: 将动态表达式构造器提升为一等公民，使其可以无缝参与 `group` 和批量 ID 操作，从而构建可参数化的复杂模块。

### 4. 模块化与分发

-   **标准 JS 模块**: 我们完全拥抱标准的 `import/export` 语法，废弃了任何自定义的打包函数。库作者和使用者都使用他们熟悉的 JS 生态标准。
-   **扁平导出模式 (推荐)**: 库作者应尽可能将 `group` 内的变量解构后独立导出（如上例所示）。这可以确保 IDE 获得最佳的静态分析能力，为代码跳转、类型提示和我们的自定义悬停信息功能提供支持。

### 5. 开发者体验 (DevEx) 工具链

Destra 的开发者体验由一个协同工作的工具链体系支撑，而非在运行时库中实现所有功能。

-   **预处理器 (Preprocessor)**: 核心能力模块，负责将开发者编写的、简洁的“创作形式”代码，转换为系统内部使用的、信息完备的“标准形式”代码（例如，自动注入 `.id()` 调用）。
-   **Vite 插件**: 在 Vite 构建或开发服务器中调用预处理器，对源码进行实时转换。
-   **Volar 语言服务 / IDE 插件**: 在代码编辑器中实时分析代码，提供关键的 DevEx 功能，例如：
    -   **ID 动态计算与预览**: 鼠标悬停到变量上时，可动态计算并显示其经过各种 `idPrepend` 操作后的最终 Destra ID。
    -   **自定义悬停信息**: 库作者可以通过 `.hoverInfo(callback)` API 为表达式提供自定义的文档和信息，这些信息也会在悬停时展示。
-   **`create-destra` CLI**: 一个轻量级脚手架工具，用于快速搭建预设好所有配置的 Destra 项目模板。

这个设计体系通过将 ID 的**组织能力**交给开发者，将 ID 的**追踪和展示**交给工具链，在灵活性、稳定性和开发者体验之间取得了理想的平衡。
