# 上下文变量真名决议

> 本文档是 [编译与导出](./index.md) 流程中 "Step 3: 上下文变量真名决议" 的详细实现方案。它重点解决了混合嵌套作用域下的命名冲突问题。

在 Destra 中，上下文变量 (`CtxVar`) 的作用域不仅跨越了 DSL 字符串边界，还穿透了 Formula 对象之间的依赖关系。为了在 Desmos 的扁平命名空间中正确模拟这些嵌套作用域并避免冲突，我们需要引入一个专门的 **Scope Tree** 数据结构。

## 1. 核心数据结构：Scope Tree

Scope Tree 是一个独立于 AST 和 Dependency Graph 的树状结构，专门用于描述上下文变量的作用域层级。它将所有“作用域产生者”（无论是工厂创建的 Formula 还是内部 DSL 解析出的 AST 节点）统一抽象为树上的节点。

### 1.1 ScopeNode 定义

```typescript
// 概念定义
interface ScopeNode {
    id: number;                // 唯一ID，用于调试
    type: 'root' | 'factory' | 'internal';
    
    parent: ScopeNode | null;
    children: ScopeNode[];

    // 数据源引用
    // 如果是 'factory' 类型，指向 CtxExp 公式对象
    sourceFormula?: Formula;
    // 如果是 'internal' 类型，指向 AST 节点 (如 SumClauseASTNode)
    sourceASTNode?: any;
    // 如果是 'internal' 类型，同时记录该 AST 所属的 Formula 对象 (Host Formula)
    hostFormula?: Formula;

    // 本作用域定义的变量决议表
    // Key: 原始变量名 (如 "i")
    // Value: 决议后的信息
    variables: Map<string, ResolvedVariable>;
}

interface ResolvedVariable {
    originalName: string;      // 原始名 "i"
    realname: string;          // 最终真名 "i_{1}"
    isForced: boolean;         // 是否被用户强制指定
    // 如果是 factory 类型，持有 CtxVar 引用以便反向查找
    sourceCtxVar?: CtxVar;
}
```

### 1.2 节点类型

1.  **Root Node**: 全局作用域，对应整个图表的根。
2.  **Factory Node**: 对应由 `For`, `Sum`, `Func` 等工厂函数创建的 `CtxExp` 公式对象。它的作用域覆盖其 `body` 属性所指向的表达式（及其下游依赖）。
3.  **Internal Node**: 对应 DSL 内部解析出的上下文语句 AST 节点（如 `sum(n=1,10) ...` 中的 `SumClauseASTNode`）。它的作用域覆盖其 `content` 子节点。

## 2. 编译流程详解

### Phase 1: 构建 Scope Tree (Tree Construction)

我们需要遍历 Formula 依赖图和每个 Formula 的 AST，来构建这棵树。由于 Factory 和 Internal 作用域可能互相嵌套，遍历过程是交织的。

**输入**: Graph Roots (Formulas)
**输出**: 完整的 Scope Tree

**遍历算法**:

1.  **初始状态**: 创建 Root ScopeNode。
2.  **递归遍历 (Visit Formula)**:
    *   输入: 当前 `Formula`, 当前 `ScopeNode` (parent)。
    *   **分支 A**: 如果当前 Formula 是 `CtxExp` (Factory):
        *   创建一个新的 Child ScopeNode (Type: `factory`)，挂载到 parent 下。
        *   记录该节点定义的 `ctxVars`。
        *   **递归**: 使用新节点作为 parent，继续遍历 `CtxExp.body`。
    *   **分支 B**: 如果是普通 Formula (包括 CtxExp 本身):
        *   获取其缓存的 AST。
        *   调用 **Visit AST**，传入当前 ScopeNode。

3.  **递归遍历 (Visit AST)**:
    *   输入: 当前 AST Node, 当前 `ScopeNode` (parent)。
    *   **分支 A**: 如果是上下文语句节点 (如 `SumClauseASTNode`):
        *   创建一个新的 Child ScopeNode (Type: `internal`)，挂载到 parent 下。
        *   记录该节点定义的变量名。
        *   **递归**: 使用新节点作为 parent，继续遍历 `ASTNode.content`。
    *   **分支 B**: 如果是插值节点 (Interpolation):
        *   找到插值对应的 Value (Formula)。
        *   **递归**: 使用**当前** parent，调用 **Visit Formula** 遍历该 Value。
    *   **分支 C**: 其他节点 -> 递归遍历子节点。

### Phase 2: 变量真名决议 (Resolution Pass)

为了满足“内部强制命名优先于外部自动命名”的需求（即外部自动命名需避让内部强制命名），我们需要分两步进行。

#### Step 1: 收集强制命名 (Collect Forced Names)

自底向上（或在构建树时）计算每个 ScopeNode 的 `subtreeForcedNames` 集合。该集合包含该节点及其所有子孙节点中被用户强制指定的变量真名。

#### Step 2: 自顶向下分配 (Top-down Assignment)

在构建好的 Scope Tree 上，执行自顶向下的遍历，分配最终的 `realname`。

**输入**: Scope Tree, 全局已占用名称集合 (Global Used Names - 来自 Step 3 全局变量决议)

**算法**:

1.  **递归决议 (Resolve Scope)**:
    *   输入: 当前 ScopeNode, `ancestorNames` (祖先已占用的名字)。
    *   **准备冲突检测集合**:
        *   `forbiddenNames` = `ancestorNames` U `this.subtreeForcedNames`。
        *   这意味着：通过自动生成的名字，既不能与祖先冲突，也不能抢占子孙节点强制要求的名字。
    *   **当前作用域处理**:
        *   创建 `currentScopeNames` 集合，用于传递给子节点，初始包含 `ancestorNames` 和本节点确定的所有 names。
        *   遍历本作用域定义的每个变量 `var`：
            *   **Case A: 强制命名 (Forced)**:
                *   `realname` = 用户指定名。
                *   检查冲突：如果与 `ancestorNames` 冲突，说明用户配置与上层冲突（可能是故意的 Shadowing，也可能是错误）。我们**允许**这种行为（Shadowing），但记录警告。
                *   将 `realname` 加入 `currentScopeNames`。
            *   **Case B: 自动命名 (Automatic)**:
                *   候选名 = `var.originalName`。
                *   **冲突检查**: 检查候选名是否在 `forbiddenNames` 或本作用域已分配的名字中。
                *   如果冲突，递增数字后缀 (`i` -> `i_{2}` -> `i_{3}`) 直到无冲突。
                *   确定 `realname`。
                *   将 `realname` 加入 `currentScopeNames`。
                *   保存结果到 `ScopeNode.variables` 映射表。
    *   **递归子节点**:
        *   对每个 child，调用 **Resolve Scope**，传入 `currentScopeNames`。

## 3. 特殊情况处理

### 3.1 强制命名 (Forced Realname)

用户可能希望强制指定上下文变量的 Latex 名称（例如为了配合特定的可视化脚本）。

*   **Factory 模式 (`CtxVar`)**:
    *   **API**: `ctxVar.realname('my_name')`。
    *   **存储**: 将强制名存储在 `CtxVar` 的 sidecar state 中。
    *   **Scope Tree 构建**: 读取 state 中的配置，设置 `ResolvedVariable.isForced = true`。

*   **Internal DSL**:
    *   目前暂不支持在 DSL 字符串中直接指定强制真名。建议需要精细控制命名的用户使用 Factory 模式。

*   **处理策略**: 
    在 Phase 2 (Resolution) 中，强制命名的变量具有最高优先级。
    *   **Shadowing**: 如果它与上层变量冲突，它会“遮蔽”(shadow) 上层变量。
    *   **Reservation**: 它会作为“保留字”传递给父级 Scope，迫使父级（及更上层）在自动分配同名变量时进行避让（重命名为 `i_{1}` 等）。


### 3.2 隐式依赖的 Scope
某些 Formula 可能被多个下游引用。在 Scope Tree 中，这意味着同一个 Formula 可能会出现在树的不同分支上吗？
*   **不是的**。Scope Tree 是**树**，不是图。如果一个 Formula `A` 被 `B` 和 `C` 同时引用（插值），且 `B` 和 `C` 处于不同的上下文路径中，那么 `A` 实际上被“实例化”了两次。
*   **然而**，Destra 的默认模式假设 Formula 是不可变的 DAG 节点。
*   **关键约束**: 一个 `CtxExp` (Factory) 创建的上下文环境是**词法作用域 (Lexical Scoping)** 的。它被创建时，其父级环境是确定的吗？
    *   在 Destra 中，`CtxExp` 是独立的。它的 `body` 内部对外部变量的引用是通过 JS 闭包或显式插值完成的。
    *   如果是显式插值 (`expr`${a} + ${b}``)，这些插值对象 (`a`, `b`) 已经是在外部定义好的 Formula。它们内部**不应该**再依赖当前 `CtxExp` 提供的变量（因为它们是在外面定义的）。
    *   **结论**: 我们的 Scope Tree 其实非常简单。Factory Scope 只影响它**内部**定义的 DSL 字符串。它**不会**影响通过插值传入的、在外部定义的 Formula。
    *   **修正的构建算法 (Phase 1)**:
        *   当遍历 `CtxExp` 的 `body` 时，遇到插值 (Interpolation)，**不要**递归进入插值的 Formula 继续构建 Scope Tree。因为插值的 Formula 是在外部定义的，它不属于当前的上下文作用域（它看不见当前的 `i` 或 `n`）。
        *   **唯一的例外**: 如果插值的是 `CtxVar` 对象本身。这正是我们建立连接的地方。

### 3.3 修正后的 Scope Tree 遍历逻辑

正因为 Destra 的 DAG 特性，所有的“依赖”都是预先定义好的。

*   **Internal DSL**: `sum(n=1, 10) n^2`。`n` 的作用域仅限于 `n^2` 这段 AST。
*   **Factory**: `Sum(n => expr`${n}^2`)`。
    *   这里 `expr`${n}^2`` 是一个独立的 Formula。
    *   这个 Formula 内部有一个插值，插值的值是 `ctxVar n`。
    *   在 Latex 生成时，当遍历到 `expr`${n}^2`` 的插值 `n` 时，我们需要知道这个 `n` 对应哪个 Scope 的变量。
    *   **解决方案**: 不需要复杂的 Scope Tree 覆盖插值 Formula。
        *   每个 `CtxVar` 对象在创建时，虽然不知道它具体的 `realname`，但它是唯一的对象引用。
        *   我们在 **Resolution Pass** 中，主要是为了给每个 `CtxVar` 对象（以及 Internal DSL 中的 AST 变量节点）分配一个 `realname`。
        *   对于 Factory 创建的 `CtxVar`，它属于该 Factory Formula 的 Scope。
        *   对于 Internal DSL 创建的变量，它属于该 AST 节点的 Scope。

**简化的核心逻辑**:

Scope Tree 主要处理的是 **Internal DSL 的嵌套** 以及 **Factory 的嵌套**（如果 Factory 的 body 里面直接写了 DSL 字符串，而该字符串里又定义了上下文语句）。

*   对于通过 JS 变量传递引用 (`${n}`) 的情况，Latex 生成器只需查表：`Map<CtxVar, Realname>`。
*   对于 DSL 内部引用 (`sum(i=1,10) i^2`) 的情况，Latex 生成器需要查 Scope Stack。

因此，Scope Tree 构建器主要关注：
1.  **Factory Formula**: 它是一个 Scope，定义了 `CtxVar` 对象。
2.  **Internal AST**: 解析 AST，如果发现 Context Clause，创建 Scope，并记录其定义的变量名。

**Resolution Pass** 负责统一这两者：
1.  为 Factory 的 `CtxVar` 对象分配真名。
2.  为 Internal AST 的变量分配真名。
3.  确保嵌套时的名称避让。
