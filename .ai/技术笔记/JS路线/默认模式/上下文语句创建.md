# 上下文语句API

> 本文档阐述 Destra “默认模式”中上下文语句的 API 设计。

推荐的实现语法将采用函数回调的形式，将局部变量通过上下文对象 (`ctx`) 注入。

## 1. For (List Comprehension)

Desmos 的 `for` 列表推导式用于生成一系列值。Destra 通过 `For` 工厂函数来建模这一行为。

*   **语法**: ``For`i = someList`(callback)``
*   **迭代器定义**: 模板字符串中定义迭代变量及其范围，支持多个变量，例如 `i = [1...10], j = [1...5]`（`[1...10]` 和 `[1...5]` 都是 desmos 和 destra DSL 语法中支持的 range 式列表创建语法）。多变量的 For 语句会自动对多个变量进行笛卡尔积迭代，靠前的变量先迭代，靠后的变量后迭代。
*   **回调函数**: 接收一个包含所有迭代变量的上下文对象 (`ctx`)，返回要在每次迭代中生成的表达式。实际上起到了“具名参数列表”的作用。
*   **返回值**: 返回一个 `Expression` 对象，代表整个列表推导式。

```javascript
// 对应 Desmos: [i^2 + j^2 for i=[1...10], j=[1...5]]
const list = For`i=[1...10], j=[1...5]` (({i, j}) => {
    return expr`${i}^2 + ${j}^2`;
});
```

### 2.2 With (Scope / Let-binding)

Desmos 的 `with` 语句用于引入局部变量。Destra 通过 `With` 工厂函数来建模。

*   **语法**: ``With`a = someValue`(callback)``
*   **赋值定义**: 模板字符串中定义局部变量及其值，也支持同时定义多个变量，例如 `a = 10, b = x^2`。
*   **回调函数**: 接收一个包含所有局部变量的上下文对象 (`ctx`)，返回在该作用域内计算的表达式。
*   **返回值**: 返回一个 `Expression` 对象。

```javascript
// 对应 Desmos: a^2 + b^2 with a=sin(x), b=cos(x)
const val = With`a=sin(${x}), b=cos(${x})` (({a, b}) => {
    return expr`${a}^2 + ${b}^2`;
});
```

Desmos 的 `with` 语句非常初步，有禁止嵌套的限制（with 下可以有 for，甚至嵌套 for，但往下不能再追溯到第二个 with），Destra 的 `With` 工厂函数也遵循这一限制，在创建时会检查依赖链上是否存在第二个 with 并报错。

### 2.3 Sum (Summation) & Int (Integration)

求和 (`Sum`) 和积分 (`Int`) 在结构上与 `For` 非常相似，都是引入一个局部迭代变量。

*   **Sum 语法**: ``Sum`n = 1, 10`(callback)``
*   **Int 语法**: ``Int`x = 0, 1`(callback)``
*   **迭代器定义**: 定义迭代变量及其范围。对于 `Sum` 范围是用上下界指定的离散 range，对于 `Int` 范围是用上下界指定的连续区间。上/下界传入列表型变量时会对列表进行广播。
*   **返回值**: 返回一个 `Expression` 对象。

由于这两种语句属于**算子语句**，在数学语义上严格绑定单一变量，为了API的简洁性，标准形式规定它们的回调函数**直接接收该变量**作为参数，而不需要像 `For/With` 那样接收 Context 对象。

```javascript
// 对应 Desmos: sum_{n=1}^{10} n^2
const s = Sum`n = 1, 10` (n => expr`${n}^2`);

// 对应 Desmos: int_{0}^{1} x^2 dx
const i = Int`x = 0, 1` (x => expr`${x}^2`);
```

### 2.4 Func (Function Definition)

虽然 `expl` 标签函数已经可以创建简单的函数定义 (如 ``expl`f(x) = x^2` `` 或 ``expl`f(x, y) = x^2 + y^2` ``)，但对于函数体构造逻辑复杂、需要利用 JS 表达能力的场景，我们提供 `Func` 工厂。

*   **语法**: ``Func`params_list`(callback)``
*   **参数列表**: 逗号分隔的参数名字符串，如 `x, y`。
*   **回调函数**: 接收包含参数的上下文对象，返回函数体表达式。
*   **返回值**: 返回一个 `FuncExpl` 对象。

```javascript
// 对应 Desmos: f_1(x, y) = x^2 + y^2
const f1 = Func`x, y` (({x, y}) => expr`${x}^2 + ${y}^2`).id('f1');

// 对应 Desmos: f_2(x, y) = x^2 + y^2
const f2 = expl.Func`x, y` (({x, y}) => {
    // 在这里可以使用任意 JS 逻辑来构建表达式
    const dist = expr`${x}^2 + ${y}^2`;
    return dist;
}).id('f2');
```

### 注：作用域内使用 expl 的行为

是的，我们可以在作用域内使用 `expl` 标签函数来创建表达式，并且会非常巧妙地得到一个 desmos 所支持的结果：

当你在作用域内创建 `expl` 表达式后，按照 expl 的意图，会在作用域所在的公式**外边**生成一个对应的公式。这个公式因为依赖了作用域内的变量，所以在 desmos 里会报错（带有悬空依赖），但是只要在作用域内使用这个变量，它就可以在里面正常工作了，并且让整个作用域表达式正确完成构建/定义。

例如：

```javascript
// 对应 Desmos: 
// d_ist = a^2 + b^2 --> 带有悬空依赖，在该行上报错
// f_2(a, b) = d_ist --> 依然正确创建
const f2 = expl.Func`a, b` (({a, b}) => {
    // 在这里可以使用任意 JS 逻辑来构建表达式
    const dist = expl`${a}^2 + ${b}^2`.id('dist');
    return dist;
}).id('f2');
```

甚至还有这种情况：
```javascript
// 对应 Desmos: 
// d_ist = x^2 + y^2 
// f_2(x, y) = d_ist
const f2 = expl.Func`x, y` (({x, y}) => {
    // 在这里可以使用任意 JS 逻辑来构建表达式
    const dist = expl`${x}^2 + ${y}^2`.id('dist');
    return dist;
}).id('f2');
/**
 * 按理来说 d_ist 那一行公式应该带有悬空依赖，会在该行上报错；
 * 但是因为这里依赖的变量名是保留变量名 x 和 y，所以 desmos 能够接受这种“关于x, y的表达式片段”，并供后续构建隐式方程时使用，不会在该行报错
 * 但无论如何都不影响最终 f2 的成功创建和正常使用，以及 Destra 对这种行为的正确支持
 */
```

但是，虽然 Destra 也支持用户生成这种略带 hack 色彩的操作，但是这个策略并不是万能的，有时候会出错，所以我们需要再加上一些限制：

*    首先，显然我们不能在作用域内创建依赖于作用域变量的 FuncExpl 函数定义。因为我在 desmos 里试了没法成功x（外界带有悬空依赖的函数，无论在哪一种能够补全变量的作用域内都无法正常工作。我嘞个阻断性错误......）

*    其次。。。好吧想不到了暂时就这些了

### 2.5 语法糖：`expl.*` 系列

为了简化“创建上下文结构并立即将其赋值给变量”这一常见模式，我们为所有上下文工厂提供了 `expl` 命名空间下的语法糖版本。它们直接返回 `VarExpl`。

*   `expl.For` -> 返回 `VarExpl`
*   `expl.With` -> 返回 `VarExpl`
*   `expl.Sum` -> 返回 `VarExpl`
*   `expl.Int` -> 返回 `VarExpl`
*   `Func` 不需要语法糖，因为它返回的就是 `FuncExpl`（函数必为具名函数）。

```javascript
// 直接返回一个 VarExpl 对象
const myVar = expl.For`i=[1...10]`(({i}) => expr`${i}^2`).id('myVar');

const myVal = expl.With`a=10`(({a}) => expr`${a} * 2`).id('myVal');
```

### 2.6 参数传递方式 (Standard Form)

可以看到我们设计的这种传递 ctx 对象 / 解包传递的方式其实也有点问题，有时候会让用户感觉写起来有点繁琐——特别是当参数只有1个的时候，为什么 For 和 With 要强制我写一个解包的花括号？

但是更好的设计其实是无法实现的。或者至少说，标准形式下无法实现，例如根据传入的 lambda 代码形式在类型系统里自动推断出应该传递 ctx 对象还是直接接收变量：

```javascript
// 示例：根据传入的 lambda 代码形式在类型系统里自动推断出应该传递 ctx 对象还是直接接收变量——但实际上不可行
const f1 = For`i=[1...10]`(({i}) => expr`${i}^2`);
const f2 = For`i=[1...10]`(i => expr`${i}^2`);
```

所以为了保证类型安全和代码的可预测性，标准形式下依然采用确定不变的参数传递方式。

*   **作用域语句 (`For`, `With`, `Func`)**: 总是接收一个 **Context 对象**。
    *   设计意图：这些语句定义了一个包含多个潜在变量的命名空间。即使只有一个变量，也必须通过解构获取。
    *   写法：``For`...`(({i}) => ...) `` 或 ``With`...`(({a, b}) => ...) ``

*   **算子语句 (`Sum`, `Int`)**: 总是接收**单个变量 (VarExpl)**。
    *   设计意图：这些语句在数学上严格绑定单一变量，所以让用户记住即使在标准形式下也必须直接接收这个变量作为参数，应该也是可以接受的。
    *   写法：``Sum`...`(n => ...) `` 或 ``Int`...`(x => ...) ``

### 2.6.1 语法糖 (Creative Form): 参数免解包

在创作形式 (Creative Form) 或预处理层中，我们可以引入“智能参数解包”的语法糖，允许用户在所有场景下省略解包步骤直接接收变量。但请注意，这超出了标准形式 (Standard Form) 下 TypeScript 类型推断的能力极限，必须通过一层代码转换才能实现。

```javascript
// 概念示例 (仅在 Creative Form 下可用)
For`i=[1..10]`(i => expr`${i}^2`); // 自动转换为 For`...`(({i}) => ...)
With`a=10`(a => expr`${a} * 2`); // 自动转换为 With`...`(({a}) => ...)
```

### 2.7 纯字面量语法

对于不需要用 JS 作用域组织逻辑的简单场景，用户可以直接使用 `expr` 或 `expl` 配合 DSL 语法，而无需使用上述工厂函数。

*   **工厂函数 (For/Sum/...)**: 专用于 **Callback 模式**，利用 JS 闭包特性构建复杂逻辑。
*   **DSL 语法**: 直接写在字符串里。

```javascript
// 简单场景：直接写字符串
const s = expr`sum(n=1, 10) n^2`;

// 复杂场景：使用工厂
const s2 = Sum`n=[1...10]` (n => {
   const term = complexLogic(n);
   return term;
});
```

#### 语法完整列举 

*   **sum**: ``expr`sum(n = 1, 10) n^2` ``
*   **int**: ``expr`int(0, 1) x^2 dx` ``
*   **for**: ``expr`i^2 for i=[1...10]` ``，``expr`[i^2 for i=[1...10]]` ``
*   **with**: ``expr`2 + a with a = 2` ``
*   **func**: ``expl`f(x) = x^2` ``，``expl`(x, y) => x^2 + y^2` ``

#### 作用范围

**sum, int**: 遵循数学的惯用规则，优先级仅高于加减号，低于一切算术运算——除非使用括号手动指定表达式结构。

```javascript
const s = expr`sum(n=1, 10) n^2 + 1`; // sum 优先级高于加减号，所以在 desmos 里计算结果为 (sum(n=1, 10) n^2) + 1 = 385 + 1 = 386
const int = expr`int(0, 1) x^2 dx + 1`; // 在 desmos 里计算结果为 int(0, 1) x^2 dx + 1 = 1/3 + 1 = 4/3

// const int = expr`int(0, 1) x^2 + 1 dx`; 
// int 优先级高于加减号，所以在 desmos 里会认为你写的是 (int(0, 1) x^2) + 1 dx，写了一个没有 dx 被积变量的积分表达式，以及外面 "dx" 解析为 "d * x" 找不到变量 "d" 的定义，从而报错。
```

另外在 int 语句中，dx 的位置会影响表达式解析结果：
```javascript
const int2 = expr`int(0, 1) dx x^2 + 1`; 
```

在 desmos 里除了运算符优先级这个条件之外，积分身体表达式范围的划定也受另一个因素的影响：表达式范围不超过 dx 的位置。

也就是说，这个表达式在 desmos 里会被解析为 (int(0, 1) dx) (x^2 + 1)，而不是 int(0, 1) (dx x^2 + 1)，进而解析成显式方程。

但是在数学物理里把 dx 放最前也是合理的写法之一，实际上既然已经有了一个根据运算符优先级+括号来划定身体表达式范围的机制，那么 desmos 按理本来就不应该再加上这个根据 dx 位置限制范围的限制，这样只会让用户更容易写错。

所以在 destra 里我们**支持这种把 dx 置于乘法链任意位置的写法**，并会在**解析时自动把 dx 移至最后**，将这种写法转换为 desmos 认为正确的写法。这个例子会被解析为 (int(0, 1) x^2 dx) + 1。

**for, with**: 由于语法特性，它们的作用域变量定义位于身体 (body) 表达式的右侧/后面。

for 的优先级也仅高于加减号，同时for 表达式外围可以使用中括号包围（desmos 支持），其实也等效于用圆括号包围，以作为一种明确界定身体表达式范围的方法，这时候它可以跨越优先级规则界定身体表达式的范围。

（其实历史上 desmos 是先支持，甚至强制要求使用中括号包围的写法的，后来才支持圆括号包围、或者在一些条件下可以无括号包围的写法的）

```javascript
const L1 = expr`2 * i^2 for i=[1...10]`; // 在 desmos 里计算结果为 [2 * i^2 for i=[1...10]]
const L2 = expr`2 * [i^2 for i=[1...10]]`; // 在 desmos 里计算结果为 2 * [i^2 for i=[1...10]]
const L3 = expr`2 * (i^2 for i=[1...10])`; // 在 desmos 里计算结果为 2 * [i^2 for i=[1...10]]
const L4 = expr`2 + i^2 for i=[1...10]`; // 在 desmos 里计算结果为 2 + [i^2 for i=[1...10]]
const L5 = expr`2 + [i^2 for i=[1...10]]`; // 在 desmos 里计算结果为 2 + [i^2 for i=[1...10]]
// with 的优先级低于加减号（应该也就是低于一切算术运算了），高于函数定义和变量定义
const W1 = expr`2 + a with a = 2`; // 在 desmos 里计算结果为 2 + 2 = 4
const W2 = expr`a^2 with a = 2 + 2`; // 在 desmos 里计算结果为 (2 + 2) ^ 2 = 16
```

另外：
```javascript
// const W3 = expl`a = 10 with a = 2`; 
```
不要在变量定义里使用同名 with。desmos 的报错很令人费解，是什么“系统只支持x和y的隐函数方程。” ...??? 总之本来从原则上就不应该重名的。

Destra 在上下文语句的工厂函数语法里会自动通过 id 映射过程，让作用域变量之间、以及作用域变量与 Expl 之间避免重名。