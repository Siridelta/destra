# 语法实现方案

> 本文档描述基于 Chevrotain 的 Destra 表达式解析器（Parser）的实现技术方案。

## 1. 总体架构

解析流程采用 **"Pre-process -> Lex -> Post-process -> Parse (CST) -> Visit (AST) -> Analyze"** 的流水线设计。

1.  **预处理 (Pre-process)**: 处理 JS 模板字符串插值，将 `${obj}` 替换为短占位符（如 `"$0"`）。
2.  **词法分析 (Lexing)**: 使用 Chevrotain Lexer 将字符串转换为 Token 向量。
3.  **Token 后处理 (Post-process)**: 遍历 Token 向量，在特定场景下（如括号后、数值与变量间）自动插入 "Implicit Multiply" (隐式乘法) Token。
4.  **语法分析 (Parsing)**: 使用 Chevrotain CstParser 构建 CST。
5.  **AST 构建 (Visiting)**: 将 CST 转换为 AST。
6.  **语义分析 (Analysis)**: 类型推断与元数据提取。

## 2. 词法分析 (Lexer)

### 2.1 占位符 (Placeholders)

JS 模板字符串插值（`${...}`）在进入 Lexer 前，会被替换为索引占位符。DSL 语法和命名系统的考虑里基本上不会涉及美元符号（`$`），因此推荐占位符的格式为 `"$<INDEX>$"`。尾部带一个美元符号可以避免与后续出现的数字混淆。

*   **格式**: `"$<INDEX>$"` (例如 `"$0$"`, `"$1$"`)
*   **Token**: `Placeholder`
*   **Pattern**: `/\$\d+\$/`
*   **AST**: 解析为 `PlaceholderNode`，包含 index。

### 2.2 词法规则优先级与数值处理

Chevrotain Lexer 对 Token 定义顺序敏感。我们需要严格控制顺序以正确处理 `2x` 等紧凑写法。

**推荐顺序**:
1.  **Whitespace**: Skipped.
2.  **Keywords**: `for`, `with`, `sum`, `prod`, `int`, `in` 等以字母开头的关键字。注意 `d/d变量名` 微分算子也在这一级，优先解析。
3.  **NumberLiteral**:
    *   Desmos 支持十进制数值及科学计数法（如 `1.2e-5`）。
    *   **关键点**: 为避免 `2e` (2 * e) 被错误识别为未完成的科学计数法数值，`NumberLiteral` 的正则中 `e/E` 后**必须**紧跟数字（或 `+`/`-` 后跟数字）。
    *   **Pattern**: `/\d+(\.\d+)?([eE][+-]?\d+)?|\.\d+([eE][+-]?\d+)?/`
    *   **安全验证**: 对于输入 `2x`，由于 Identifier 不能以数字开头，Lexer 会先匹配 `2` (Number)，剩余 `x`；然后匹配 `x` (Identifier)。对于输入 `2e`，由于 `e` 后无数字，正则不匹配科学计数法部分，Lexer 匹配 `2`，剩余 `e`；然后匹配 `e` (Identifier/Constant)。
4.  **Operator & Punctuation**: `+`, `-`, `*`, `->`, `...` (RangeDots 需在 Dot 前), `.`, `(`, `)`, `,` 等。
5.  **Placeholder**: `/\$\d+\$/` 插值占位符
6.  **Identifier**: `/[a-zA-Z_][a-zA-Z0-9_]*/` 最后识别标识符。

### 2.3 隐式乘法 (Implicit Multiplication)

严格遵循 "Desmos 语法 & Expr DSL 语法参考" 2.10 节。我们采用 **Token 注入** 与 **Parser 规则** 相结合的策略。

**Token 注入场景 (Post-process)**:

在 Lexing 之后、Parsing 之前，遍历 Token 向量，检查相邻 Token 对 `(Prev, Next)`，满足条件时在中间插入 `Multiply` Token：

1.  **括号/列表后**:
    *   `Prev` 是 `ParenthesisClose` `)` 或 `BracketClose` `]`.
    *   `Next` 是能开始一个表达式的 Token: `Identifier`, `NumberLiteral`, `Placeholder`, `ParenthesisOpen` `(`, `BracketOpen` `[`.
    *   例: `(a)(b)` -> `(a)*(b)`, `[1,2](3)` -> `[1,2]*(3)`.

2.  **大括号前后 (分段表达式)**:
    *   `Next` 是 `BraceOpen` `{`. 例: `2{x>0}` -> `2*{x>0}`.
    *   `Prev` 是 `BraceClose` `}`. 例: `{x>0}2` -> `{x>0}*2`.

3.  **数值/标识符/常量/占位符/内置函数**:
    *   `Prev` 是 `NumberLiteral`.
    *   `Next` 是 `Identifier`, `Placeholder`, `ParenthesisOpen` `(`, `BracketOpen` `[`, `Function` (如 `sin`, `sqrt` 等内置函数名).
    *   **安全性**: 基于 Lexer 的正确分词，`2x` 已被拆分为 `Number(2)` 和 `Identifier(x)`。此处逻辑将其转换为 `2 * x`。这涵盖了 `2pi`, `2sin(x)`, `2${var}` 等场景。
    *   *注*: `2` 和 `x` 之间是否有空格不影响 Token 序列（空格已被 Skip），因此 `2 x` 和 `2x` 均会被处理。

4.  d/dx, sum, prod, int 前

**Parser 规则场景**:

4.  **积分中的 dx**: 在 `Integral` 规则中直接允许 `Expr` 与 `Differential` (d+Var) 相邻，不强制要求乘号 Token。
    *   例: `int(0,1) x dx`.

## 2.4 d/dx & dx 语法

d/dVar 和 dVar (用于积分上下文语句) 都是需要优先于标识符处理的代码，然而它们后面是可变的变量名标识符，所以有点难处理。

有两种解决办法：

1. Lexer 把变量名识别进去，在 token 后处理阶段再拆开。
2. Lexer 不把变量名识别进去，正则表达式里用 lookahead 来处理，前瞻一个符合 DSL 内部变量格式的字符串，如果不是则不匹配。

## 3. 语法分析 (Parser)

采用 Chevrotain 的 `RULE` 定义各级优先级。参考 "Desmos 语法 & Expr DSL 语法参考" 中的优先级列表（共 14+ 层级）。

### 3.1 优先级层级 (从低到高)

在普通顶层语境里：

1.  **In**: 处理 `in` (Slider定义) (不允许结合性)
2.  **Top**: `=` (赋值/方程), `< > <= >=` (不等式), `~` (回归), `=>` (箭头式函数定义)。(不允许结合性) 
3.  **Action Batch**: 处理 `,` (Action并联)。（结合性随意）
5.  **Action**: `->` (Action). (不允许结合性)(Sematics需要检查左值是否为变量)
6.  **AddSub**: `+`, `-` (左结合).
7.  **Context**: 
    *   **Context1**: `sum`, `prod`, `int`, `d/dx`.
    *   **Context2**: `for`, `with`.
    *   注意：`sum(n=1, 10) n + 1` 应解析为 `(sum(n=1, 10) n) + 1`。因此 Context 规则的 Body 部分应解析更高优先级的表达式 (MultDiv 或更高)。
8.  **MultDiv**: `*`, `/`, `%` (包含隐式乘法) (左结合)
9.  **OmittedCall**: `sin x`, `log x`. (不允许结合性)
    *   仅允许特定函数名 (内置三角函数、对数函数等)。
    *   可能会把并未省略括号的情况给解析成省略括号的情况，需要在 Semantics 阶段进行修正。
10. **Prefix**: `-x`, `+x`. (不允许结合性)
11. **Rootof**: `rootof` (右结合)
12. **Power**: `^` (右结合)
13. **PostFix**: `!`, `.member`, `.extCall .extCall(x)`, `L[i]`(期望 Bracket), 
14. **Atomic & FuncCall**: NumberLiteral, Identifier, Placeholder, Parenthesis, Bracket, Brace.
    *   小中大括号有多种用法，在语法上统一解析为 Parenthesis/Bracket/Brace，在 Semantics 阶段区分。括号内下降到 Pair 层级。
    *   函数调用（普通形式）：`f(x)`。Destra 里函数非一等公民所以只有插值量和内置函数可以被调用，因此将其视为整体 atomic 表达式处理。

在大括号（Piecewise）语境里：`,`, `:` 优先级 < 比较运算符 < actions < addsub。不允许 for 和 with 语句（除非使用小括号括起来）。没有 actionBatch，因为 `,` 被优先赋予"条件分支分隔符"的语义了。
1.  **piecewise 初始 level**:
    因为条件分支的语法在分层之外还施加了一些额外限制，LL(k)解析器无法简单用普通分层思路来处理，我们在一个层级里将 `,`, `:`, 和比较运算符视为同级分隔符，并使用一些类似状态转移规则的方法把这几层内容在同一层级处理。
    1.  **Piecewise_Start**: 初始指令，转到2.
    2.  **Piecewise_Start2**: 也是初始指令，但是不可空。actionLevel，可选转到3.
    3.  **Piecewise_FromComp**: 处理比较运算符往后的内容。比较运算符包括 `= ==`(相等比较), `< > <= >=` (不等比较)，左结合，为了支持比较运算符链接语法。比较运算符，actionLevel，可选转到3/4/5.
    4.  **Piecewise_FromColon**: 处理 `:` 往后的内容。`:`，actionLevel，可选转到5.
    5.  **Piecewise_FromComma**: 处理 `,` 往后的内容。`,`，转到2.
2.  **Piecewise_Action**: `->` (动作)。(不允许结合性)(Sematics需要检查左值是否为变量)
3.  **Piecewise_AddSub**: 处理 `+`, `-` (左结合)。
4.  **Piecewise_Context**: 转到 OR(Context1, MultDiv). 

在中括号（列表创建/列表索引）语境里：

1.  **List_Comma**: 处理 `,` (列表元素分隔符)。（结合性随意）
2.  **List_Rel**: `=` (相等比较), `==`, `< > <= >=` (不等比较) (左结合，为了支持比较运算符链接语法)
3.  转到 **AddSub** 规则继续解析。

在小括号（函数调用）语境里：

1.  **FuncCall_Comma**: 处理 `,` (函数调用参数分隔符)。（结合性随意）
2.  转到 **AddSub** 规则继续解析。

在其他小括号语境里：允许 `,` 出现在括号内，用于定义点类型。

1.  **Comma**: 处理 `,` (点坐标分隔符)。（结合性随意）
2.  转到 **AddSub** 规则继续解析。

### 3.2 关键规则实现细节

*   **结合性**
    *   **左结合**：LL(k) 解析器无法单独处理左结合性（导致左递归），Parser 规则先解析为右结合式的 CST，在 Sematics 阶段再转换为左结合式的 AST。
    *   **右结合**：直接解析为右结合式的 CST。
    *   **不允许结合性**其子节点直接解析下一优先级的表达式，规则类似 `Exp_of_Layer(n+1) Op_of_Layer(n) Exp_of_Layer(n+1)`这种形式，而非 `Exp_of_Layer(n+1) Op_of_Layer(n) Exp_of_Layer(n)`这种形式。

*   **Context Statements (`sum`, `int`...)**:
    *   语法: `SumToken` `OpenParen` `Var` `=` `Expr` `Comma` `Expr` `CloseParen` `BodyExpr`.
    *   `BodyExpr` 需调用 `MultDivExpression` (即比 AddSub 高一级的规则)。
*   **Integral (`int`)**:
    *   Destra 允许 `dx` 前置或后置。
    *   Parser 规则应灵活匹配: `IntToken` `OpenParen` ... `CloseParen` `( (Differential Expr) | (Expr Differential) )`.
    *   需要定义 `Differential` 规则匹配 `d` + `Var` (需确保 `d` 是 Identifier 且 Var 是 Identifier，且中间无其他 Token? 或者将 `d` 视为特殊 keyword? 建议将 `d` 视为普通 Identifier，但在 Integral 规则中特殊检查).
*   **Definition vs Equation**:
    *   统一解析为 `BinaryExpression` (op=`=` 或 `~`).
    *   在 Visitor 阶段或 Analysis 阶段：
        *   如果 LHS 是 `Identifier` 或 `Call(Identifier, args)` 且 op 是 `=` -> **VariableDefinition** / **FunctionDefinition**.
        *   如果 op 是 `~` -> **Regression**.
        *   否则 -> **Equation** (Implicit/Explicit).

## 4. AST 结构定义

在 `parse-ast/ast-types.ts` 中定义。

```typescript
export type NodeType = 
    | "Binary" | "Unary" | "Call" | "Member" | "List" | "Piecewise" 
    | "Literal" | "Identifier" | "Placeholder" 
    | "Range" | "ListComp" | "SumProd" | "Integral" | "Derivative"
    | "Assignment" | "Regression" | "Action";

export interface BaseNode {
    type: NodeType;
    // ... pos info
}

export interface BinaryNode extends BaseNode {
    type: "Binary";
    op: string; // "+", "-", "*", "/", "^", "=", "<", ">", ...
    left: BaseNode;
    right: BaseNode;
}

export interface CallNode extends BaseNode {
    type: "Call";
    callee: string; // Identifier name
    args: BaseNode[];
}

export interface AssignmentNode extends BaseNode {
    type: "Assignment";
    lhs: IdentifierNode | CallNode; // a = ... or f(x) = ...
    rhs: BaseNode;
}
// ...
```

## 5. 类型推断 (Analysis)

在 `analyzeType.ts` 中实现。接收 AST，输出 `FormulaType` 及相关元数据。

1.  **Check Root Node**:
    *   `AssignmentNode`: 
        *   LHS is `Identifier` -> `Type: Definition`, `name: LHS.name`.
        *   LHS is `Call` -> `Type: Function`, `name: LHS.callee`, `params: LHS.args`.
    *   `RegressionNode`: -> `Type: Regression`. (提取 RHS 中的未知变量作为 Parameters).
    *   `BinaryNode` (Comparison/=): -> `Type: Equation`.
    *   Other: -> `Type: Expression`.

2.  **显式方程特判**:
    *   如果 Root 是 `Expression` 类型 (如 `x^2`)，且仅依赖保留变量 (x, y)，则应视为 **Explicit Equation** (自动补全 `y = ...`)。
    *   **语法糖**: 在 Analysis 阶段将 AST 包裹一层 `AssignmentNode(lhs=y, rhs=original)`，并修改类型为 `Equation` (Explicit)。

3.  **科学计数法语法糖**:
    *   Lexer 识别出的科学计数法 `NumberLiteral` (如 `1.2e5`)，需在 AST 构建 (Visiting) 阶段或 Analysis 阶段转换为算术表达式结构。
    *   转换目标: `BinaryExpression(op="*", left=Literal(1.2), right=BinaryExpression(op="^", left=Literal(10), right=Literal(5)))`。
    *   这是因为 Desmos 内部并没有科学计数法这一原子类型，而是将其视为表达式。

4.  **Regression 参数提取**:
    *   遍历 RHS AST。
    *   收集所有 `Identifier`。
    *   排除: 保留变量 (x, y...), 已知上下文变量, 内置函数。
    *   剩余的即为 Regression Parameters (如 `k`, `b`)。需要为它们自动创建 Expl 对象。
