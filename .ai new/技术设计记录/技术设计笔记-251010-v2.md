# Bernard.js 默认模式设计方案（251010-251012）

## 251010 与 Monica 的讨论回顾

> 本节内容基于 `../imported/20251010 monica聊天记录.md` 的讨论进行总结。

在10月10日，开发者与AI助手Monica进行了一次深入的讨论，旨在为 Bernard.js 的默认模式设计一套健壮的 **命名与封装机制**。以下是该次讨论中方案演进的详细回顾。

### 背景：核心矛盾

设计的起点源于一个核心矛盾：
> JavaScript 变量名的丰富性、灵活性与 Desmos 变量名的严格限制、可读性差之间的冲突。

在此之上，还有一个关键的工程化约束：
> 如何让用户能够像使用 npm 包一样，模块化地分发、组合和复用 Bernard 代码，同时避免命名冲突并提供良好的开发者体验（DevEx）。

### 初步构想

这是设计的最早版本，来源于开发者的初始笔记，是开发者的初始灵感组合，包含了几个核心要素：

1.  **三层命名系统**：在“JS 变量名”和“Desmos 变量名”之间，引入一个稳定且由开发者控制的中间层——**“Bernard 标识 (ID)”**。
2.  **命名 API**：提供 `.name()` 用于设置 Bernard ID，`.realname()` 用于强制指定最终的 Desmos 变量名，以及 `package()` 函数用于批量为一组表达式添加命名空间。
3.  **严格的依赖与上下文**：禁止悬空依赖，并简化所有上下文语句（如 `with`, `for`），使其行为统一为“弱绑定”，即只填补缺失的定义，不覆盖已有定义。

这个初步方案虽然指明了方向，但在开发者体验和模块化分发的细节上留下了许多问题，整个方案本身也需要论证以寻找最优化方案。

### 第1版方案：确定 Bernard ID / 三层名称层设计，以及 DevEx 初步设计方案

在对初步构想进行审视后，讨论进入了更深层次。此版本旨在解决第1版方案中悬而未决的问题，并为关键决策提供了坚实的论证。

#### 论证：Bernard ID 中间层的必要性

讨论首先明确了一个基础性问题：在 JS 变量名和 Desmos 变量名之间设立一个“Bernard ID”中间层是否是必须的？

结论是：**非常有必要**。

其核心论据是 **JS 变量名的不稳定性**。一个库中导出的表达式对象，在被用户导入时，其 JS 变量名可以被任意重命名，也可以被赋给多个不同的变量。

```javascript
// 'some-library' 中原始的变量名为 'formula'
import { formula as myCoolFormula } from 'some-library';
const anotherVar = myCoolFormula;
```

如果系统依赖 JS 变量名来生成最终的 Desmos 变量名，那么这个过程将是混乱且不可靠的。因此，必须有一个独立于 JS 变量名的、稳定的标识符来唯一地标记每一个“表达式声明”。Bernard ID 正是扮演了这个**“主键 (Primary Key)”**的角色，它将一个公式的**内在身份**和它在代码中临时的**外部称呼**进行了解耦。

#### 配套方案：尽力可读的命名策略

在肯定了 Bernard ID 的基础上，讨论确认了最终生成 Desmos 名称时的策略——**默认可读，并把选择权交给用户**。

1.  **默认可读**：系统应尽最大努力，根据 Bernard ID 生成人类可读的 Desmos 名称（例如，将 `myLib.vector` 转换为 `m_yLib_vector`）。这对于“IDE-浏览器”对照调试至关重要。
2.  **冲突自动解决**：当出现命名冲突时，系统必须自动解决，例如通过添加数字后缀（`v_1`, `v_2`）。
3.  **提供压缩选项**：允许用户在最终发布时选择“压缩/混淆”模式，将所有变量名替换为 `a_1, a_2, ...` 等最短形式，以优化性能或URL长度。

#### 配套方案：初步的协作与 API 设计

为解决跨库协作的命名冲突问题，此版本提出了一套基于“命名空间”的 API 设计。

*   **隐式与显式 ID**：在日常使用中，``const c = expl`...` `` 会借助预处理器的能力**隐式地**将 `"c"` 作为 Bernard ID，即通过 JS 变量名（层）自动确定 Bernard ID（层）。对于库作者，则提供了 `.id("vector.magnitude")` API 来**显式地**指定一个更规范的 ID。
*   **`namespace` 函数**：为了从根源上避免来自不同库的 ID 冲突，设计了一个 `namespace` 函数。库的作者在发布时，可以将所有导出项用此函数包裹，从而为它们统一添加一个唯一的ID前缀。

```javascript
// my-awesome-lib/index.js
import { namespace } from 'bernard';
import { magnitude } from './vector'; // ID: "vector.magnitude"
import { dotProduct } from './algebra'; // ID: "algebra.dotProduct"

// 将库里的所有公式封装在一个 "my-awesome-lib" 命名空间下导出
export default namespace("my-awesome-lib", [
    magnitude,
    dotProduct
]);
```

对于库的使用者，其代码示例如下：

```javascript
// other-project/main.js
import awesomeLib from 'my-awesome-lib';
import { expl } from 'bernard';

// 这个公式的 Bernard ID 是 "local.myVec"
const myVec = expl`...`.id("local.myVec");

// awesomeLib 已经被命名空间包裹
// 最终 Bernard 会知道它内部的 magnitude 的完整 ID 是 "my-awesome-lib:vector.magnitude"
const len = awesomeLib.magnitude(myVec);
```

当最终编译时，`magnitude` 的全局唯一 ID 将变为 `my-awesome-lib:vector.magnitude`，从而避免了与其他库的冲突。这样，在最终编译时，Bernard 会看到一个全局唯一的 ID 树，从而确保**绝对不会有冲突**。

*   `local.myVec`
*   `my-awesome-lib:vector.magnitude`
*   `my-awesome-lib:algebra.dotProduct`

> 注：在整个聊天记录/讨论过程中，关于 “库作者” 和 “库使用者” 的概念一直没有清晰或者确定的称呼，有时称为 “上/下游”，有时称为 “供给方/需求方”，“库编写者/库使用者”，“创作者/使用者”；为了标准化术语，今后统一使用 “库作者” (Library Author) 和 “库使用者” (Library User)。

#### 本版方案总结

综上所述，第1版方案的大致设计内容如下：

1.  **三层命名系统**:
    *   **JS 变量名**: 临时的、上下文相关的别名。
    *   **Bernard ID (主键)**: `string` 类型，全局唯一，由库作者定义，是公式的**真正身份**。
    *   **Desmos 变量名**: 最终产物，由 Bernard 根据 Bernard ID 自动生成，保证可读性并自动解决冲突。

2.  **核心 API**:
    *   ``expr`...` ``: 创建一个可内联的公式片段。
    *   ``expl`...` ``: 创建一个具名声明。
        *   **隐式 ID**: ``const c = expl`...` `` 自动使用 `"c"` 作为 ID。
        *   **显式 ID**: `.id("my-unique-id")` 用于库开发和精确控制。
    *   `namespace("my-lib", [formula1, ...])`: 用于库作者，给一组公式批量加上命名空间前缀，解决跨库冲突。

3.  **编译/导出过程**:
    1.  收集项目中所有的 `expl` 对象，形成一个有向无环图 (DAG)。
    2.  读取每个对象的 Bernard ID。
    3.  根据 Bernard ID 生成一个建议的 Desmos 变量名。
    4.  检查所有建议的变量名是否有冲突，并对冲突项进行自动重命名。
    5.  生成最终的 Desmos 公式列表。

这个新设计保留了初步构想中的好想法，但通过引入“隐式命名”和更清晰的“命名空间”概念，使得 API 在日常使用中更简洁，同时为库作者提供了强大的工具来避免冲突。

### 第2版方案：转向 JS 标准导入导出方式

我们发现尽管第1版的方案在逻辑上是自洽的，但它隐藏了一个关于开发者体验的**致命缺陷**：`namespace` 函数将库的所有导出项打包成了一个单一对象，这会**彻底破坏 IDE 的静态分析能力**。库使用者将无法获得库中单个函数的 JSDoc、类型提示和代码跳转。`namespace` 函数对开发者体验的破坏是不可接受的，因此第2版方案的核心目标就是**在不牺牲IDE静态分析能力的前提下，解决模块化和命名冲突问题**。

这次迭代放弃 `namespace` 函数，使用标准的 `import/export` 模块化方案。

#### DevEx 优先的新工作流

这个新方案的思路是，与其创造一个新的封装机制，不如回归到所有 JavaScript 开发者都已熟悉的标准流程上。

*   **对于库作者**：
    库作者不再需要任何特殊的 `package` 或 `namespace` 函数。他们只需要使用标准的 `export` 关键字导出每一个需要暴露的表达式、函数或常量。为了解决命名冲突，库作者有责任**手动为每一个导出的 `expl` 对象通过 `.id()` 方法提供一个全局唯一的ID**。

    ```javascript
    // file: my-awesome-lib/vector.js
    import { expl } from 'bernard';

    /**
     * Calculates the magnitude of a 2D vector.
     */
    export const magnitude = expl`sqrt(vec.x^2 + vec.y^2)`
        // 关键：作者手动声明一个遵循约定的、全局唯一的ID
        .id("my-awesome-lib:vector.magnitude");
    ```

*   **对于库使用者**：
    库使用者也采用标准的 `import` 语法导入他们需要的模块。

    ```javascript
    // file: my-project/main.js
    import { magnitude } from 'my-awesome-lib/vector';

    // 当鼠标悬浮在 `magnitude` 上时, IDE会完美地弹出 JSDoc 和类型信息。
    const len = magnitude(someVector);
    ```

#### 新方案的优劣势

*   **优势**:
    1.  **完美的IDE支持**：JSDoc、类型提示、代码跳转等功能全部正常工作。
    2.  **零学习成本**：开发者使用他们已经熟悉的 `import/export` 语法。
    3.  **混合导出**：可以轻松地在同一个文件里导出 Bernard 公式、普通 JS 函数等。
*   **劣势/权衡**:
    *   **繁琐且易错**：将保证ID唯一性的责任完全交给了库作者。作者必须为**每一个**导出的表达式手动编写一段长长的、带命名空间的ID字符串。这增加了工作量，也引入了手滑写错的风险，在一定程度上也损害了开发者体验。

#### 补充说明：强制指定真名功能的必要性

在这次讨论中，开发者补充说明了 `.realname()` API 的必要性。它并非一个可有可无的功能，而是解锁特定高级功能的“钥匙”。

一个典型的场景是社区探索出的“键盘输入 hack”技术。该技术依赖于能精确控制在 Desmos 中生成的变量名（如 `w`, `a`, `s`, `d`），以便通过监控用户在特定位置的键盘输入引发 Desmos 计算系统响应、最终引发的特定变量值的变化，来侦测并响应用户的键盘输入。没有 `.realname()` 的能力，这类高级应用将无法在 Bernard 框架内实现。

因此，方案明确了 `.id()` 和 `.realname()` 的分工：
*   `.id()`: 负责设定 Bernard ID，Bernard ID 层作为用户工程体系内部的、全局唯一的**身份**，用于解决模块化冲突。
*   `.realname()`: 负责 **覆盖** Bernard 的自动命名生成器，干涉从 Bernard ID 生成到 Desmos 变量名（“真名”）的过程，优先指定特定表达式的 Desmos 真名，用于实现特殊功能。

#### 命名空间标识符的探讨

针对 Bernard ID 的格式，Monica 补充了解释为什么推荐使用冒号（`:`）作为顶层命名空间的分隔符（如 `my-awesome-lib:vector.magnitude`）。

其主要考虑是**鲁棒性**。由于 npm 包名本身可能包含点（`.`），如果 ID 全部使用点来分隔（如 `my.lib.vector.magnitude`），程序将无法 100% 明确 `my.lib` 是库名，还是库内部的路径。使用一个在 JS 标识符中不合法的字符（如冒号）可以创建一个**绝对无歧义的层级**，清晰地将“库”与“库内路径”区分开。尽管这只是一个约定，但它能提升系统的健壮性。

#### 本版方案总结

第2版方案的核心API和模块化策略如下：

1.  **三层命名系统 (不变)**: JS 变量名 -> Bernard ID -> Desmos 变量名。
2.  **核心 API (优化)**:
    *   ``expl`...` ``, ``expr`...` ``
    *   `.id("unique-id")`: **(强制约定)** 库作者必须为每个导出的 `expl` 设置全局唯一的 Bernard ID。
    *   `.realname("desmos_name")`: **(可选)** 高级 API，用于强制指定最终的 Desmos 变量名。
3.  **模块化与分发 (DevEx 优先)**:
    *   **废弃 `package` 和 `namespace` 函数。**
    *   库作者使用标准的 `export` 关键字导出模块。
    *   库使用者使用标准的 `import` 关键字导入模块。

这个方案成功解决了第1版方案的致命缺陷，将开发者体验（特别是IDE集成）拉回了最高优先级。但它引入了新的问题——手动维护ID的繁琐性，而这正是第3版方案试图解决的核心矛盾。

### 第3版方案：构建时自动化

#### 新的挑战：手动维护 ID 的繁琐性

第2版方案虽然保证了与标准JS生态的兼容性，却把手动维护ID的繁琐工作完全抛给了库作者。开发者很快就意识到，如果需要为库中每一个导出的表达式手动添加类似 `"my-lib:module.sub-module.name"` 这样的长字符串ID，这本身就是一种对开发者体验的损害。

基于这个痛点，开发者提出了新的设想：
*   **抽象化“批量ID操作”**：是否能提供一种高度抽象化/去语义化的工具，让库作者可以对一组表达式进行“一键添加ID前缀”这样的批量操作，同时模糊掉“包名”域和“包下命名空间”域之间的界限？
*   **利用类型系统传递信息**：为了避免库作者在每次ID结构变动后，都要去手动更新多处JSDoc，是否能将ID的结构信息编码到类型系统中，让库使用者可以静态地获取这些信息？

#### Monica 的回应：构建时自动化方案

针对开发者提出的“减少手动操作”、“自动化”的核心诉求，AI助手Monica给出了一个方向不同但目标一致的回应方案。其核心理念是“约定优于配置 + 构建时魔法”，即深入强化**构建时预处理器 (Build-Time Preprocessor)**，彻底抛弃“开发者手动编写完整ID”的思路。

*   **理想的开发体验**：
    库作者的开发体验将回归纯粹，只需编写最简单的代码，无需任何 `.id()` 调用：
    ```typescript
    // file: my-awesome-lib/src/vector/math.ts
    import { expl } from 'bernard';

    /** Calculates the magnitude of a vector. */
    export const magnitude = expl`sqrt(v.x^2 + v.y^2)`;
    ```

*   **预处理器的工作流**：
    当库作者运行构建命令时，预处理器会自动扫描源代码，并根据文件结构约定，生成添加了完整ID的“标准形式”代码：
    ```typescript
    // 预处理器在内存中生成的代码
    /** Calculates the magnitude of a vector. */
    export const magnitude = expl`sqrt(v.x^2 + v.y^2)`
        .id("my-awesome-lib:vector/math.magnitude"); // ID被自动注入!
    ```
    ID的生成将遵循一个清晰的约定：`[库名]:[文件路径].[变量名]`。这个机制将开发者已经熟悉的“文件系统结构”作为组织ID的天然方式。同时，`.id()` API依然被保留，作为处理特殊情况、手动覆盖自动生成ID的可选功能。

*   **与类型系统深度集成**：
    该方案还采纳了开发者关于类型系统的设想，并提出了一个更进一步的实现：让预处理器不仅注入ID值，还将ID的字符串字面量**注入到TypeScript的类型系统中**。
    ```typescript
    // 预处理器可以让IDE将magnitude的类型推断为：
    // const magnitude: Expl<"my-awesome-lib:vector/math.magnitude">
    ```
    这将使得库使用者可以通过类型系统静态地、安全地获取到一个表达式的唯一ID，解决了跨模块传递ID信息的问题，相比手动编写JSDoc要可靠得多。

#### 发现新的致命缺陷——不稳定性

尽管这个自动化方案看起来非常优雅，解决了手动维护ID的繁琐问题，但开发者在讨论中敏锐地察觉到了一个新的**致命缺陷：ID的不稳定性**。

这个方案将表达式的**逻辑ID**与它在项目中的**物理文件路径**进行了**硬绑定**。这意味着，如果库作者为了维护代码而重构了项目的文件或目录结构（例如将 `vector/math.ts` 移动到 `math/vector.ts`），那么所有相关表达式的Bernard ID都会随之改变。

这是一种**破坏性变更 (Breaking Change)**。对于所有依赖这些ID的下游库使用者来说，库的一次内部代码重构都会导致他们的代码失效。这违背了“库的内部实现细节不应影响其公共API契约”的重要原则。正是为了解决这个“不稳定性”问题，讨论最终走向了第4版方案。

> 注：从本节开始，我们确立项目中的两组核心术语。
> 1.  **创作形式 (Authoring Form)** 与 **标准形式 (Canonical Form)**：
>     *   **创作形式**指开发者编写的、经预处理器增强的简洁代码（例如，``const c = expl`...` ``）。
>     *   **标准形式**指经预处理器转换后生成的、符合原生JS/TS标准的详细代码（例如，``const c = expl`...`.id('app:c')``），这是系统内部唯一认可的规范化版本。
> 2.  **ID 段 (ID Segment)**：
>     *   指构成完整 Bernard ID 的、由点号（`.`）或冒号（`:`）分隔的各个组成部分。例如，在 `my-lib:vector.magnitude` 中，`my-lib`、`vector` 和 `magnitude` 都是 ID 段。
> 3.  **ID 路径 (ID Path)** 与 **名称段 (Name Segment)**：
>     *   一个完整的 Bernard ID 由一个 **ID 路径**和一个**名称段**组成。**ID 路径**指 ID 中除最后一段外的所有前置部分，代表其逻辑位置；**名称段**则指 ID 的最后一段，通常由表达式创建时的“JS变量名隐式确定”功能决定。
>     *   例如，在 `my-lib.vector.magnitude` 中，`my-lib.vector` 是 **ID 路径**，而 `magnitude` 是 **名称段**。

### 第4版方案：动态、可塑与工具增强

第3版方案中“ID与物理文件路径硬绑定”所带来的不稳定性，促使开发者进行了一次彻底的范式转变。开发者指出，库作者在重构代码时不应意外地破坏对下游用户的API契约，因此，**一个健壮的系统必须允许库作者构建一个与物理文件结构脱钩（异构）的、稳定的逻辑ID体系**。

这个核心诉求，引发了一系列连锁的关键决策，最终形成了第4版方案，其核心是：**拥抱命令式编程的动态性，并通过外部工具链（IDE插件）来弥补静态类型系统留下的空白，以换取ID体系的稳定性和更高的灵活性**。

#### 核心抉择：拥抱可变 API (Mutable API)

为了让库作者能方便地构建和维护与文件结构异构的ID体系，必须提供“批量ID操作”的工具。此时，一个关键的技术抉择摆在面前：这些操作API应该是**不可变的（Immutable）**还是**可变的（Mutable）**？

*   **不可变 API 的困境**：如果API是不可变的（例如，`idprepend` 操作返回一组全新的表达式对象），那么对象之间的引用关系将会被破坏。
    > 例如，表达式 `b` 依赖于表达式 `a`。如果对它们进行批量ID操作 `group({a, b}).idprepend('mylib')` 会返回全新的 `mylib.a` 和 `mylib.b` 对象，那么新的 `mylib.b` 内部引用的仍然是旧的 `a` 对象，而不是新的 `mylib.a`，从而导致依赖关系错乱。

*   **开发者的决断**：为了维护表达式在进行ID操作时内部依赖关系的正确性，开发者明确选择**采用可变API**。这意味着 `idprepend` 等操作将**直接修改**传入的表达式对象本身（例如，在其内部追加一个ID转换规则），而不是创建新对象。

#### DevEx 的新路径：放弃类型系统，探索 Volar / IDE 插件能力

选择可变API的直接代价是，**无法再将动态变化的ID信息编码到静态的TypeScript类型系统中**。一个对象的类型将始终是 `Expl`，IDE无法在编译时知道其最终的ID。

为了解决由此带来的开发者体验问题（库使用者无法方便地获知ID），开发者提出了一条全新的路径：**通过一个强大的IDE插件（基于Volar）来增强DevEx**。

*   **动态计算与信息悬停**：IDE插件可以在库使用者将鼠标悬停到某个导入的表达式变量上时，**动态地、实时地**计算出其最终的Bernard ID，并将其显示在一个自定义的悬停窗口中。
*   **可定制的悬停信息**：为了给库作者最大的自由度并优化性能，方案设计了 `.hoverInfo()` API。库作者可以为表达式提供一个函数，用来自定义其悬停提示的内容，这比静态的JSDoc要灵活和强大得多。

#### 关键 API 与设计模式

基于以上原则，方案明确了一套面向命令式、动态编程的API和推荐模式。

*   **`group` 与批量 ID 操作**

    `group` 是一个核心辅助函数，用于将一组离散的表达式对象（或 `expr builder`）聚合为一个逻辑单元，以便进行后续的批量ID操作。这是库作者构建其逻辑ID树的主要工具。

    在其基础上，方案提供如 `.idprepend(segment: string)` 这样的可变API，它会接受一个ID段（`segment`）并将其作为前缀添加到 `group` 内所有对象的ID路径中，通过直接修改对象本身来完成操作。

    ```javascript
    // 示例：在一个物理模拟库中
    const physics = group({
        initialPosition,
        velocity,
        gravity,
    }).idprepend('physics');
    // 此操作会直接修改 initialPosition, velocity, gravity 对象
    ```

    对于 `group` 操作后的导出，向库作者推荐两种模式：
    1.  **非扁平导出**：将 `group` 的结果作为一个整体对象导出。这是最简单直接的方式。
        ```javascript
        export default physics;
        ```
    2.  **扁平导出**：如果库作者希望将组内的每个变量重新作为独立的顶级导出项，可以使用解构赋值的方式。这要求原始变量使用 `let` 而非 `const` 声明。
        ```javascript
        let { initialPosition, velocity, gravity } = physics;
        export { initialPosition, velocity, gravity };
        ```

*   **DevEx 增强：通过 `.hoverInfo` 定制悬停提示**

    为了弥补放弃静态类型系统所带来的信息损失，方案的核心是通过IDE插件提供信息悬停。`.hoverInfo(callback)` API 允许库作者为表达式或 `expr builder` 自定义此功能。

    它接受一个回调函数 `callback: (info) => string`，该回调函数接收一个包含详细信息的 `info` 对象，并返回一个字符串作为最终的提示内容。
    *   **`info` 对象详解**:
        *   `id: string`: 表达式在当前状态下计算出的**最终ID**。
        *   `realname: string | undefined`: 通过 `.realname()` 强制指定的最终Desmos变量名。
        *   `idInitial: string`: 表达式未经任何批量ID操作修改前的**初始ID**。
        *   `idDrvs: (initialId: string) => string`: 一个函数，封装了此对象经历过的**所有ID变换**（`drv` 意为 derivations）。它可以将一个初始ID转换为最终ID，库作者可以用它来向使用者展示ID的变换逻辑。
        *   `makeDefaultInfo: (id, realname, additionalInfo) => string`: 一个辅助函数，用于方便地生成默认格式的悬停提示字符串，并支持附加额外信息。

*   **`expr builder` 提升为一等公民**

    为了支持参数化生成等高级动态场景，方案将“表达式构造器” (**expr builder**) 提升为一等公民。`builder(callback)` API用于创建一个 `expr builder`，它接受一个回调函数，该回调函数自身需要返回一个可被用户调用的、用于生成表达式的函数。即：`builder((idDrvs: (initialId: string) => string) => ((...) => {...}))`。

    为了让 `builder` 能够正确响应外部的批量ID操作，外层回调会接收一个 `idDrvs` 函数 (`(initialId: string) => string`)。`builder` 的内部逻辑必须使用这个 `idDrvs` 函数来处理所有它生成的表达式的ID，从而正确应用外部通过 `group` 等方式施加的ID变换。

#### 本版方案总结

第4版方案的核心，是确立一套以**命令式、可变API**为基础，**以开发者主动维护的、与文件结构异构的逻辑ID体系**为核心的模块化方案。

该方案的基石是 `group()` 和 `builder()` 两个API，它们分别解决了静态表达式集合与动态表达式生成的批量ID管理问题。为了解决可变API与静态类型系统不兼容所带来的开发者体验下降问题，方案引入了**基于IDE插件（Volar）的外部工具链**。通过 `.hoverInfo()` API，库作者可以提供丰富的、动态的上下文信息，让库使用者在IDE中就能直观地了解表达式的最终ID等元信息。

这套设计通过接受“可变性”来换取“ID稳定性和动态能力”，再通过“工具链”来反哺“开发者体验”，最终形成了一个灵活、强大且对创作者友好的系统。

## 对先前方案的思考与更新 (251012)

（此处占位，用于记录后续的讨论和方案修改。）
