# 上下文语句API

> 本文档阐述 Destra “默认模式”中上下文语句的 API 设计。

推荐的实现语法将采用函数回调的形式，将局部变量通过上下文对象 (`ctx`, 或者鼓励解包传递) 注入。

## 1. For (List Comprehension)

Desmos 的 `for` 列表推导式用于生成一系列值。Destra 通过 `For` 工厂函数来建模这一行为。

*   **语法**: ``For`i = someList`(callback)``
*   **迭代器定义**: 模板字符串中定义迭代变量及其范围，支持多个变量，例如 `i = [1...10], j = [1...5]`（`[1...10]` 和 `[1...5]` 都是 desmos 和 destra DSL 语法中支持的 range 式列表创建语法）。多变量的 For 语句会自动对多个变量进行笛卡尔积迭代，靠前的变量先迭代，靠后的变量后迭代。
*   **回调函数**: 接收一个包含所有迭代变量的上下文对象 (`ctx`)，返回要在每次迭代中生成的表达式。实际上起到了“具名参数列表”的作用。
*   **返回值**: 返回一个 `Expression` 对象，代表整个列表推导式。

```javascript
// 对应 Desmos: [i^2 + j^2 for i=[1...10], j=[1...5]]
const list = For`i=[1...10], j=[1...5]` (({i, j}) => {
    return expr`${i}^2 + ${j}^2`;
});
```

### 2.2 With (Scope / Let-binding)

Desmos 的 `with` 语句用于引入局部变量。Destra 通过 `With` 工厂函数来建模。

*   **语法**: ``With`a = someValue`(callback)``
*   **赋值定义**: 模板字符串中定义局部变量及其值，也支持同时定义多个变量，例如 `a = 10, b = x^2`。
*   **回调函数**: 接收一个包含所有局部变量的上下文对象 (`ctx`)，返回在该作用域内计算的表达式。
*   **返回值**: 返回一个 `Expression` 对象。

```javascript
// 对应 Desmos: a^2 + b^2 with a=sin(x), b=cos(x)
const val = With`a=sin(${x}), b=cos(${x})` (({a, b}) => {
    return expr`${a}^2 + ${b}^2`;
});
```

Desmos 的 `with` 语句非常初步，有禁止嵌套的限制（with 下可以有 for，甚至嵌套 for，但往下不能再追溯到第二个 with），Destra 的 `With` 工厂函数也遵循这一限制，在创建时会检查依赖链上是否存在第二个 with 并报错。

### 2.3 Sum (Summation) & Int (Integration)

求和 (`Sum`) 和积分 (`Int`) 在结构上与 `For` 非常相似，都是引入一个局部迭代变量。

*   **Sum 语法**: ``Sum`n = 1, 10`(callback)``
*   **Int 语法**: ``Int`x = 0, 1`(callback)``
*   **迭代器定义**: 定义迭代变量及其范围。对于 `Sum` 范围是用上下界指定的离散 range，对于 `Int` 范围是用上下界指定的连续区间。上/下界传入列表型变量时会对列表进行广播。
*   **返回值**: 返回一个 `Expression` 对象。

由于这两种语句属于**算子语句**，在数学语义上严格绑定单一变量，为了API的简洁性，标准形式规定它们的回调函数**直接接收该变量**作为参数，而不需要像 `For/With` 那样接收 Context 对象。

```javascript
// 对应 Desmos: sum_{n=1}^{10} n^2
const s = Sum`n = 1, 10` (n => expr`${n}^2`);

// 对应 Desmos: int_{0}^{1} x^2 dx
const i = Int`x = 0, 1` (x => expr`${x}^2`);
```

### 2.4 Func (Function Definition)

虽然 `expl` 标签函数已经可以创建简单的函数定义 (如 ``expl`f(x) = x^2` `` 或 ``expl`f(x, y) = x^2 + y^2` ``)，但对于函数体构造逻辑复杂、需要利用 JS 表达能力的场景，我们提供 `Func` 工厂。

*   **语法**: ``Func`params_list`(callback)``
*   **参数列表**: 逗号分隔的参数名字符串，如 `x, y`。
*   **回调函数**: 接收包含参数的上下文对象，返回函数体表达式。
*   **返回值**: 返回一个 `FuncExpl` 对象。

```javascript
// 对应 Desmos: f_1(x, y) = x^2 + y^2
const f1 = Func`x, y` (({x, y}) => expr`${x}^2 + ${y}^2`).id('f1');

// 对应 Desmos: f_2(x, y) = x^2 + y^2
const f2 = expl.Func`x, y` (({x, y}) => {
    // 在这里可以使用任意 JS 逻辑来构建表达式
    const dist = expr`${x}^2 + ${y}^2`;
    return dist;
}).id('f2');
```

### 注：术语说明

*   **上下文工厂函数 / Context Factory Function**: 包括 `For`, `With`, `Sum`, `Int`, `Func`，`expl.For`, `expl.With`, `expl.Sum`, `expl.Int` 所有工厂函数。用 expl 工厂结合纯内嵌 DSL 语法创建的上下文语句不算。
*   **上下文语句 / 上下文表达式 / Context / Context Statement / Context Expression / CtxExp**: 上下文工厂函数创建的上下文语句，可能为 Expression 或 Expl 类型（子类）。
*   **上下文变量 / Context Variable / CtxVar**: 上下文语句中定义的变量。
*   **定义头部 / Definition Header**: 上下文语句中，作为工厂函数立即作用的模板字面量内容的，给出各个上下文变量定义的头部，或者说这个模板字符串的 payload。
*   **身体表达式 / Body Expression / body**: 上下文语句中回调函数创建并返回的表达式。

### 注：作用域内使用 expl 的行为

是的，我们可以在作用域内使用 `expl` 标签函数来创建表达式，并且会非常巧妙地得到一个 desmos 所支持的结果：

当你在作用域内创建 `expl` 表达式后，按照 expl 的意图，会在作用域所在的公式**外边**生成一个对应的公式。这个公式因为依赖了作用域内的变量，所以在 desmos 里会报错（带有悬空依赖），但是只要在作用域内使用这个变量，它就可以在里面正常工作了，并且让整个作用域表达式正确完成构建/定义。

例如：

```javascript
// 对应 Desmos: 
// d_ist = a^2 + b^2 --> 带有悬空依赖，在该行上报错
// f_2(a, b) = d_ist --> 依然正确创建
const f2 = expl.Func`a, b` (({a, b}) => {
    // 在这里可以使用任意 JS 逻辑来构建表达式
    const dist = expl`${a}^2 + ${b}^2`.id('dist');
    return dist;
}).id('f2');
```

甚至还有这种情况：
```javascript
// 对应 Desmos: 
// d_ist = x^2 + y^2 
// f_2(x, y) = d_ist
const f2 = expl.Func`x, y` (({x, y}) => {
    // 在这里可以使用任意 JS 逻辑来构建表达式
    const dist = expl`${x}^2 + ${y}^2`.id('dist');
    return dist;
}).id('f2');
/**
 * 按理来说 d_ist 那一行公式应该带有悬空依赖，会在该行上报错；
 * 但是因为这里依赖的变量名是保留变量名 x 和 y，所以 desmos 能够接受这种“关于x, y的表达式片段”，并供后续构建隐式方程时使用，不会在该行报错
 * 但无论如何都不影响最终 f2 的成功创建和正常使用，以及 Destra 对这种行为的正确支持
 */
```

但是，虽然 Destra 也支持用户生成这种略带 hack 色彩的操作，但是这个策略并不是万能的，有时候会出错，所以我们需要再加上一些限制：

*    首先，显然我们不能在作用域内创建依赖于上下文变量的 FuncExpl 函数定义。因为我在 desmos 里试了没法成功x（外界带有悬空依赖的函数，无论在哪一种能够补全变量的上下文作用域里都无法让它重新正常工作。我嘞个阻断性错误......）

*    其次。。。好吧想不到了暂时就这些了

### 2.5 语法糖：`expl.*` 系列

为了简化“创建上下文结构并立即将其赋值给变量”这一常见模式，我们为所有上下文工厂提供了 `expl` 命名空间下的语法糖版本。它们直接返回 `VarExpl`。

*   `expl.For` -> 返回 `VarExpl`
*   `expl.With` -> 返回 `VarExpl`
*   `expl.Sum` -> 返回 `VarExpl`
*   `expl.Int` -> 返回 `VarExpl`
*   `Func` 不需要语法糖，因为它返回的就是 `FuncExpl`（函数必为具名函数）。

```javascript
// 直接返回一个 VarExpl 对象
const myVar = expl.For`i=[1...10]`(({i}) => expr`${i}^2`).id('myVar');

const myVal = expl.With`a=10`(({a}) => expr`${a} * 2`).id('myVal');
```

### 2.6 参数传递方式 (Standard Form)

可以看到我们设计的这种传递 ctx 对象 / 解包传递的方式其实也有点问题，有时候会让用户感觉写起来有点繁琐——特别是当参数只有1个的时候，为什么 For 和 With 要强制我写一个解包的花括号？

但是更好的设计其实是无法实现的。或者至少说，标准形式下无法实现，例如根据传入的 lambda 代码形式在类型系统里自动推断出应该传递 ctx 对象还是直接接收变量：

```javascript
// 示例：根据传入的 lambda 代码形式在类型系统里自动推断出应该传递 ctx 对象还是直接接收变量——但实际上不可行
const f1 = For`i=[1...10]`(({i}) => expr`${i}^2`);
const f2 = For`i=[1...10]`(i => expr`${i}^2`);
```

所以为了保证类型安全和代码的可预测性，标准形式下依然采用确定不变的参数传递方式。

*   **`For`, `With`, `Func`**: 总是接收一个 **Context 对象**。
    *   设计意图：这些语句定义了一个包含多个潜在变量的命名空间。即使只有一个变量，也必须通过解构获取。
    *   写法：``For`...`(({i}) => ...) `` 或 ``With`...`(({a, b}) => ...) ``

*   **`Sum`, `Int`**: 总是接收**单个变量 (VarExpl)**。
    *   设计意图：这些语句在数学上严格绑定单一变量，所以让用户记住即使在标准形式下也必须直接接收这个变量作为参数，应该也是可以接受的。
    *   写法：``Sum`...`(n => ...) `` 或 ``Int`...`(x => ...) ``

### 2.6.1 语法糖 (仅创作形式 / Creative Form): 参数免解包

在创作形式 (Creative Form) 或者说预处理层中，我们可以引入“智能参数解包”的语法糖，允许用户在所有场景下省略解包步骤直接接收变量。但请注意，这超出了标准形式 (Standard Form) 下 TypeScript 类型推断的能力极限，必须通过一层代码转换才能实现。

```javascript
// 概念示例 (仅在 Creative Form 下可用)
For`i=[1..10]`(i => expr`${i}^2`); // 自动转换为 For`...`(({i}) => ...)
With`a=10`(a => expr`${a} * 2`); // 自动转换为 With`...`(({a}) => ...)
```

### 2.6.2 语法糖 (仅创作形式 / Creative Form): Func 工厂省略定义头部

对于 `Func` 工厂，我们可以提供一种无需显式声明参数列表的简化写法。同样仅在创作形式 (Creative Form) 可用，依赖于预处理器的 AST 分析。

```javascript
// 标准形式
Func`x, y` (({x, y}) => expr`${x}^2 + ${y}^2`)

// 创作形式 (Creative Form)
// 自动分析出参数名 "x", "y" 并生成上面的标准形式
Func((x, y) => expr`${x}^2 + ${y}^2`)
```

### 2.7 纯字面量 / 内嵌 DSL 语法

前面提到过对于函数创建来说也有直接使用 DSL 语法来创建的写法，因此我们可以推广到所有 5 种上下文语句里，对于不需要用 JS 作用域组织逻辑的简单场景，或者大量插值-模板字面量-插值会带来大量"语法噪音"的场景，用户可以直接使用 `expr` 或 `expl` 配合 DSL 语法，而无需使用上述工厂函数。

*   **工厂函数 (For/Sum/...)**: 专用于 **Callback 模式**，利用 JS 闭包特性构建复杂逻辑。
*   **DSL 语法**: 直接写在字符串里。

```javascript
// 简单场景：直接写字符串
const s = expr`sum(n=1, 10) n^2`;

// 复杂场景：使用工厂
const s2 = Sum`n=[1...10]` (n => {
   const term = complexLogic(n);
   return term;
});

// 复杂场景：纯 DSL 写法
// 可以想象一下如果这种带有大量 for/with/expr 嵌套的表达式逻辑，
// 用工厂+插值+回调嵌套的写法写出来会是什么样子...
const mosaicGrid = expl`
    [
        polygon(P, P + (1, 0), P + (1, 1), P + (0, 1)) 
        for P = Points[Filter = 0]
    ] with
        Points = [(i, j) for i = [0...${N}-1], j = [0...${N}-1]],
        Filter = [mod(i + j, 2) for i = [0...${N}-1], j = [0...${N}-1]]
    `.id("mosaicGrid")
```

#### 语法完整列举 

*   **sum**: ``expr`sum(n = 1, 10) n^2` ``
*   **int**: ``expr`int(0, 1) x^2 dx` ``
*   **for**: ``expr`i^2 for i=[1...10]` ``，``expr`[i^2 for i=[1...10]]` ``
*   **with**: ``expr`2 + a with a = 2` ``
*   **func**: ``expl`f(x) = x^2` ``，``expl`(x, y) => x^2 + y^2` ``

#### 作用范围

**sum, int**: 遵循数学的惯用规则，优先级仅高于加减号，低于一切算术运算——除非使用括号手动指定表达式结构。

```javascript
const s = expr`sum(n=1, 10) n^2 + 1`; // sum 优先级高于加减号，所以在 desmos 里计算结果为 (sum(n=1, 10) n^2) + 1 = 385 + 1 = 386
const int = expr`int(0, 1) x^2 dx + 1`; // 在 desmos 里计算结果为 int(0, 1) x^2 dx + 1 = 1/3 + 1 = 4/3

// const int = expr`int(0, 1) x^2 + 1 dx`; 
// int 优先级高于加减号，所以在 desmos 里会认为你写的是 (int(0, 1) x^2) + 1 dx，写了一个没有 dx 被积变量的积分表达式，以及外面 "dx" 解析为 "d * x" 找不到变量 "d" 的定义，从而报错。
```

另外在 int 语句中，dx 的位置会影响表达式解析结果：
```javascript
const int2 = expr`int(0, 1) dx x^2 + 1`; 
```

在 desmos 里除了运算符优先级这个条件之外，积分身体表达式范围的划定也受另一个因素的影响：表达式范围不超过 dx 的位置。

也就是说，这个表达式在 desmos 里会被解析为 (int(0, 1) dx) (x^2 + 1)，而不是 int(0, 1) (dx x^2 + 1)，进而解析成显式方程。

但是在数学物理里把 dx 放最前也是合理的写法之一，实际上既然已经有了一个根据运算符优先级+括号来划定身体表达式范围的机制，那么 desmos 按理本来就不应该再加上这个根据 dx 位置限制范围的限制，这样只会让用户更容易写错。

所以在 destra 里我们**支持这种把 dx 置于乘法链任意位置的写法**，并会在**解析时自动把 dx 移至最后**，将这种写法转换为 desmos 认为正确的写法。这个例子会被解析为 (int(0, 1) x^2 dx) + 1。

**for, with**: 由于语法特性，它们的作用域变量定义位于身体表达式的右侧/后面。

for 的优先级也仅高于加减号，同时for 表达式外围可以使用中括号包围（desmos 支持），其实也等效于用圆括号包围，以作为一种明确界定身体表达式范围的方法，这时候它可以跨越优先级规则界定身体表达式的范围。

（其实历史上 desmos 是先支持，甚至强制要求使用中括号包围的写法的，后来才支持圆括号包围、或者在一些条件下可以无括号包围的写法的）

```javascript
const L1 = expr`2 * i^2 for i=[1...10]`; // 在 desmos 里计算结果为 [2 * i^2 for i=[1...10]]
const L2 = expr`2 * [i^2 for i=[1...10]]`; // 在 desmos 里计算结果为 2 * [i^2 for i=[1...10]]
const L3 = expr`2 * (i^2 for i=[1...10])`; // 在 desmos 里计算结果为 2 * [i^2 for i=[1...10]]
const L4 = expr`2 + i^2 for i=[1...10]`; // 在 desmos 里计算结果为 2 + [i^2 for i=[1...10]]
const L5 = expr`2 + [i^2 for i=[1...10]]`; // 在 desmos 里计算结果为 2 + [i^2 for i=[1...10]]
// with 的优先级低于加减号（应该也就是低于一切算术运算了），高于函数定义和变量定义
const W1 = expr`2 + a with a = 2`; // 在 desmos 里计算结果为 2 + 2 = 4
const W2 = expr`a^2 with a = 2 + 2`; // 在 desmos 里计算结果为 (2 + 2) ^ 2 = 16
```

另外：
```javascript
// const W3 = expl`a = 10 with a = 2`; 
```
不要在变量定义里使用同名 with。desmos 的报错很令人费解，是什么“系统只支持x和y的隐函数方程。” ...??? 总之本来从原则上就不应该重名的。

Destra 在上下文语句的工厂函数语法里会自动通过 id 映射过程，让作用域变量之间、以及作用域变量与 Expl 之间避免重名。

### 2.8 类体系设计

在以下继承位置新增以下几个类，同时更改其他代码以和这些新类兼容。

*   **CtxVar 类**: 直接继承自 `Formula` 类（与 `Expr` `Expl` 平行），用于存储上下文变量的 CtxVar ID 和源上下文语句的引用。
*   **CtxExpression 类**: 继承自 `Expression` 类，实现 `CtxExp` 接口，为 `Sum`, `Int`, `For`, `With` 工厂的返回类型，并带有 `CtxExp` 接口的、上下文语句带有的特殊额外数据。
*   **CtxVarExpl 类**: 继承自 `VarExpl` 类，实现 `CtxExp` 接口，为 `expl.Sum`, `expl.Int`, `expl.For`, `expl.With` 工厂的返回类型，并带有 `CtxExp` 接口的、上下文语句带有的特殊额外数据。
*   **CtxFuncExpl 类**: 继承自 `FuncExpl` 类，实现 `CtxExp` 接口，为 `Func` 工厂的返回类型，并带有 `CtxExp` 接口的、上下文语句带有的特殊额外数据。
*   **CtxExp 接口**: 为 `CtxVar`, `CtxExpression`, `CtxVarExpl`, `CtxFuncExpl` 类的公共接口，用于存储上下文语句带有的特殊额外数据：
    *   **ctxVars**: 存储上下文变量对象的引用。
    *   **body**: 存储 callback 返回的身体表达式内容的引用。
*   注：
    *   原有的 deps 字段只记录定义头部中的依赖；这些依赖记录在各 CtxExp 本身中，而不记录在各 ctxVar 中。
    *   身体表达式的依赖由身体表达式对象自己记录。
    *   原有的 template 字段记录的也是定义头部的模板字面量内容，但是 ctxVar 的 template 字段则不记录任何内容。
*   重写 / 更新 面向 CtxExp 和 CtxVar 的 _content getter 方法，使用专门的描述性内容生成逻辑。

### 2.9 创建时(Creation Time)可做的检查

在创建上下文语句时，由于带来了一些新的逻辑，可以进行一些额外的创建时检查，以获得一些 fast-fail 的错误提示。

#### CtxVar 传递方向检查: 

CtxVar 按理必须**只能向内传递**。不能向外部传递。同时按照附加规则 CtxVar 不能传递到内层函数定义内。但是在 js 里用户是有可能 Exploit 的，比如在回调函数里把 CtxVar 传到外部去。

好吧，这个会相当难处理了。我们无法阻止用户在回调函数里把 CtxVar 传到外部去，但我们可以阻止用户把传到外部的 CtxVar 落地到表达式树 / 依赖树里原上下文语句节点的下游去。虽然但是，这需要各方面代码的配合。同时，我们也要注意不应阻止上下文语句接收自己外面来自更外层上下文语句的变量，因为这是合法的行为。

*   在一个 Context 语句创建时，阻止来自更内层 Context 的 CtxVar 传递到本层 Context 可见的、超出那个内层 Context 的位置。在 Context 语句被创建时，分析上下文变量定义的模板字面量内容，创建 CtxVar，并传入 callback 里执行 callback，接收 callback 返回/构建的表达式。然后检查该表达式的依赖树，如果找到任何在内层 Context 外使用内层 Context 变量的行为，则报错。
*   在最终编译（也即全局公式列表被"封顶"时），阻止任何 CtxVar 传递到 Context 之外，位于全局公式列表 / “全局作用域” 的位置。这需要在编译功能的代码里实现。在编译功能里，我们可以通过检查全局公式列表的依赖树，如果在 Context 之外找到任何 CtxVar 的依赖，则报错。
*   在一个函数定义创建时（包括新建的 Func 工厂和原有的 expl 工厂），阻止任何 CtxVar （除非使用工厂语法，然后是自己的 CtxVar）传递到函数定义内。

#### 其他检查

*   **同语句内变量定义重名检查**: 在一个 Context 语句创建时，分析字面量内容，如果发现有同名变量定义，则报错。
*   **With 语句嵌套限制检查**: 在一个 With 语句创建时，检查身体表达式的依赖以及上下文变量定义式的依赖，如果发现有第二层 With 语句，则报错。
*   **定义头部的自依赖检查（编译时）**: 在编译时，检查定义头部的模板字面量内容，如果发现有上下文变量依赖于本上下文表达式定义的本层上下文变量（比如 `x = x`，或者`a = b, b = 1` 这样的写法），则报错。