既然你已经有清晰的「工具链与开发体验」文档，那我们**直接做插件**绝对是正确的选择。手动搭建 Playground 虽然快，但后续还是得拆掉重做。

你提到的文档里非常明确：**Destra 定位为一个标准的 Vite 插件 (`Library` 思路)**。

### 1. Vite 插件大概是怎么做的？

Vite 插件本质上是一个返回对象的函数。它利用 Rollup 的插件接口，并在其基础上增加了一些 Vite 独有的钩子（Hooks）。

对于你的 **"图表实时预览 (Live-Preview)"** 场景，我们需要用到的核心钩子主要有两个：

1.  **`configureServer(server)`**:这是开发服务器的钩子。我们可以利用它拦截浏览器的请求，返回我们自定义的 HTML（包含 Desmos 计算器的外壳），而不是让 Vite 去找磁盘上的 `index.html`。
2.  **`resolveId` / `load` (可选)**: 用于生成“虚拟模块 (Virtual Modules)”。我们可以凭空捏造一个 `virtual:destra-runner` 文件，把用户的图表代码和 Desmos 的初始化代码“胶合”在一起。

---

### 2. 插件实现方案 (v0.1)

为了快速验证，我们暂不实现复杂的 AST 预处理器（那是 `@bernard/preprocessor` 的工作），我们先实现 **"预览容器"** 的功能。

**目标**：
用户在 `vite.config.ts` 里配置入口文件，运行 `vite dev`，浏览器直接打开 Desmos 并渲染该文件的导出结果。

#### 第一步：目录结构

在 monorepo 中创建插件包目录：

```text
destra.js/
├── facade/
│   └── vite-plugin-destra/  <-- 新建
│       ├── package.json
│       ├── src/
│       │   ├── index.ts     <-- 插件入口
│       │   └── client.d.ts  <-- 类型定义
│       └── tsconfig.json
```

#### 第二步：编写插件代码 (`src/index.ts`)

这个插件的核心逻辑是：
1.  拦截根路径 `/` 的请求。
2.  返回一个包含 Desmos API 脚本的 HTML 模板。
3.  在模板里注入一段 JS，这段 JS 会导入用户的图表文件，并把导出的 Graph 对象喂给 Desmos。

```typescript
import type { Plugin, ViteDevServer } from 'vite';

interface DestraPluginOptions {
    /**
     * 图表入口文件路径 (相对于项目根目录)
     * 例如: 'src/my-graph.ts'
     */
    entry: string;
    
    /**
     * Desmos API Key (可选，开发用默认即可)
     */
    apiKey?: string;
}

export default function destraPlugin(options: DestraPluginOptions): Plugin {
    const virtualModuleId = 'virtual:destra-runner';
    const resolvedVirtualModuleId = '\0' + virtualModuleId;

    return {
        name: 'vite-plugin-destra',
        
        // 1. 解析虚拟模块 ID
        resolveId(id) {
            if (id === virtualModuleId) {
                return resolvedVirtualModuleId;
            }
        },

        // 2. 加载虚拟模块内容 (这就是前面说的“胶水代码”)
        load(id) {
            if (id === resolvedVirtualModuleId) {
                // 这里我们动态生成 JS 代码
                // 导入用户的 entry，获取 default export，然后初始化 Desmos
                return `
                    import userGraph from '/${options.entry}';
                    
                    // 简单的类型保护，实际可以在这里做更多错误检查
                    if (!userGraph || typeof userGraph.export !== 'function') {
                        console.error("[Destra] 入口文件默认导出必须是一个 Graph 实例");
                        document.body.innerHTML = '<h1 style="color:red">Error: Default export is not a Graph</h1>';
                    } else {
                        // 初始化 Desmos
                        const elt = document.getElementById('calculator');
                        const calculator = Desmos.GraphingCalculator(elt, {
                            expressions: false // 接管表达式列表
                        });
                        
                        // 编译并渲染
                        try {
                            const state = userGraph.export();
                            console.log("[Destra] Compiled State:", state);
                            calculator.setState(state);
                        } catch (e) {
                            console.error("[Destra] Compilation Error:", e);
                        }
                        
                        // TODO: 这里可以添加 HMR 热更新逻辑
                        if (import.meta.hot) {
                            import.meta.hot.accept('/${options.entry}', (newModule) => {
                                if (newModule && newModule.default) {
                                     console.log("[Destra] Hot Update");
                                     try {
                                        const newState = newModule.default.export();
                                        calculator.setState(newState);
                                     } catch(e) { console.error(e); }
                                }
                            });
                        }
                    }
                `;
            }
        },

        // 3. 配置开发服务器，拦截首页请求
        configureServer(server: ViteDevServer) {
            server.middlewares.use((req, res, next) => {
                // 如果请求的是根路径，我们返回自定义的 HTML
                if (req.url === '/') {
                    const apiKey = options.apiKey || 'dcb31709b452b1cf9dc26972add0fda6'; // 测试 Key
                    
                    const html = `
<!DOCTYPE html>
<html>
<head>
    <title>Destra Live Preview</title>
    <meta charset="utf-8">
    <style>html, body, #calculator { width: 100%; height: 100%; margin: 0; overflow: hidden; }</style>
    <script src="https://www.desmos.com/api/v1/calculator.js?apiKey=${apiKey}"></script>
</head>
<body>
    <div id="calculator"></div>
    <!-- 引入我们的虚拟 Runner 模块 -->
    <script type="module" src="/@id/${virtualModuleId}"></script>
</body>
</html>
                    `;
                    
                    res.statusCode = 200;
                    res.setHeader('Content-Type', 'text/html');
                    res.end(html);
                    return;
                }
                next();
            });
        }
    };
}
```

---

### 3. 如何在当前的 `v-id-mutable` 目录中使用它？

你不需要真的先把包发到 npm，也不用先配置 monorepo 的软链接。我们可以直接在 `v-id-mutable` 目录下创建一个简单的 `vite.config.ts` 来**本地引用**这个插件逻辑。

**在 `destra.js/variant-drafts/v-id-mutable/` 目录下：**

1.  创建 `example-graph.ts` (你的测试用例)。
2.  创建 `vite.config.ts`：

```typescript
import { defineConfig } from 'vite';
import path from 'path';

// --- 暂时把插件代码直接写在这里，或者是 import 进来 ---
// 实际工程化后，这里会变成 import destra from '@bernard/vite-plugin'
function destraLocalPlugin(options: { entry: string }) {
   // ... (把上面的插件代码复制粘贴到这里，或者放在一个 local-plugin.ts 里导入)
   // 记得把上面代码里的 virtualModuleId 改成简单的字符串，避免 TS 类型问题
   const virtualModuleId = 'virtual:destra-runner';
   const resolvedVirtualModuleId = '\0' + virtualModuleId;
   
   return {
       name: 'vite-plugin-destra-local',
       resolveId(id: string) {
           if (id === virtualModuleId) return resolvedVirtualModuleId;
       },
       load(id: string) {
           if (id === resolvedVirtualModuleId) {
               // 注意：这里需要根据实际情况生成 import 路径
               // 简单的处理方式：
               return `
                   import userGraph from '/${options.entry}';
                   declare const Desmos: any;
                   
                   const elt = document.getElementById('calculator');
                   const calculator = Desmos.GraphingCalculator(elt, { expressions: false });
                   
                   function render() {
                       const state = userGraph.export();
                       calculator.setState(state);
                   }
                   
                   render();
                   
                   // 简易 HMR
                   if (import.meta.hot) {
                       import.meta.hot.accept((newModule) => {
                           window.location.reload(); // 暂时强制刷新页面
                       });
                   }
               `;
           }
       },
       configureServer(server: any) {
           server.middlewares.use((req: any, res: any, next: any) => {
               if (req.url === '/') {
                   const html = `
                       <!DOCTYPE html>
                       <html>
                       <head>
                           <style>html,body,#calculator{width:100%;height:100%;margin:0;}</style>
                           <script src="https://www.desmos.com/api/v1/calculator.js?apiKey=dcb31709b452b1cf9dc26972add0fda6"></script>
                       </head>
                       <body>
                           <div id="calculator"></div>
                           <script type="module" src="/@id/${virtualModuleId}"></script>
                       </body>
                       </html>
                   `;
                   res.end(html);
                   return;
               }
               next();
           });
       }
   }
}

export default defineConfig({
    plugins: [
        destraLocalPlugin({
            entry: 'example-graph.ts' // 指定你的入口文件
        })
    ]
});
```

### 总结

这种方式完美契合你文档中的 **Scene 5: Live-Preview Graph Development**。

1.  **Library 模式**：用户不需要关心 HTML，只需要配置 `vite.config.ts`。
2.  **开发体验**：运行 `npx vite`，插件接管路由，直接展示 Desmos 和你的图表。
3.  **未来扩展**：以后可以在 `load()` 钩子之前加入 `transform()` 钩子，引入你提到的 **预处理器**（把 ``const c = expl`...` `` 自动注入 ID），这也是 Vite 插件的标准用法。

要不要我帮你把这个 `vite.config.ts` 写出来，你直接复制进去运行试试？
