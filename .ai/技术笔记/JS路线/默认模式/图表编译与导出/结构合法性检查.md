# 结构合法性检查

> 本文档是 [编译与导出](./index.md) 流程中 "Step 1.5: 结构合法性检查" 的详细方案。它位于 ID 索引构建之后，旨在确保图表的依赖结构符合 Destra 和 Desmos 的限制。

由于 Destra 是 JS 库，通用编程语言能力带来的灵活性允许用户构建复杂的 JS 对象依赖图，但也会引入一些 Destra （至少默认模式）所不期望的、无法通过机制设计本身完美避免的极端情况，这些情况下用户所构造的结构难以或者根本无法对映为 Desmos 图表内容。因此需要此步骤负责在编译早期手动识别并拦截这些非法结构。

## 1. CtxVar 逃逸与引用检查 (Scope Leakage)

**核心原则**: 一个上下文变量 (`CtxVar`) **只能**被其所属的 `CtxExp` (Factory Formula) 的 `body` 表达式及其下游依赖所引用，且该引用路径必须完全处于该 `CtxExp` 的作用域内。

### 1.1 违规场景示例

```javascript
// 1. 全局逃逸：CtxVar 被直接用作全局公式
let a_leak = null;
const v = expl.With`a=1`(({a}) => {
    a_leak = a;
    return a;
});
const leak = expr`${a_leak} + 1`; // leak 在 With 外部引用了 a_leak，导致 a 逃逸到全局

// 2. 交叉引用（菱形依赖逃逸）：
// F 引用了 a
const F = expr`... ${a} ...`; 
// Path 1: Valid
const valid = expl.With`a=1`(({a}) => F); 
// Path 2: Invalid - F 被另一个无关路径引用，此时 F 处于 a 的作用域之外
const invalid = expr`${F} + 1`; 
```

### 1.2 检查算法：Scope Marking (染色法)

我们需要确认：对于图中的每一个 `CtxVar` 引用，该引用点是否都位于定义该 `CtxVar` 的 `CtxExp` 的合法支配树 (Dominator Tree) 下。

**算法步骤**:

1.  **初始化**:
    *   为每个 Formula 对象维护一个 `validScopes: Set<CtxExp>` 集合，记录该节点“被允许访问”的上下文环境。
    *   初始状态下，所有 Formula 的 `validScopes` 为空。

2.  **自顶向下传播 (Top-down Propagation)**:
    *   遍历图表中的所有 `CtxExp` (Factory Formulas)。
    *   对于每个 `CtxExp` (记为 `S`)，从其 `body` 开始进行**有向图遍历** (DFS/BFS)。
    *   **传播规则**:
        *   访问节点 `F`。
        *   将 `S` 加入 `F.validScopes`。
        *   **阻断条件 (Boundary)**:
            *   如果 `F` 是 `VarExpl` (具名变量) 或 `FuncExpl` (函数)，停止沿该路径继续传播？
            *   **注意**: Desmos 中，具名变量 (`y = x + 1`) 引用上下文变量时，该变量本身必须定义在上下文内部。如果外部引用 `y`，`y` 作为一个整体被引用，并不意味着 `x` 逃逸。但如果 `y` 的定义依赖了 `CtxVar`，那么 `y` 本身必须处于该 `CtxVar` 的作用域内。
            *   **策略**: 传播**不应**被 `Expl` 阻断。因为如果 `Expl` 依赖了 `CtxVar`，那么引用该 `Expl` 的地方也隐含地处于该 Scope 约束下（除非该 Expl 自身是一个封闭的 Context，但这在 Desmos 里很罕见且复杂）。
            *   **修正策略**: 传播穿透所有 `Expression`, `VarExpl`, `FuncExpl`。
        *   **特例**: 如果遇到**另一个** `CtxExp` (Nested Scope)，进入其 Body 继续传播吗？
            *   是的。内部 Scope 的 Body 自然也是外部 Scope 的一部分。

3.  **引用合法性验证 (Validation)**:
    *   遍历图中所有 Formula。
    *   检查该 Formula 的 **直接依赖** (`deps`)。
    *   如果发现依赖项 `D` 是一个 `CtxVar`:
        *   找到定义 `D` 的源头 `CtxExp` (记为 `SourceS`)。
        *   检查当前 Formula 的 `validScopes` 集合是否包含 `SourceS`。
        *   **如果不包含**: 报错 `CtxVar Leakage: Variable '${D.name}' used outside its defining scope.`。

**补充：关于“隐式顶级归属”**:
在 Step 1 中我们收集了“隐式顶级公式”。如果这些公式依赖了 `CtxVar`，在上述算法中，它们因为是依赖链的上游，会被 `CtxExp` 遍历到并打上标记，这是合法的。
**但在全局根遍历时**：我们需要检查那些**没有**被任何 `CtxExp` 覆盖到的节点（即全局节点）。如果它们依赖了 `CtxVar`，上述算法能覆盖吗？
*   上述算法是“允许名单”机制。
*   我们需要补充：遍历所有节点，如果节点依赖了 `CtxVar`， assert `validScopes.has(ctxVar.source)`. 如果 `validScopes` 为空，显然报错。

## 2. 函数内外部变量引用检查 (Closure Safety)

**核心原则**: Desmos 的函数定义 (`f(x) = ...`) 是非闭包的。其内部表达式**不能**引用外部定义的上下文变量 (`CtxVar`)。它只能引用：
1.  全局变量 (Global Expls)。
2.  函数自身的参数 (`Func` Factory 定义的 CtxVar)。

### 2.1 检查算法

1.  遍历所有 `FuncExpl` 对象。
2.  获取其 `deps` 列表。
3.  对于每个依赖 `D`:
    *   如果 `D` 是 `CtxVar`:
        *   检查 `D` 是否属于该 `FuncExpl` 自身（即 `D.sourceCtx === FuncExpl`）。
        *   **如果不是**: 报错 `Illegal Closure: Function '${FuncExpl.name}' references external context variable '${D.name}'. Desmos functions do not support closures.`。

## 3. With 语句嵌套检查

**核心原则**: Desmos 不支持 `With` 语句的嵌套。

### 3.1 检查算法

需要检查的是 **内联展开 (Inlining)** 导致的嵌套。

1.  遍历所有 `CtxExp`，筛选出 `ctxKind === 'with'` 的节点。
2.  对于每个 `With` 节点，遍历其依赖树 (DFS)。
3.  **路径检查**:
    *   在遍历路径上，维护一个状态 `hasEncounteredWith = true`。
    *   如果路径上遇到另一个 `CtxExp` 且 `ctxKind === 'with'`:
        *   **阻断判断**:
            *   如果中间经过了 `VarExpl` (具名变量) 或 `FuncExpl`：**合法**。因为具名变量在 Desmos 中是独立的引用，不会导致语法层面的嵌套展开。
            *   如果是纯 `Expression` 直接连接：**非法**。报错 `Nested With: 'With' statements cannot be directly nested via inline expressions.`。

## 4. 定义头部自依赖检查

**核心原则**: 上下文语句的定义部分（如 `For` 的列表定义、`With` 的赋值）不能引用本层定义的变量。

### 4.1 检查算法

1.  遍历所有 `CtxExp`。
2.  获取其 `ctxVars` 列表。
3.  对于每个 `CtxVar` (记为 `V`):
    *   获取 `V` 的定义表达式 (例如 `With` 中的赋值表达式，或 `For` 中的 Range 定义)。
        *   注意：这需要访问 `CtxExp` 内部结构，获取 `definitions` 对应的 Formula。
    *   检查该定义表达式的依赖树。
    *   如果依赖树中出现了 `V` 自身，或者 `ctxVars` 列表中的其他同级变量：
        *   报错 `Circular Definition: Context variable '${V.name}' references itself or sibling variables in its definition.`。
