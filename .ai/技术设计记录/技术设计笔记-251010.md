# Bernard.js 默认模式设计记录（251010-251019）

> 注意：本文档涉及的设计记录和 [命名设计笔记-251016.md](../命名设计笔记-251016.md) 大致发生在同一时间，项目已更名为 "Destra.js" (以及: "Destra.jl"; "Desmos Canvas" -> "PerSpatia.Ad: Destra (PSADestra)")；但为了历史记录内容一致性，本记录文档里依然按照原名 "Bernard.js" 和 "Desmos Canvas" 进行记录和后续的构思设计。后面把设计内容同步更新到主知识库文档时再按照新命名进行更新。

## 251010 与 Monica 的讨论回顾

> 本节内容基于 `../imported/20251010 monica聊天记录.md` 的讨论进行总结。

在10月10日，开发者与AI助手Monica进行了一次深入的讨论，旨在为 Bernard.js 的默认模式设计一套健壮的 **命名与封装机制**。以下是该次讨论中方案演进的详细回顾。

### 背景：核心矛盾

设计的起点源于一个核心矛盾：
> JavaScript 变量名的丰富性、灵活性与 Desmos 变量名的严格限制、可读性差之间的冲突。

在此之上，还有一个关键的工程化约束：
> 如何让用户能够像使用 npm 包一样，模块化地分发、组合和复用 Bernard 代码，同时避免命名冲突并提供良好的开发者体验（DevEx）。

### 初步构想

这是设计的最早版本，来源于开发者的初始笔记，是开发者的初始灵感组合，包含了几个核心要素：

1.  **三层命名系统**：在"JS 变量名"和"Desmos 变量名"之间，引入一个稳定且由开发者控制的中间层——**"Bernard 标识 (ID)"**。
2.  **命名 API**：提供 `.name()` 用于设置 Bernard ID，`.realname()` 用于强制指定最终的 Desmos 变量名，以及 `package()` 函数用于批量为一组表达式添加命名空间。
3.  **严格的依赖与上下文**：禁止悬空依赖，并简化所有上下文语句（如 `with`, `for`），使其行为统一为"弱绑定"，即只填补缺失的定义，不覆盖已有定义。

这个初步方案虽然指明了方向，但在开发者体验和模块化分发的细节上留下了许多问题，整个方案本身也需要论证以寻找最优化方案。

### 第1版方案：确定 Bernard ID / 三层名称层设计，以及 DevEx 初步设计方案

在对初步构想进行审视后，讨论进入了更深层次。此版本旨在解决第1版方案中悬而未决的问题，并为关键决策提供了坚实的论证。

#### 论证：Bernard ID 中间层的必要性

讨论首先明确了一个基础性问题：在 JS 变量名和 Desmos 变量名之间设立一个"Bernard ID"中间层是否是必须的？

结论是：**非常有必要**。

其核心论据是 **JS 变量名的不稳定性**。一个库中导出的表达式对象，在被用户导入时，其 JS 变量名可以被任意重命名，也可以被赋给多个不同的变量。

```javascript
// 'some-library' 中原始的变量名为 'formula'
import { formula as myCoolFormula } from 'some-library';
const anotherVar = myCoolFormula;
```

如果系统依赖 JS 变量名来生成最终的 Desmos 变量名，那么这个过程将是混乱且不可靠的。因此，必须有一个独立于 JS 变量名的、稳定的标识符来唯一地标记每一个"表达式声明"。Bernard ID 正是扮演了这个**"主键 (Primary Key)"**的角色，它将一个公式的**内在身份**和它在代码中临时的**外部称呼**进行了解耦。

#### 配套方案：尽力可读的命名策略

在肯定了 Bernard ID 的基础上，讨论确认了最终生成 Desmos 名称时的策略——**默认可读，并把选择权交给用户**。

1.  **默认可读**：系统应尽最大努力，根据 Bernard ID 生成人类可读的 Desmos 名称（例如，将 `myLib.vector` 转换为 `m_yLib_vector`）。这对于"IDE-浏览器"对照调试至关重要。
2.  **冲突自动解决**：当出现命名冲突时，系统必须自动解决，例如通过添加数字后缀（`v_1`, `v_2`）。
3.  **提供压缩选项**：允许用户在最终发布时选择"压缩/混淆"模式，将所有变量名替换为 `a_1, a_2, ...` 等最短形式，以优化性能或URL长度。

#### 配套方案：初步的协作与 API 设计

为解决跨库协作的命名冲突问题，此版本提出了一套基于"命名空间"的 API 设计。

*   **隐式与显式 ID**：在日常使用中，``const c = expl`...` `` 会借助预处理器的能力**隐式地**将 `"c"` 作为 Bernard ID，即通过 JS 变量名（层）自动确定 Bernard ID（层）。对于库作者，则提供了 `.id("vector.magnitude")` API 来**显式地**指定一个更规范的 ID。
*   **`namespace` 函数**：为了从根源上避免来自不同库的 ID 冲突，设计了一个 `namespace` 函数。库的作者在发布时，可以将所有导出项用此函数包裹，从而为它们统一添加一个唯一的ID前缀。

```javascript
// my-awesome-lib/index.js
import { namespace } from 'bernard';
import { magnitude } from './vector'; // ID: "vector.magnitude"
import { dotProduct } from './algebra'; // ID: "algebra.dotProduct"

// 将库里的所有公式封装在一个 "my-awesome-lib" 命名空间下导出
export default namespace("my-awesome-lib", [
    magnitude,
    dotProduct
]);
```

对于库的使用者，其代码示例如下：

```javascript
// other-project/main.js
import awesomeLib from 'my-awesome-lib';
import { expl } from 'bernard';

// 这个公式的 Bernard ID 是 "local.myVec"
const myVec = expl`...`.id("local.myVec");

// awesomeLib 已经被命名空间包裹
// 最终 Bernard 会知道它内部的 magnitude 的完整 ID 是 "my-awesome-lib:vector.magnitude"
const len = awesomeLib.magnitude(myVec);
```

当最终编译时，`magnitude` 的全局唯一 ID 将变为 `my-awesome-lib:vector.magnitude`，从而避免了与其他库的冲突。这样，在最终编译时，Bernard 会看到一个全局唯一的 ID 树，从而确保**绝对不会有冲突**。

*   `local.myVec`
*   `my-awesome-lib:vector.magnitude`
*   `my-awesome-lib:algebra.dotProduct`

> 注：在整个聊天记录/讨论过程中，关于 "库作者" 和 "库使用者" 的概念一直没有清晰或者确定的称呼，有时称为 "上/下游"，有时称为 "供给方/需求方"，"库编写者/库使用者"，"创作者/使用者"；为了标准化术语，今后统一使用 "库作者" (Library Author) 和 "库使用者" (Library User)。

#### 本版方案总结

综上所述，第1版方案的大致设计内容如下：

1.  **三层命名系统**:
    *   **JS 变量名**: 临时的、上下文相关的别名。
    *   **Bernard ID (主键)**: `string` 类型，全局唯一，由库作者定义，是公式的**真正身份**。
    *   **Desmos 变量名**: 最终产物，由 Bernard 根据 Bernard ID 自动生成，保证可读性并自动解决冲突。

2.  **核心 API**:
    *   ``expr`...` ``: 创建一个可内联的公式片段。
    *   ``expl`...` ``: 创建一个具名声明。
        *   **隐式 ID**: ``const c = expl`...` `` 自动使用 `"c"` 作为 ID。
        *   **显式 ID**: `.id("my-unique-id")` 用于库开发和精确控制。
    *   `namespace("my-lib", [formula1, ...])`: 用于库作者，给一组公式批量加上命名空间前缀，解决跨库冲突。

3.  **编译/导出过程**:
    1.  收集项目中所有的 `expl` 对象，形成一个有向无环图 (DAG)。
    2.  读取每个对象的 Bernard ID。
    3.  根据 Bernard ID 生成一个建议的 Desmos 变量名。
    4.  检查所有建议的变量名是否有冲突，并对冲突项进行自动重命名。
    5.  生成最终的 Desmos 公式列表。

这个新设计保留了初步构想中的好想法，但通过引入"隐式命名"和更清晰的"命名空间"概念，使得 API 在日常使用中更简洁，同时为库作者提供了强大的工具来避免冲突。

### 第2版方案：转向 JS 标准导入导出方式

我们发现尽管第1版的方案在逻辑上是自洽的，但它隐藏了一个关于开发者体验的**致命缺陷**：`namespace` 函数将库的所有导出项打包成了一个单一对象，这会**彻底破坏 IDE 的静态分析能力**。库使用者将无法获得库中单个函数的 JSDoc、类型提示和代码跳转。`namespace` 函数对开发者体验的破坏是不可接受的，因此第2版方案的核心目标就是**在不牺牲IDE静态分析能力的前提下，解决模块化和命名冲突问题**。

这次迭代放弃 `namespace` 函数，使用标准的 `import/export` 模块化方案。

#### DevEx 优先的新工作流

这个新方案的思路是，与其创造一个新的封装机制，不如回归到所有 JavaScript 开发者都已熟悉的标准流程上。

*   **对于库作者**：
    库作者不再需要任何特殊的 `package` 或 `namespace` 函数。他们只需要使用标准的 `export` 关键字导出每一个需要暴露的表达式、函数或常量。为了解决命名冲突，库作者有责任**手动为每一个导出的 `expl` 对象通过 `.id()` 方法提供一个全局唯一的ID**。

    ```javascript
    // file: my-awesome-lib/vector.js
    import { expl } from 'bernard';

    /**
     * Calculates the magnitude of a 2D vector.
     */
    export const magnitude = expl`sqrt(vec.x^2 + vec.y^2)`
        // 关键：作者手动声明一个遵循约定的、全局唯一的ID
        .id("my-awesome-lib:vector.magnitude");
    ```

*   **对于库使用者**：
    库使用者也采用标准的 `import` 语法导入他们需要的模块。

    ```javascript
    // file: my-project/main.js
    import { magnitude } from 'my-awesome-lib/vector';

    // 当鼠标悬浮在 `magnitude` 上时, IDE会完美地弹出 JSDoc 和类型信息。
    const len = magnitude(someVector);
    ```

#### 新方案的优劣势

*   **优势**:
    1.  **完美的IDE支持**：JSDoc、类型提示、代码跳转等功能全部正常工作。
    2.  **零学习成本**：开发者使用他们已经熟悉的 `import/export` 语法。
    3.  **混合导出**：可以轻松地在同一个文件里导出 Bernard 公式、普通 JS 函数等。
*   **劣势/权衡**:
    *   **繁琐且易错**：将保证ID唯一性的责任完全交给了库作者。作者必须为**每一个**导出的表达式手动编写一段长长的、带命名空间的ID字符串。这增加了工作量，也引入了手滑写错的风险，在一定程度上也损害了开发者体验。

#### 补充说明：强制指定真名功能的必要性

在这次讨论中，开发者补充说明了 `.realname()` API 的必要性。它并非一个可有可无的功能，而是解锁特定高级功能的"钥匙"。

一个典型的场景是社区探索出的"键盘输入 hack"技术。该技术依赖于能精确控制在 Desmos 中生成的变量名（如 `w`, `a`, `s`, `d`），以便通过监控用户在特定位置的键盘输入引发 Desmos 计算系统响应、最终引发的特定变量值的变化，来侦测并响应用户的键盘输入。没有 `.realname()` 的能力，这类高级应用将无法在 Bernard 框架内实现。

因此，方案明确了 `.id()` 和 `.realname()` 的分工：
*   `.id()`: 负责设定 Bernard ID，Bernard ID 层作为用户工程体系内部的、全局唯一的**身份**，用于解决模块化冲突。
*   `.realname()`: 负责 **覆盖** Bernard 的自动命名生成器，干涉从 Bernard ID 生成到 Desmos 变量名（"真名"）的过程，优先指定特定表达式的 Desmos 真名，用于实现特殊功能。

#### 命名空间标识符的探讨

针对 Bernard ID 的格式，Monica 补充了解释为什么推荐使用冒号（`:`）作为顶层命名空间的分隔符（如 `my-awesome-lib:vector.magnitude`）。

其主要考虑是**鲁棒性**。由于 npm 包名本身可能包含点（`.`），如果 ID 全部使用点来分隔（如 `my.lib.vector.magnitude`），程序将无法 100% 明确 `my.lib` 是库名，还是库内部的路径。使用一个在 JS 标识符中不合法的字符（如冒号）可以创建一个**绝对无歧义的层级**，清晰地将"库"与"库内路径"区分开。尽管这只是一个约定，但它能提升系统的健壮性。

#### 本版方案总结

第2版方案的核心API和模块化策略如下：

1.  **三层命名系统 (不变)**: JS 变量名 -> Bernard ID -> Desmos 变量名。
2.  **核心 API (优化)**:
    *   ``expl`...` ``, ``expr`...` ``
    *   `.id("unique-id")`: **(强制约定)** 库作者必须为每个导出的 `expl` 设置全局唯一的 Bernard ID。
    *   `.realname("desmos_name")`: **(可选)** 高级 API，用于强制指定最终的 Desmos 变量名。
3.  **模块化与分发 (DevEx 优先)**:
    *   **废弃 `package` 和 `namespace` 函数。**
    *   库作者使用标准的 `export` 关键字导出模块。
    *   库使用者使用标准的 `import` 关键字导入模块。

这个方案成功解决了第1版方案的致命缺陷，将开发者体验（特别是IDE集成）拉回了最高优先级。但它引入了新的问题——手动维护ID的繁琐性，而这正是第3版方案试图解决的核心矛盾。

### 第3版方案：构建时自动化

#### 新的挑战：手动维护 ID 的繁琐性

第2版方案虽然保证了与标准JS生态的兼容性，却把手动维护ID的繁琐工作完全抛给了库作者。开发者很快就意识到，如果需要为库中每一个导出的表达式手动添加类似 `"my-lib:module.sub-module.name"` 这样的长字符串ID，这本身就是一种对开发者体验的损害。

基于这个痛点，开发者提出了新的设想：
*   **抽象化"批量ID操作"**: 是否能提供一种高度抽象化/去语义化的工具，让库作者可以对一组表达式进行"一键添加ID前缀"这样的批量操作，同时模糊掉"包名"域和"包下命名空间"域之间的界限？
*   **利用类型系统传递信息**: 为了避免库作者在每次ID结构变动后，都要去手动更新多处JSDoc，是否能将ID的结构信息编码到类型系统中，让库使用者可以静态地获取这些信息？

#### Monica 的回应：构建时自动化方案

针对开发者提出的"减少手动操作"、"自动化"的核心诉求，AI助手Monica给出了一个方向不同但目标一致的回应方案。其核心理念是"约定优于配置 + 构建时魔法"，即深入强化**构建时预处理器 (Build-Time Preprocessor)**，彻底抛弃"开发者手动编写完整ID"的思路。

*   **理想的开发体验**：
    库作者的开发体验将回归纯粹，只需编写最简单的代码，无需任何 `.id()` 调用：
    ```typescript
    // file: my-awesome-lib/src/vector/math.ts
    import { expl } from 'bernard';

    /** Calculates the magnitude of a vector. */
    export const magnitude = expl`sqrt(v.x^2 + v.y^2)`;
    ```

*   **预处理器的工作流**：
    当库作者运行构建命令时，预处理器会自动扫描源代码，并根据文件结构约定，生成添加了完整ID的"标准形式"代码：
    ```typescript
    // 预处理器在内存中生成的代码
    /** Calculates the magnitude of a vector. */
    export const magnitude = expl`sqrt(v.x^2 + v.y^2)`
        .id("my-awesome-lib:vector/math.magnitude"); // ID被自动注入!
    ```
    ID的生成将遵循一个清晰的约定：`[库名]:[文件路径].[变量名]`。这个机制将开发者已经熟悉的"文件系统结构"作为组织ID的天然方式。同时，`.id()` API依然被保留，作为处理特殊情况、手动覆盖自动生成ID的可选功能。

*   **与类型系统深度集成**：
    该方案还采纳了开发者关于类型系统的设想，并提出了一个更进一步的实现：让预处理器不仅注入ID值，还将ID的字符串字面量**注入到TypeScript的类型系统中**。
    ```typescript
    // 预处理器可以让IDE将magnitude的类型推断为：
    // const magnitude: Expl<"my-awesome-lib:vector/math.magnitude">
    ```
    这将使得库使用者可以通过类型系统静态地、安全地获取到一个表达式的唯一ID，解决了跨模块传递ID信息的问题，相比手动编写JSDoc要可靠得多。

#### 发现新的致命缺陷——不稳定性

尽管这个自动化方案看起来非常优雅，解决了手动维护ID的繁琐问题，但开发者在讨论中敏锐地察觉到了一个新的**致命缺陷：ID的不稳定性**。

这个方案将表达式的**逻辑ID**与它在项目中的**物理文件路径**进行了**硬绑定**。这意味着，如果库作者为了维护代码而重构了项目的文件或目录结构（例如将 `vector/math.ts` 移动到 `math/vector.ts`），那么所有相关表达式的Bernard ID都会随之改变。

这是一种**破坏性变更 (Breaking Change)**。对于所有依赖这些ID的下游库使用者来说，库的一次内部代码重构都会导致他们的代码失效。这违背了"库的内部实现细节不应影响其公共API契约"的重要原则。正是为了解决这个"不稳定性"问题，讨论最终走向了第4版方案。

> 注：从本节开始，我们确立项目中的两组核心术语。
> 1.  **创作形式 (Authoring Form)** 与 **标准形式 (Canonical Form)**：
>     *   **创作形式**指开发者编写的、经预处理器增强的简洁代码（例如，``const c = expl`...` ``）。
>     *   **标准形式**指经预处理器转换后生成的、符合原生JS/TS标准的详细代码（例如，``const c = expl`...`.id('app:c')``），这是系统内部唯一认可的规范化版本。
> 2.  **ID 段 (ID Segment)**：
>     *   指构成完整 Bernard ID 的、由点号（`.`）或冒号（`:`）分隔的各个组成部分。例如，在 `my-lib:vector.magnitude` 中，`my-lib`、`vector` 和 `magnitude` 都是 ID 段。
> 3.  **ID 路径 (ID Path)** 与 **名称段 (Name Segment)**：
>     *   一个完整的 Bernard ID 由一个 **ID 路径**和一个**名称段**组成。**ID 路径**指 ID 中除最后一段外的所有前置部分，代表其逻辑位置；**名称段**则指 ID 的最后一段，通常由表达式创建时的"JS变量名隐式确定"功能决定。
>     *   例如，在 `my-lib.vector.magnitude` 中，`my-lib.vector` 是 **ID 路径**，而 `magnitude` 是 **名称段**。

### 第4版方案：动态、可塑与工具增强

第3版方案中"ID与物理文件路径硬绑定"所带来的不稳定性，促使开发者进行了一次彻底的范式转变。开发者指出，库作者在重构代码时不应意外地破坏对下游用户的API契约，因此，**一个健壮的系统必须允许库作者构建一个与物理文件结构脱钩（异构）的、稳定的逻辑ID体系**。

这个核心诉求，引发了一系列连锁的关键决策，最终形成了第4版方案，其核心是：**拥抱命令式编程的动态性，并通过外部工具链（IDE插件）来弥补静态类型系统留下的空白，以换取ID体系的稳定性和更高的灵活性**。

#### 核心抉择：拥抱可变 API (Mutable API)

为了让库作者能方便地构建和维护与文件结构异构的ID体系，必须提供"批量ID操作"的工具。此时，一个关键的技术抉择摆在面前：这些操作API应该是**不可变的（Immutable）**还是**可变的（Mutable）**？

*   **不可变 API 的困境**：如果API是不可变的（例如，`idprepend` 操作返回一组全新的表达式对象），那么对象之间的引用关系将会被破坏。
    > 例如，表达式 `b` 依赖于表达式 `a`。如果对它们进行批量ID操作 `group({a, b}).idprepend('mylib')` 会返回全新的 `mylib.a` 和 `mylib.b` 对象，那么新的 `mylib.b` 内部引用的仍然是旧的 `a` 对象，而不是新的 `mylib.a`，从而导致依赖关系错乱。

*   **开发者的决断**：为了维护表达式在进行ID操作时内部依赖关系的正确性，开发者明确选择**采用可变API**。这意味着 `idprepend` 等操作将**直接修改**传入的表达式对象本身（例如，在其内部追加一个ID转换规则），而不是创建新对象。

#### DevEx 的新路径：放弃类型系统，探索 Volar / IDE 插件能力

选择可变API的直接代价是，**无法再将动态变化的ID信息编码到静态的TypeScript类型系统中**。一个对象的类型将始终是 `Expl`，IDE无法在编译时知道其最终的ID。

为了解决由此带来的开发者体验问题（库使用者无法方便地获知ID），开发者提出了一条全新的路径：**通过一个强大的IDE插件（基于Volar）来增强DevEx**。

*   **动态计算与信息悬停**：IDE插件可以在库使用者将鼠标悬停到某个导入的表达式变量上时，**动态地、实时地**计算出其最终的Bernard ID，并将其显示在一个自定义的悬停窗口中。
*   **可定制的悬停信息**：为了给库作者最大的自由度并优化性能，方案设计了 `.hoverInfo()` API。库作者可以为表达式提供一个函数，用来自定义其悬停提示的内容，这比静态的JSDoc要灵活和强大得多。

#### 关键 API 与设计模式

基于以上原则，方案明确了一套面向命令式、动态编程的API和推荐模式。

*   **`group` 与批量 ID 操作**

    `group` 是一个核心辅助函数，用于将一组离散的表达式对象（或 `expr builder`）聚合为一个逻辑单元，以便进行后续的批量ID操作。这是库作者构建其逻辑ID树的主要工具。

    在其基础上，方案提供如 `.idprepend(segment: string)` 这样的可变API，它会接受一个ID段（`segment`）并将其作为前缀添加到 `group` 内所有对象的ID路径中，通过直接修改对象本身来完成操作。

    ```javascript
    // 示例：在一个物理模拟库中
    const physics = group({
        initialPosition,
        velocity,
        gravity,
    }).idprepend('physics');
    // 此操作会直接修改 initialPosition, velocity, gravity 对象
    ```

    对于 `group` 操作后的导出，向库作者推荐两种模式：
    1.  **非扁平导出**：将 `group` 的结果作为一个整体对象导出。这是最简单直接的方式。
        ```javascript
        export default physics;
        ```
    2.  **扁平导出**：如果库作者希望将组内的每个变量重新作为独立的顶级导出项，可以使用解构赋值的方式。这要求原始变量使用 `let` 而非 `const` 声明。
        ```javascript
        let { initialPosition, velocity, gravity } = physics;
        export { initialPosition, velocity, gravity };
        ```

*   **DevEx 增强：通过 `.hoverInfo` 定制悬停提示**

    为了弥补放弃静态类型系统所带来的信息损失，方案的核心是通过IDE插件提供信息悬停。`.hoverInfo(callback)` API 允许库作者为表达式或 `expr builder` 自定义此功能。

    它接受一个回调函数 `callback: (info) => string`，该回调函数接收一个包含了制作提示信息所需的全部数据和工具函数的 `info` 对象，并返回一个字符串作为最终的提示内容。
    *   **`info` 对象详解**:
        *   `id: string`: 表达式在当前状态下计算出的**最终ID**。
        *   `realname: string | undefined`: 通过 `.realname()` 强制指定的最终Desmos变量名。
        *   `idInitial: string`: 表达式未经任何批量ID操作修改前的**初始ID**。
        *   `idDrvs: (initialId: string) => string`: 一个函数，封装了此对象经历过的**所有ID变换**（`drv` 意为 derivations）。它可以将一个初始ID转换为最终ID，库作者可以用它来向使用者展示ID的变换逻辑。
        *   `makeDefaultInfo: (id, realname, additionalInfo) => string`: 一个辅助函数，用于方便地生成默认格式的悬停提示字符串，并支持附加额外信息。

*   **`expr builder` 提升为一等公民**

    为了支持参数化生成等高级动态场景，方案将"表达式构造器" (**expr builder**) 提升为一等公民。`builder(callback)` API用于创建一个 `expr builder`，它接受一个回调函数，该回调函数自身需要返回一个可被用户调用的、用于生成表达式的函数。即：`builder((idDrvs: (initialId: string) => string) => ((...) => {...}))`。

    为了让 `builder` 能够正确响应外部的批量ID操作，外层回调会接收一个 `idDrvs` 函数 (`(initialId: string) => string`)。`builder` 的内部逻辑必须使用这个 `idDrvs` 函数来处理所有它生成的表达式的ID，从而正确应用外部通过 `group` 等方式施加的ID变换。

#### 本版方案总结

第4版方案是一个范式转变，其核心技术细节如下：

1.  **核心原则**:
    *   **拥抱可变性**: API 设计为**可变的 (Mutable)**，ID 操作直接修改对象自身，以在批量操作中维持对象间的依赖引用关系。
    *   **ID 体系与文件结构解耦**: 库作者负责主动维护一个稳定的、与物理文件结构**异构**的逻辑 ID 体系。
    *   **工具链增强 DevEx**: 放弃在静态类型中编码所有信息，转而依赖**外部 IDE 插件（Volar）**来动态计算和展示信息，以提升开发者体验。

2.  **核心 API**:
    *   `group({ a, b, ... })`: 核心辅助函数，用于将表达式或 `builder` 聚合为逻辑单元，以进行批量操作。
    *   `.idprepend(segment)` 等可变 ID 操作 API: 直接修改 `group` 内所有对象的内部状态，为其 ID 路径添加前缀。
    *   `builder(callback)`: 将动态表达式构造器提升为一等公民，使其可以无缝参与批量 ID 操作。
    *   `.hoverInfo(callback)`: 允许库作者为表达式或 `builder` 提供自定义函数，用于在 IDE 插件中生成动态的悬停提示信息。

3.  **开发者工作流**:
    *   库作者使用 `group` 和 `.idprepend` 等 API 构建逻辑 ID 树，然后使用标准 `export` 导出（可选择扁平或非扁平模式）。
    *   库使用者使用标准 `import` 导入，并通过 IDE 插件获得 ID、文档等增强信息。

## 对先前方案的思考与更新 (251013)

### 第4版的API命名调整

- `idprepend` -> `idPrepend`
- `makeDefaultInfo` (in `hoverInfo: (info: {makeDefaultInfo: (id: string, realname: string, additionalInfo: string) => string, ...}) => string`) -> `mkDefaultInfo: (id: string, realname: string, additionalInfo: string) => string`

### 对第4版的补充思考

#### 关于 `group` , 导出 pattern 与 DevEx

`group` 的引入一定程度上也相当于重新使用了第1版里的一些设计，包括之前被认为会阻碍 IDE 悬浮提示进而影响 DevEx的 package/namespace 这种设计（扁平模式下依然使用标准 export，但我们无意间也给库作者留下了非扁平导出，这种等效于第1版设计的选择）。

"扁平导出"即对应在标准 export 语法下分项导出，而"非扁平导出"即对应在标准 export 语法下的一个对象/字典下分项导出。

只有在标准 export 语法下分项导出才能打通 IDE 引用追溯、进而进行 IDE 悬浮提示的"通道"，而我们同时设计的 hoverInfo() custom hoverInfo evaluator 的功能也依赖于这个通道存在才能正常工作。

（不过似乎也能在非扁平导出模式下让 hoverInfo() custom hoverInfo evaluator 的功能正常工作，但需要实验，比如导出`group1`对象后导入它时是否可以在`group1.exprA`上触发悬浮提示并激活我们的语言支持功能，追溯到 custom hoverInfo evaluator 对象，最终进行 hoverInfo 的计算。）

现阶段先不考虑非扁平导出模式的 DevEx 支持，等到后面再考虑。

#### 关于批量 id 操作

id 变换是链式累积的，比如一个被 `group1` 选中的表达式（id: "exprA"）经历了 `group1.idPrepend('nsInner').idPrepend('nsOuter')` 两次 ID 变换，那么它的最终 ID 就是 `nsOuter.nsInner.exprA`。

id 段分隔符还是选择全部使用 `.`。（见下文讨论）

### 继续设计

#### 抉择：ID 段分隔符，是首段使用 `:` 还是全部使用 `.` ？ -> 统一使用 `.`

在对 ID 路径的构建方式进行深入讨论后，我们最终决定采用一个更简洁、更统一的方案：**在 Bernard ID 中，所有 ID 段 (ID Segment) 均统一使用点号 (`.`) 作为分隔符**。

这个决策的核心是**追求 API 的简洁性和概念的纯粹性**。

我们曾探讨过一个备选方案，即使用冒号 (`:`) 来分隔"顶级命名空间"（通常对应 npm 包名），用点号 (`.`) 分隔库内路径（如 `my-lib:vector.magnitude`）。这个方案的优点是鲁棒性强，即使 npm 包名包含点号也能清晰区分。

然而，这种方案的代价是引入了两种语义不同的分隔符，这将不可避免地导致 API 的复杂化——我们需要引入一个特殊的、"封顶"性质的 ID 操作（例如 `idSeal()`）来添加带冒号的前缀，这与第4版方案"拥抱简洁动态"的核心原则相悖。

因此，我们选择"纯点号"方案，其优势在于：

1.  **API 极度简洁**：只需要一个 `.idPrepend()` 方法即可完成所有 ID 路径操作。ID 变换的逻辑统一且易于理解。
2.  **概念单纯**："ID 段"是一个无特殊语义、可任意组合的原子单元，整个 ID 体系更加灵活和简单。

这个方案也带来一个权衡：它向库开发者提出了一个额外的较小的**约定**。为了让 Bernard ID 的顶级名称与 npm 包名能轻松保持一致，我们**建议**库作者在发布 npm 包时**避免在包名中使用点号**。如果库作者的包名确实无法避免地包含了点号，他们则需要手动选择一个不含点号的顶级 ID（例如 `my-lib` 而非 `my.lib`）并在自己的库文档中向使用者明确说明。

我们认为，**API 的长期简洁性和易用性**远比"自动处理少数边缘场景"的便利性更为重要。用一个轻度的约定，换取一个对所有开发者都更简单、更纯粹的系统，是值得的。

#### DevEx 设施 / 工具链梳理

Bernard 项目的开发者体验 (DevEx) 由一个分工明确、协同工作的工具链体系支撑。

*   **核心能力模块**
    *   **预处理器 (Preprocessor)**: 这是一个核心的"幕后"能力模块，负责将开发者编写的、简洁的 **"创作形式 (Authoring Form)"** 代码，转换为系统内部使用的、信息完备的 **"标准形式 (Canonical Form)"** 代码。它本身不直接面向开发者，而是作为一项基础能力被其他工具调用。

*   **开发者工具集成**
    *   **Vite 插件 (Vite Plugin)**: 在 Vite 构建或开发服务器运行时，调用**预处理器**，对项目源码进行实时转换。
    *   **Volar 语言服务 / IDE 插件**: 在代码编辑器中实时调用**预处理器**的分析功能，为开发者提供诸如 悬停信息动态计算（id预览性动态计算）、自动补全等丰富的代码智能体验。
    *   **`create-bernard` CLI**: 一个命令行工具，用于快速搭建 Bernard 项目骨架，预设好所有配置。
    *   **Desmos Canvas 集成模块**: 未来用于将 Bernard 的开发体验无缝集成到 Desmos Canvas 环境中的一系列模块（具体形态待明确）。

*   **底层框架与工具**
    *   **Vite**: 在用户端作为项目构建、打包和运行开发服务器的基础工具。
    *   **Volar**: 作为开发 IDE 插件和语言服务的底层框架。

#### 开发场景梳理

我们梳理了以下几种核心的开发场景，并明确了在 Library 思路下，开发者与之交互所使用的具体 Vite 命令。

1.  **程序化图表构建 (Programmatic Graph Build)**
    *   **描述**: 在 JavaScript 运行时（如 Node.js 或浏览器应用）中，直接调用 Bernard 库提供的 API 来动态构建图表。这个场景的特点在于它不依赖 Vite 插件等构建时工具，不是使用指令构建，而是调用 JS API 来构建。
    *   **产物**: 内存中的 Desmos State Object。

2.  **宿主应用构建 (Host Application Build)**
    *   **描述**: 这是"程序化图表构建"的一个衍生场景。当开发者在一个会被 Vite 打包的宿主应用（如一个前端项目）中，以"创作形式"编写图表构建逻辑，并使用 JS API 来动态构建图表时，依然需要 Vite 插件在宿主应用构建阶段介入，对这部分代码进行预处理。
    *   **产物**: 宿主应用的一部分，内含被正确处理的 Bernard 逻辑。
    *   **命令**: `vite build`

3.  **静态图表构建 (Static Graph Build)**
    *   **描述**: 开发者编写一个或多个定义图表的源文件，并通过命令行调用 Vite 构建指令，将这些源文件编译成一个独立的、可分发的 Desmos State JSON 文件。
    *   **产物**: `.desmos.json` 格式的 Desmos State 文件。
    *   **命令**: `vite build --mode graph`

4.  **公式库开发与打包 (Expression Library Development & Packaging)**
    *   **描述**: 库作者创建一套可复用的公式、函数或图表组件，并利用 Bernard 的模块化和命名机制进行组织，最终通过 Vite 打包成一个标准的 npm 包进行分发。
    *   **产物**: 一个 npm 包。
    *   **命令**: `vite build` (配合 `vite.config.js` 中的库模式配置)

5.  **图表实时预览与开发 (Live-Preview Graph Development)**
    *   **描述**: "静态图表构建"的衍生场景，开发者在本地运行一个由 Vite 驱动的开发服务器。当修改图表源代码时，可以在浏览器中实时看到更新后的图表预览，享受所见即所得的开发体验。
    *   **产物**: 一个本地运行的、带实时预览的 Web 服务。
    *   **命令**: `vite dev --mode graph`

6.  **Desmos Canvas 中开发 (Development in Desmos Canvas)**
    *   **描述**: 在 Desmos Canvas 的画布环境中，通过内嵌的代码节点和图表预览节点，实现 Bernard 代码的编写、运行与可视化，形成一个闭环的、可视化的编程体验。
    *   **产物**: Desmos Canvas 中的 Bernard JS 对象数据、Desmos State Object 数据，以及一些调试服务。

#### 抉择：是否开发自己的 CLI ? -> 不开发全能 CLI，只开发一个轻量级脚手架工具

在工具链的讨论中，我们深入探讨了是否应该为 Bernard 创建一个自定义的命令行工具（CLI），例如 `bernard build`，来封装底层的 Vite 调用。

##### 两种思路的权衡

1.  **Toolkit 思路 (自定义 CLI)**:
    *   **定位**: 提供一个高度集成、自成体系的"工具集"，可以类比 **Next.js** 框架。
    *   **优势**: 提供一个 `bernard` 命令可以统一用户体验，将 Vite 作为实现细节隐藏起来，并且能内置最佳实践，实现零配置启动。
    *   **劣势**: 增加了额外的抽象层和维护成本，且与现代前端生态中"拥抱通用工具（如 Vite）"的趋势相悖。

2.  **Library 思路 (Vite 插件优先)**:
    *   **定位**: 将 Bernard 作为一个标准的 JavaScript 库和 Vite 插件，可以类比当前的 **React / Vue** 框架。
    *   **优势**: 完全拥抱 Vite 生态，开发者使用他们已经熟悉的 `vite` 命令，学习成本低，灵活性和透明度最高。
    *   **劣势**: 对于新手来说，可能需要手动配置 `vite.config.js`，存在一定的上手门槛；可以通过辅以一个脚手架工具来解决这个问题。

##### 最终决定：采纳 Library 思路，辅以一个轻量级脚手架工具

我们最终采纳了开发者的观点，决定采纳 **Library 思路**，而非创建一个封装 Vite 的重量级 CLI。这一定位更类似 React (`@vitejs/plugin-react`) 或 Vue (`@vitejs/plugin-vue`)，它们作为生态中的一环与 Vite 等通用工具协同工作；而不是像 Next.js 那样提供一个高度集成、自成体系的 Toolkit。Bernard 的核心定位缩小为一个 JS 库和一个 Vite 插件（或者未来下一代构建工具的插件），给使用者更多"白盒"视野。

同时我们将提供一个独立的脚手架工具 `create-bernard` (通过 `npm create bernard@latest` 使用)，以解决 Library 思路在上手便利性上可能存在的不足。这个工具的**唯一职责**是根据用户的选择（例如"创建一个公式库"或"创建一个静态图表项目"），快速生成一个预设好 `vite.config.js` 和 `package.json` 的项目模板。这个模板中的脚本将直接使用标准的 `vite` 命令。

这个策略削减了 Bernard 的工作范围，将脚手架创建服务独立出来，既为需要灵活性的高级用户和应用集成者提供了"Library"形态的 Bernard，也通过脚手架为新用户提供了"一键启动"的便利。

## 251017 讨论：工程化与多版本并行开发方案

为了支持默认模式下多个探索性方案（如ID可变版、ID不可变版、类JSX版等）的并行开发，我们决定采用 **Monorepo** 架构，并使用 **pnpm workspaces** 作为核心管理工具。这套方案允许我们在一个代码库中维护多个独立的、可互相引用的包，同时保持清晰的结构和高效的依赖管理。

### 核心目录结构

项目将在 `Bernard.js` 文件夹下采用一种按功能划分的、多层级的目录结构，取代传统的单一 `packages` 文件夹模式。这种结构通过顶层文件夹对不同类型的包进行了语义上的分组，使代码库的意图更加明确。

```plaintext
.
├── shared/
│   # 存放所有版本和模块共享的通用代码包
│   ├── core/      # @bernard/core: 核心数据结构、算法等
│   ├── types/     # @bernard/types: 共享的TypeScript类型定义
│   └── preprocessor/ # @bernard/preprocessor: "创作形式"到"标准形式"的代码预处理器
│
├── variant-drafts/
│   # 存放所有并行的、探索性的Bernard.js核心实现
│   ├── v-mutable/  # @bernard-variant/v-mutable: 可变ID方案
│   └── v-immutable/ # @bernard-variant/v-immutable: ID不可变方案
│
├── facade/
│   # 存放最终面向用户的、作为"门面"的包
│   ├── bernard/               # bernard: 主库包, 重新导出某个variant
│   ├── vite-plugin-bernard/   # vite-plugin-bernard: 配套的Vite插件
│   └── create-bernard/        # create-bernard: 项目脚手架CLI
│
├── tooling/
│   # 存放开发时辅助工具，如IDE插件
│   ├── language-server/ # @bernard/language-server: Volar语言服务核心
│   └── vscode-extension/  # bernard-vscode: VS Code插件封装
│
├── package.json               # Monorepo 根目录的 package.json
└── pnpm-workspace.yaml        # pnpm 工作区的配置文件
```

### pnpm Workspaces 配置

为了让 pnpm 能够识别并管理上述结构中的所有包，根目录下的 `pnpm-workspace.yaml` 文件将进行如下配置：

```yaml
packages:
  # 告诉 pnpm 去这几个文件夹下寻找所有的子包
  - 'shared/*'
  - 'variant-drafts/*'
  - 'facade/*'
  - 'tooling/*'
```

### 版本切换与默认导出机制

`facade/bernard` 包是最终发布给用户的主包 `bernard`，它本身不包含核心实现。它作为一个"代理"或"门面"，其唯一职责是选择一个 `variant-drafts` 中的实现，并将其API重新导出。

通过修改 `facade/bernard/package.json` 中的依赖项，就可以切换整个项目对外暴露的"默认版本"，例如：

```json
{
  "name": "bernard",
  "dependencies": {
    // 当前选择 v4-mutable 作为默认实现
    "@bernard-variant/v4-mutable": "workspace:*"
  }
}
```

同时需要修改 `facade/bernard/src/index.ts` 文件，将默认导出改为选择一个 variant 包的导出。
```typescript
export * from "@bernard-variant/v-mutable";
```

这种结构为项目的多方案探索提供了强大的工程化支持，保证了不同版本开发的隔离性、代码共享的便利性以及最终版本发布的灵活性。

### 依赖关系流

我们将包组织在不同的顶级目录中，整个 monorepo 内存在一个依赖关系图。

我们可以建立一个大致的**分层心智模型**来理解主要的依赖方向：
1.  **`shared/` (最上游)**: 提供最基础的、无依赖的工具和类型。
2.  **`variant-drafts/`**: 依赖 `shared/` 中的包，实现各种核心逻辑。
3.  **`facade/`**: 依赖 `variant-drafts/` 中的某个具体实现。
4.  **`tooling/` (最下游)**: 依赖 `facade/` 中的主包 `bernard` 来获取API信息。

然而，存在必要且健康的**跨层依赖**。例如：
- `vite-plugin-bernard` (`facade/`) 和 `@bernard/language-server` (`tooling/`) 都需要直接依赖 `@bernard/preprocessor` (`shared/`) 来处理用户代码。

只要我们避免出现循环依赖，这种灵活的DAG结构就是非常健壮的。

## 201019 讨论

### 关于 API 可变 / 不可变设计的说明

我们再明确一下 Bernard 种不同数据的可变性/不可变性。表达式的数学内容和上游依赖关系是**不可变的**，我们故意封闭了一些能力，这样就可以保证"上游表达式一定比下游先创建"的时间关系，以实现默认模式的主要目的，避免悬空依赖。这种设计从根本上保证了计算图的稳定性和可预测性。

与之相对，表达式的 ID 和 样式（尚不明确，见下文）等数据，则被设计为**可变的**，这样我们可以在不破坏计算逻辑的前提下，灵活地对表达式进行组织和样式化。当然代价是，如果不把不可变性设计延伸到 ID 部分上，那么就无法通过类型系统有效追踪基于 id 的依赖关系数据。不过如我们前文提过的，我们通过多种方式缓解这个问题，而且现在看来这种高层次的类型系统也不一定是我们所需要的了。

### 关于两类公式属性的可变性设计

目前已知的两种公式属性包括 Slider 属性和显示属性。通过对 Desmos 行为的实验和分析，我们发现 Slider 属性和显示属性在依赖关系上的行为和性质不同，这直接指导了我们的 API 设计。

我们可以用两种等价的表征来描述这个现象：

1.  **双依赖图表征**：这是最能体现其行为差异的模型，模型拆分为两部分依赖图：
    *   **计算依赖图 (Calculation DAG)**: 这是一个严格的、禁止循环的依赖图。它包含了公式的数学内容，**Slider 属性** (`min`, `max`, `step`)也被包含在这里面，任何在此图上产生循环依赖的操作都会导致 Desmos 报错。因此，这部分对应的 API 必须设计为**不可变的**。
    *   **可视化依赖图 (Visualization DAG)**: 这是一个次级的、更宽松的图。它包含所有**显示属性**（颜色、线宽、点大小等）和**标签内容**。这个图的更新发生在计算图完成之后，它所依赖的是计算图的**最终输出值**，而非其结构。因此，它允许出现看似循环的依赖（例如，`n` 点的大小依赖 `m` 点的位置，`m` 点的大小也依赖 `n` 点的位置），是合法的。这部分对应的 API 可以被设计为**可变的**。

2.  **分层节点表征**：这是从单个公式节点的内部结构出发的模型。
    *   一个顶层的"公式节点"下辖两个子节点：
        *   **内容定义节点**：包含符号名、数学表达式和 **Slider 属性**。所有跨公式的计算依赖都指向这类节点，而非公式节点本身。
        *   **元数据节点**：包含**显示属性**和标签等。它们间接或最终依赖内容定义节点，但没有反向决定计算图的边，所以不会产生循环依赖。

这两种模型都导向了同一个结论：Slider 属性必须在表达式创建时定义且不可变，而显示属性可以在创建后自由、动态地修改。

### Slider 属性的不可变 API 设计

基于其不可变的特性，Slider 属性不适合使用链式方法进行修改。我们决定将其作为表达式定义的一部分，在 `Expr DSL` (表达式领域特定语言) 中进行声明。

在这次讨论中，我们正式确立了 **`Expr DSL`** 这个术语，用以指代在 `` expl`...` `` 的反引号内编写的、遵循 Desmos 语法的微型语言。

为了在 DSL 中定义 Slider，我们引入一个分隔词，将主表达式与 Slider 定义分开。经过讨论，我们最终选择 `in` 作为分隔词，因为它语义清晰且在 Desmos 的数学语境中几乎不会产生冲突。

```javascript
// 语法: expl`[表达式] in [最小值] : [步长] : [最大值]`
const n = expl`1 in 0 : 0.1 : 10`;
```

### 显示属性的可变 API 设计

显示属性的设计过程经历了一次从"最大化灵活性"到"聚焦于核心体验"的迭代。

###### 初步构想：一个全能的 API 表面

开发者最初设想了一套极度灵活的 API，希望 `expr.style` 及其所有子属性都能同时作为数据容器、可调用函数和拥有完整CRUD方法的 Fluent API 入口。

```javascript
// 开发者设想的"全能"API 的部分示例
expr.style.set({point: ...});
expr.style.point.edit(p => ...);
expr.style.point(p => ...);
expr.style.point = { size: 10 };
expr.style.deletePoint();
```

这个方案的优点是为用户提供了无与伦比的自由度：
*   支持在任意位点上进行链式调用；
*   链式调用可以完成全部类型的任务；
*   对象本体可序列化，而通过`draft()`再转为editor对象；

但很快我们便意识到其缺点更为致命：
*   **API 表面积巨大**：过多的选择会让用户困惑，没有方向感和信心选择路径。
*   **概念模糊**：API 对象的"身份"不清晰，是数据还是接口？
*   **实现复杂**：要完美地实现这样一个在所有情况下都表现正确的全能 Proxy，成本极高。

###### 精炼方案：读写分离与 Editor 模式

为了解决上述问题，AI助手提出了一个更聚焦、概念更清晰的**读写分离**方案：

1.  **术语确立**: 我们正式将用于修改样式的交互句柄称为 **`Editor`**。这个术语比 `Draft` 更准确，因为它强调了操作的**即时性**和**同步性**，避免了与 Immer 等库产生错误类比。

2.  **核心原则**:
    *   **读取**: `expr.style` 及其子属性 (`expr.style.point.size`) 作为**只读的数据访问器**。它们返回纯净的数据，可以被安全地读取和序列化。
    *   **写入**: 所有修改操作都通过**函数式回调**来启动（`expr.style(s => { ... })`），这些方法会提供一个功能强大的 `Editor` 对象。

3.  **TS 类型实现**: 我们确认了在 TypeScript 中完全可以实现一个"既是可调用函数，又拥有自己属性"的混合类型对象，这为 `Editor` 的设计提供了坚实的类型基础。
    ```typescript
    // 通过带有调用签名的接口，可以精确定义 Editor 类型
    interface PointEditor extends PointStyle {
        (updater: (p: PointStyle) => void): void; // 调用签名
        set(style: PointStyle): void;             // 其他方法
        delete(): void;
    }
    ```

优点：
*   概念清晰；
*   API表面积可控；
*   依然保留全能能力，但被封装在editor下；
*   实现稍微简单一些；

缺点：
*   API表面积可能过小，需要再提供一些少量的快捷方式；

###### 抉择：将 Editor 限制在回调里，还是允许直接访问？

我们发现这个方案里 `Editor` 只能在回调函数中使用，没有可以在外部获取 Editor 对象的设计。是否应该允许用户获取一个 `Editor` 对象并在回调函数之外长期持有它？

经过深入的权衡，我们决定**不提供**直接访问或暴露 `Editor` 对象的途径，而是将其严格限制在回调函数的作用域内。这一决定可以保证 API 的**事务性清晰度**和代码的长期可维护性，同时避免了状态错乱和bug。

*   **优点（保持现状）**:
    1.  **事务性清晰**: `expr.style(editor => { ... })` 代码块像一个"事务"，所有相关的修改都集中发生于此，极大地提高了代码的可读性和可预测性。
    2.  **避免状态错乱**: 防止了因长期持有"陈旧"的 `Editor` 对象而引发的各类状态覆盖或不一致的 bug。回调模式确保了开发者拿到的永远是针对当前状态的"新鲜" `Editor`。
    3.  **引导优良实践**: 鼓励开发者将相关的修改逻辑组织在一起，而不是将可变对象在应用中到处传递。

*   **解决方案：鼓励函数式组合**:
    为了解决在复杂场景下（如跨函数、条件性应用样式）的灵活性问题，我们不暴露 `Editor` 本身，而是鼓励用户**组合"操作 Editor 的逻辑"**。开发者可以将样式修改逻辑封装在独立的、可复用的纯函数中，然后在回调中按需调用和组合它们。

    ```javascript
    // 示例：将逻辑封装成可复用的"样式更新函数"
    const applyDarkMode = (labelEditor) => {
        labelEditor.color = 'white';
    };
    
    // 在回调中按需组合
    myPoint.style(s => {
        if (isDarkMode) {
            applyDarkMode(s.label); // 将子 Editor 传入更新函数
        }
    });
    ```
    这种**函数式组合**的模式，在不破坏"事务性清晰度"的前提下，完美地解决了对高级灵活性的需求，是一个两全其美的方案。

###### 最终方案：兼顾简洁与便利

在"读写分离"的核心原则之上，我们为 API 增加了一些便利的快捷方式，形成了最终方案：

1.  **核心修改入口**: `expr.style(editor => { ... })` 是功能最全的入口，它提供一个 `Style Editor`，允许用户在回调函数中进行任意复杂的、多层次的修改。

2.  **便利快捷方式**:
    *   **一级属性操作**: 为常用的一级属性（如 `point`, `label`）提供直接的修改方法，如 `expr.point(editor => { ... })`，以减少代码嵌套。
    *   **对象合并操作**: `expr.style({ point: ... })` 和 `expr.point({ size: 10 })` 接受一个对象，并将其与现有样式进行**深层合并 (Deep Merge)**，作为 `edit/update` 语义的简便写法。`set/rewrite` 语义则不设计简便写法。换种角度说我们选择了把这个快捷入口留给了 edit 语义而非 set/rewrite 语义，以期用户更常使用 edit/update 功能。

3.  **`Editor` 对象的设计**:
    *   **混合类型**: `Editor` 的子属性（如 `editor.point`）本身也是一个 `Editor`，既可以读取其下的属性（`editor.point.size`），也可以作为函数调用（`editor.point(p => ...)`），还可以调用其方法 (`editor.point.set(...)`)。
        * 同时这使得 `Editor` 可以模拟为其上层 field 的 "可链式调用的方法"，对链式调用写法友好。
    *   **安全的深层路径创建**: `Editor` 对象本身就具备类似 `draft` 的能力。当访问一个不存在的属性时（如 `editor.a.b.c`），它会自动创建路径上的中间对象，从而避免了繁琐的空值检查，并提供"增删改查"的"增加"功能。
    *   **数据导出**: 提供 `.toJSON()` 方法，允许从 `Editor` 中获取一个纯净、可序列化的数据对象。甚至能被 `JSON.stringify()` 直接调用，方便序列化。
    *   **赋值 API**: `editor.field = value;` 可以实现全量编辑功能（set/rewrite）。功能相同的方法式 API 为 `editor.field.set(value)`.
    *   **删除 API**: `delete editor.field;` 可以删除一个属性。功能相同的方法式 API 为 `editor.field.delete()`. 注意它不能通过 `editor.field = undefined` 或 `editor.field = null` 来实现，因为这会触发 set 语义，而不是 delete 语义。
    *   **可调用体(Callable) API**: `editor` 本身可以作为函数调用，具备两种调用签名：
        *   `editor(e: Editor => void) => upperField / StyleEditor` （粗略写法） 在回调里再次提供 editor 对象，允许用户在回调函数中进行操作。返回值为上层 field的 editor 对象，如果本身是顶级 StyleEditor 对象则返回执行操作后的自己，方便继续操作。
        *   `editor(fieldPartial: Partial<SomeFieldType>) => upperField / StyleEditor` 接受一个对象，作为 `edit/update` 语义的简便写法。返回值为上层 field的 editor 对象，如果本身是顶级 StyleEditor 对象则返回执行操作后的自己，方便继续操作。

这个最终方案通过明确的读写分离和分层的 API 设计（核心入口 + 便利快捷方式），在 API 的简洁性、灵活性和概念清晰度之间取得了理想的平衡。