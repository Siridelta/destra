# Desmos 系统分析 (核心重构版)

> 本文档旨在为 Bernard 项目提供一个清晰、准确且可操作的 Desmos 系统行为模型。它基于实际的实验观察，并用一套全新的视角，来解释 Desmos 与传统编程范式之间的根本性差异。

## 核心论点：重新审视“全局”与“局域”

要理解 Desmos，我们必须首先**摒弃**传统编程中根深蒂固的“作用域(Scope)”概念，以及与之关联的“全局(Global)”与“局域(Local)”的划分。Desmos 的运行模型与指令式语言（如 JavaScript）存在本质区别。

-   **传统编程 (指令式)**：代码是一系列**指令**，按顺序执行。当写下 `let c = a + b` 时，计算机会**立即**查找 a 和 b 的**值**，计算出**结果**，并将这个**结果**绑定到 c。表达式 `a + b` 本身在执行后便消失了，留下的是它的值。
-   **Desmos (声明式)**：公式是一系列**声明**，它们定义了符号之间永恒的**关系**。当写下 `c = a + b` 时，Desmos **不会立即计算**，而是将 `a + b` 这个**表达式的结构本身**绑定到符号 `c`。`c` 此刻代表的是一个计算逻辑，而不是一个具体的数值。

这个根本差异，引出了 Desmos 最强大也最独特的特性。

## “不完整片段”作为一等公民

在传统编程中，一个带有未定义变量的表达式 `a + b` 是无法独立存在的，它会立即报错。你必须将它包裹在一个函数 `function(a, b) { return a + b }` 中，才能“延迟”它的计算。

但在 Desmos 中，带有未定义依赖的表达式——我们称之为**“不完整片段” (Incomplete Fragment)**——是完全合法的、可被独立引用和复用的“一等公民”。

**示例1：定义并引用一个“不完整片段”**
```
c = a + b       // c 现在是一个“不完整片段”，因为它依赖未定义的 a 和 b
f(a, b) = c     // 这是合法的！函数 f 成功地引用了片段 c
                // Desmos 理解为 f(a, b) 的结构是 a + b
```
这证明了“不完整片段”`c` 可以像任何普通变量一样被自由传递和引用。

**示例2：将同一个“不完整片段”代入多个下游上下文**
```
c = a + 1                 // 定义“不完整片段” c
c_list = c for a = [1, 2, 3]     // c_list 的结果是 [2, 3, 4]
c_1 = c with a = 10           // c_1 的结果是 11
```
这里，同一个片段 `c` 被两个完全不同的下游结构（`for` 和 `with`）所复用，并且它们各自为 `c` 补上了缺失的定义，得到了不同的结果。这在传统编程中是不可想象的，除非 `c` 被预先定义为一个函数。

## 下游如何影响上游：对“作用域”的颠覆

传统编程中的作用域是**隔离的、单向的**。一个内部作用域可以读取外部变量，但它无法改变外部作用域的行为。

**传统编程的“遮蔽”效应：**
```javascript
let a = 1;
let b = a * 2; // b 的值立即被计算并固定为 2

// 定义一个函数，它的参数 a 会“遮蔽”全局的 a
let x = ((a, c) => a + b + c)(100, 0.1);
// 在函数内部，a 是 100，b 依然是 2。
// lambda 表达式无法“回到过去”去影响 b 的计算。
// x 的结果是 100 + 2 + 0.1 = 102.1
```
参数 `a` 只是一个与全局 `a` 同名的、新的局部变量，它起到了**遮蔽 (shadow)** 作用，但无法干涉上游。

然而，在 Desmos 中，这种隔离被打破了。一个处于**下游**的结构，可以沿着依赖关系图**向上追溯**并影响上游片段的解析。

**Desmos 的“追溯”效应：**
```
a = 1
b = a * 2

// 'with a = 100' 是一个下游节点
// 但它会沿着依赖图向上追溯到 b，并影响 b 的解析
y = b with a = 100 

// 在计算 y 时，Desmos 会这样分析：
// 1. y 依赖 b。
// 2. b 的结构是 a * 2。
// 3. 应用下游 'with' 语句的规则，将 b 结构中的 a 临时替换为 100。
// 4. 因此，b 被临时解析为 100 * 2 = 200。
// y 的最终结果是 200。
```
这就是“下游覆盖上游”感觉的来源。它揭示了 Desmos 的本质：这里没有被层层隔离的作用域，只有一个统一的、全局的依赖关系图。

## 新模型：一个由“上下文语句”连接的依赖图

基于以上分析，我们提出一个更精确的模型：

1.  **抛弃“全局/局域”概念**：在 Desmos 中，所有符号和表达式都存在于一个单一的、巨大的依赖关系图中。
2.  **引入“上下文语句节点”**：我们不再称 `with`, `for`, `sum`, 函数定义等为“作用域语句”，而是改称为**“上下文语句节点” (Context Statement Node)**。
3.  **上下文的链式叠加**：这些“上下文语句节点”存在于依赖图的下游。它们的功能是为所有它们所依赖的**上游节点**，追加一套临时的解析规则。当一个节点被多个上下文节点嵌套时，这些规则会形成一个链条，共同决定最终的解析行为。

这些“上下文语句节点”提供的解析规则，可以被清晰地划分为我们之前总结的两种模式：

-   **填洞绑定 (Hole-filling Binding)**
    -   **来源**：函数定义, `sum`, `int`
    -   **行为**：只绑定上游片段中**尚未被定义**的符号。

-   **代换绑定 (Substitution/Override Binding)**
    -   **来源**：`with`, `for`
    -   **行为**：**强制替换**上游片段中的同名符号，无论它之前是否已被定义。

这个模型为 Bernard 的设计提供了清晰的指导：Bernard 的核心任务，就是正确地构建这个依赖图，并精确地模拟“上下文语句节点”的链式叠加效应，从而在最终生成 Desmos State JSON 之前，完成所有必要的静态分析和依赖检查。


