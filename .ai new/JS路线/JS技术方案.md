# Bernard JavaScript 技术方案

> 本文档记录 Bernard 项目的 JavaScript 技术设计，基于双重表达式对象模式。

## 已确定的设计

### 1. 双重表达式对象模式

Bernard 采用两种不同的声明方式区分不同类型的节点：
- expl explicit 显式的 变量/函数/action 有名字 必定是一种声明
- expr expression 普通表达式

，并利用 JavaScript 的模板字符串作为 DSL 载体：

```javascript
// 无预处理版本
const a = expl`a = 1 + 3`;        // 显式公式节点
const b = expr`pi ^ 2`;           // 纯表达式节点  
const c = expl`c = ${a} + ${b}`;  // 组合的显式公式节点
const eq = expr`x^2 + y^2 = 4`;   // 方程表达式节点

// 有预处理版本（预处理机制在后文解释，用于化简语法）
const a = expl`1 + 3`;            // 自动推断变量名
const b = expr`pi ^ 2`;           // 表达式节点无需变量名
const c = expl`${a} + ${b}`;      // 自动推断组合公式
```

### 函数声明的特殊语法

设计还包含了函数声明的特殊语法：

```javascript
// 无预处理版本
const duplicate = expl`duplicate(L) = L.join(L)`;

// 有预处理版本（箭头函数语法）
const duplicate = expl`(L) => L.join(L)`;
```

### 2. 预处理转换模式

预处理版本需要处理不同的转换场景：

#### case 1：变量定义的自动推断
```javascript
// 转换前
const a = expl`1 + 3`;

// 转换后
const a = expl`a = 1 + 3`;
```

#### case 2：表达式节点保持不变
```javascript
// 转换前后完全相同
const b = expr`pi ^ 2`;
```

#### case 3：函数声明的语法转换
```javascript
// 转换前
const duplicate = expl`(L) => L.join(L)`;

// 转换后
const duplicate = expl`duplicate(L) = L.join(L)`;
```

### 设计特性

这个设计有几个值得探讨的特性：

1. **明确的节点类型区分**：`expr`和`expl`区分了不同类型的节点
2. **自然的依赖表达**：通过`${a} + ${b}`自然地表达了表达式间的依赖关系
3. **JavaScript原生语法**：完全基于标准JavaScript语法，无需额外的解析器
4. **渐进增强**：从无预处理到有预处理，提供了渐进的开发体验改进路径
5. **现代化语法**：箭头函数语法符合JavaScript开发者习惯

## 设计哲学分歧与双模式策略

Bernard 项目目前在设计过程中遇到了一个重大的设计哲学分歧，为此我们当前的对策是实施“默认模式”与“Genshin模式”的双轨制策略。这一划分旨在平衡快速开发、框架易用性与保留 Desmos 底层操作的灵活性之间的关系。

### 模式一：默认模式 (Default Mode)

**默认模式** 是 Bernard 库的主要开发方向和推荐使用方式。其核心目标是提供一个**高度封装、专注于表达式组合与复用的工具框架**。它旨在简化 Desmos 图表的构建过程，让用户可以像编写模块化代码一样来组织复杂的数学逻辑。

- **当前状态**: **优先开发中**。
- **详情**: [./默认模式设计方案.md](./默认模式设计方案.md)

### 模式二：Genshin 模式

**Genshin模式**（命名源于社区玩笑，意指追求极致的“黑科技”玩法）代表了 Bernard 项目的探索性方向。其目标是提供一个能够从**各个细节深度操作 Desmos 表达式对象的底层工具集**，完整建模 Desmos 的所有机制。

该模式将致力于完整建模 Desmos 的所有机制，保留其全部的灵活性和自由度，包括：

-   支持悬空依赖与“事后补全”定义。
-   完整实现强上下文绑定语句（`with`, `for`）的强制替换功能。
-   探索并支持盲文模式等高级特性。

- **当前状态**: **概念和远期规划阶段**，待创建文档。它的设计和实现难度远高于默认模式，并且其高度的灵活性可能会与默认模式的封装框架产生冲突。在默认模式成熟之前，不会作为开发重点。

### 当前策略：优先开发默认模式

鉴于项目当前的紧迫需求和技术可行性，我们将**集中全部精力优先开发和完善“默认模式”**。这能让我们以最快的速度交付一个稳定、可用、能解决核心问题的 Bernard 核心库；同时为未来的深度探索保留了空间。

## 待讨论和设计的技术问题

基于我们对 Desmos 声明式与动态上下文模型的深入理解，以下是 Bernard.js（特别是默认模式）需要解决的关键技术问题。

### 1. 表达式的动态与上下文相关性建模

Desmos 的核心是一种“延迟执行”的声明式系统，一个表达式节点的最终结构和值，会受到其下游节点的动态影响。这对我们的建模提出了严峻挑战。

-   **如何表示“不完整片段”**: Desmos 允许 `c = a + b` 这样的“不完整片段”作为一等公民存在，即便 `a` 和 `b` 当下未定义。我们的表达式对象需要能够优雅地表示这种“悬空依赖”的状态。

-   **如何实现“下游影响上游”**: `y = b with a = 100` 这样的下游节点，会逆着依赖图改变上游 `b = a * 2` 的解析。这意味着我们不能构建一个静态的、一次性求值的依赖图。求值过程必须是动态的，并且要感知完整的求值路径。

### 2. 符号映射与作用域管理

此问题比最初设想的“长变量名缩写”要深刻得多。它关系到如何将 JavaScript 的词法作用域映射到 Desmos 独特的、由上下文动态修改的单一全局命名空间。

-   当用户在不同的 JS 函数中都使用了名为 `i` 的局部变量（如循环变量）时，我们的系统必须能将它们正确地映射到 Desmos 中不同的局部上下文变量 `i`，或转换为不会冲突的全局符号。
-   **待决策问题**: *默认模式应采用何种策略来管理JS变量名与Desmos符号名之间的映射，以避免冲突并保持可读性？是采用全局计数器，还是基于作用域的哈希命名，或是其他更复杂的机制？*

### 3. 属性系统的集成

根据 `04-属性与可视化.md` 的分析，可视化属性（如颜色、线宽）本身也可以是表达式，动态依赖于其他变量。

-   我们的 `expl` 和 `expr` 对象不仅要能代表一个数学结构，还需要能附带这些可动态求值的属性。这意味着属性系统本身就是依赖图的一部分。
-   **待决策问题**: *默认模式的API应如何设计，以支持将表达式动态绑定到可视化属性上？是采用链式调用 `.setColor(expr`...`)`，还是通过配置对象 `{ ..., color: expr`...` }` 的方式？*

### 4. 预处理器实现

预处理器的任务现在更加明确：它需要将用户编写的、符合直觉的 JavaScript 代码（如箭头函数），准确地转换为能够被我们上述动态表达式模型所理解的内部结构。

## 主要技术挑战

### 1. 核心挑战：实现上下文动态绑定

这无疑是最大的技术挑战。我们需要设计并实现一个超越静态 DAG 的求值模型。在该模型中，一个节点的求值必须考虑到从它出发、直至最终输出节点的整条路径上所有的“上下文语句节点”（如 `with`, `for`, 函数调用等）。这在现有的前端框架或响应式系统中没有成熟的先例。

### 2. API 设计：在封装与灵活性之间取得平衡

默认模式旨在简化操作、易于上手。我们必须在 API 设计上做出关键权衡：应该在多大程度上封装 Desmos 的底层复杂性？例如，完全隐藏“不完整片段”会使 API 更简单，但可能限制了高级用户实现某些创造性效果。这是默认模式设计的核心矛盾。

### 3. 性能：管理复杂的依赖更新

由于“下游影响上游”，一个下游上下文的微小变化，可能会沿着依赖图向上触发大量节点的重新解析。一个朴素的实现可能会导致性能雪崩。我们需要设计高效的缓存策略和精确的“脏检查”算法，确保只有真正受影响的子图才会被重新计算。

