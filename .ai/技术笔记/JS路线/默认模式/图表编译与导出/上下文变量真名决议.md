# 上下文变量真名决议

> 本文档是 [编译与导出](./index.md) 流程中 "Step 3: 上下文变量真名决议" 的详细实现方案。它解决了在 DAG 依赖结构下，如何为上下文变量分配全局唯一或上下文安全的 Latex 真名。

## 概念定义与方向说明

在深入讨论之前，必须明确“上游/下游”和“父/子”等方向性概念，因为在 Destra 中存在两种反向的图结构：

1.  **数据依赖方向 (Data Dependency)**:
    *   方向: `User -> Dependency` (用户 -> 依赖)。
    *   例如 `A = B + 1`，则 `A` 依赖 `B`。`A` 是 B 的**下游**。
    *   在图中箭头通常画为 `A -> B`。

2.  **上下文覆盖方向 (Context Coverage)**:
    *   方向: `Outer Context -> Inner Content` (外层 -> 内层)。
    *   例如 `S = Sum(n, Body)`，`S` 提供了变量 `n` 给 `Body` 使用。
    *   从数据依赖看，`S` 依赖 `Body` (`S -> Body`)，`S` 是 `Body` 的下游。
    *   但从上下文作用域看，`S` 是 `Body` 的**外层/祖先 (Ancestor)**，`Body` 是 `S` 的**内层/子 (Child)**。上下文环境是**逆着数据依赖箭头**传播的。

**本文档中的约定**:
*   **Scope DAG**: 节点为 Scope (CtxExp/AST Clause)。边 $S_{parent} \to S_{child}$ 代表 $S_{parent}$ 物理上包裹了 $S_{child}$。
*   **上游/Parent (Scope)**: 指上下文覆盖关系中的外层/祖先（对应数据依赖图中的下游）。
*   **下游/Child (Scope)**: 指上下文覆盖关系中的内层/子（对应数据依赖图中的上游）。
*   **传播 (Propagation)**: 指上下文环境信息（如已占用的变量名）从 Scope Parent 向 Child 流动。

---

## 核心挑战：DAG 下的命名一致性

由于 Destra 允许公式复用，一个公式对象可能同时被多个外层 Context 引用。

```javascript
// Scope F (For i, j)
const F = expl.For`i=[1...10], j=[1...10]`(({i, j}) => expr`${i}^2 + ${j}^2`)

// Path A: A (Sum i) -> F
const A = expl.Sum`i=1, 10`(i => expr`${F}[ (${i} - 1) * 10 + 1]`)
// Path B: B (Sum j) -> F
const B = expl.Sum`j=1, 10`(j => expr`${F}[ (1 - 1) * 10 + ${j}]`)

// root entry:
const root = expr`${A} + ${B}`;
```

在此场景下：
1.  **Scope 共享**: `F` 在逻辑上同时是 `A` 和 `B` 的子 Scope。这构成了一个 **Scope DAG**（而非 Tree）。
2.  **命名静态性**: `F` 最终生成的 Latex 代码是静态唯一的。这意味着 `F` 内部选用的变量名（如 `i` 或 `i_{1}`）必须同时在 `Path A` 和 `Path B` 中合法。
3.  **约束聚合**: `F` 必须避让 `A` 中定义的 `i`，同时也必须避让 `B` 中定义的 `j`。

---

## 解决方案：Scope DAG 与约束聚合

我们采用 **拓扑真名决议 (Topological Name Resolution)** 算法。

### Phase 1: 构建 Scope DAG (Scope Propagation)

首先，我们需要基于数据依赖图构建出一个平行、精简（只包含必要节点）、且精细（包含AST内部上下文语句节点）的 Scope DAG。由于 AST 内部可能包含复杂的嵌套结构，这一步必须深入 AST 层面。

**输入**: Formula 依赖图 (经过 Step 1.5 验证合法)。
**输出**: Scope DAG (节点为 `ScopeNode`, 边为 `Parent -> Child`)。

**ScopeNode 定义**:
*   `GlobalScope`: 全局根节点。
*   `CtxExpScope`: 对应 `CtxExp` 公式对象。
*   `InternalClauseScope`: 对应 AST 内部的 Context Clause (如 `sum(...)`)。

**构建算法**:
1.  对 Formula 依赖图进行 **倒序拓扑排序 (Reverse Topological Sort)**（即 `User` 排在 `Dependency` 之前）。
2.  **Scope 状态传播**:
    *   每个 Formula 对象维护 `inheritedScopes: Set<ScopeNode>` (来自所有 User 的 Scope 集合)。
    *   按照排序依次遍历每个 Formula `F`:
        *   `currentScopes` = $\bigcup_{U \in Users(F)} U.outputScopes(to \ F)$。
        *   如果 `F` 是 `CtxExp`:
            *   创建一个新的 `CtxExpScope S`。
            *   建立边: $\forall P \in currentScopes, P \to S$。
            *   `S` 成为其 Body 的 Context。
        *   如果 `F` 包含 Internal AST:
            *   在 AST 上进行精细传播。
            *   AST 中的 Context Clause 创建 `InternalClauseScope`，并成为其 Content 的 Context。
            *   AST 中的插值节点 (`Interpolation`) 负责将当前的 Scope 集合传递给依赖的 Formula。

### Phase 2: 真名决议 (Resolution)

在构建好的 Scope DAG 上进行命名分配。

**算法**:
1.  对 Scope DAG 进行 **拓扑排序**（Parent 排在 Child 之前）。
2.  **Constraint Aggregation (约束聚合)**:
    *   对于每个 Scope 节点 `N`:
    *   计算 **禁止名称集合**: $Forbidden(N) = \bigcup_{P \in Parents(N)} (Forbidden(P) \cup Used(P))$。
    *   *解释*: 节点 `N` 必须避让所有父节点路径上已经使用的名字，以及父节点本身被禁止使用的名字（传递性）。
3.  **Name Assignment (命名分配)**:
    *   对于 `N` 中定义的每个变量 `v`:
        *   **Case A: 强制命名 (Forced)**:
            *   如果用户指定了 `realname`，检查是否在 $Forbidden(N)$ 中。
            *   若冲突，报错（或尝试自动后缀？通常强制命名意味着用户后果自负，报错更安全）。
            *   若无冲突，分配该名字。
        *   **Case B: 自动命名**:
            *   候选名 = `v.originalName`。
            *   如果候选名在 $Forbidden(N)$ 或本节点已分配集合中，尝试添加后缀 `_{2}`, `_{3}`... 直到无冲突。
    *   将分配的名字加入 `Used(N)`。

---

## 关键细节

### 1. Internal AST 的处理
Internal AST (DSL) 中的变量名虽然只在局部有效，但也参与全局的避让逻辑。
*   例如 `sum(n=1,10, n^2)`。
*   虽然 `n` 实际上只在 `n^2` 里有效，但在生成 Latex 时，如果有外层变量也叫 `n`，Desmos 可能会产生 Shadowing 歧义（虽然 Desmos 能够处理 Shadowing，但为了确定性，Destra 默认策略是**主动避让 Shadowing**，即总是生成唯一名字）。
*   因此，Internal Scope 同样作为 DAG 节点参与上述流程。

### 2. Sidecar State 存储
计算结果（Realname）将存储在 Formula 的 Sidecar State 中，供后续 Latex 生成步骤直接读取。

```typescript
// state.ts
interface CtxVarState {
    realname?: string; // 决议后的真名
}

interface ASTNodeState {
    // 对于 Internal AST 中的变量定义节点
    realname?: string;
}
```

### 3. 为什么不使用全局唯一命名？
虽然全局唯一命名（如 `v_1`, `v_2`...）工程上最简单，但它严重损害了 Latex 的可读性。Destra 的目标是生成“像人类手写一样的”公式。
通过 **Scope DAG + 约束聚合**，我们实现了：
*   **可读性**: 在无冲突时保留短名字（如 `i`, `n`）。
*   **安全性**: 在 DAG 复杂复用场景下，自动退化为带后缀的安全名字，杜绝歧义。

### 4. 优化：惰性聚合与 Expl 边界
*   **Expl 边界**: 具名公式 (`Expl`) 是静态编译单元。一旦经过 Expl，Scope 传播是否可以简化？
    *   Expl 内部的 Latex 是固定的。这意味着 Expl 内部的 Scope 决议必须在 Expl 自身编译时完成，且结果对于所有引用者是**不变的**。
    *   这实际上将 Scope DAG 切分成了若干个子图。每个 Expl 是一个子图的根。
    *   **但是**，Expl 内部引用的 **自由变量 (Free Variables)**（即来自 Expl 外部 Context 的变量）的命名，是由外部决定的。
    *   **修正**: Expl 内部定义的变量名是固定的（相对于 Expl 自身）。但如果 Expl 引用了外部 CtxVar，该 CtxVar 的名字由外部决议。
    *   我们的算法天然涵盖了这一点：Expl 只是 DAG 中的一个普通节点，Scope 传播会穿透它。

---

## 总结

Step 3 通过构建 **Scope DAG** 并执行 **拓扑约束聚合**，在保证数学含义正确（无歧义）的前提下，最大程度地保留了变量命名的可读性。这虽然比 Scope Tree 或全局唯一命名复杂，但对于一个旨在生成高质量 Desmos 图表的框架来说，是必要的投入。
