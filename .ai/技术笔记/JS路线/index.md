# Destra JavaScript 路线

> 本文档库旨在循序渐进地介绍 Destra 项目 JavaScript 路线的设计思路与最终实现的技术方案。

## 简介

本部分详细阐述了 Destra 项目当前核心的 JavaScript 技术路线。该路线旨在通过具体的工程实践，将项目“数学表达自然性、依赖关系透明性、高组合性”的核心设计原则予以实现。

为了实现数学表达的自然性，我们选择采用一种通过 JavaScript 的**模板字符串**字面量来编写“表达式领域特定语言 (`Expr DSL`)”的方案。

其核心设计则围绕着一个**双类型模式** (`expr` 与 `expl`) 展开，旨在通过清晰的节点类型区分，在标准的 JavaScript 语法内自然地表达数学结构与依赖关系。

为了提升开发者体验，我们引入了**构建时预处理器**，它能够将简洁的“创作形式”（如箭头函数）转换为信息完备的“标准形式”，实现了从简到繁的渐进增强。

在设计哲学上，我们确立了**“默认模式”与“Genshin模式”并行的双模式策略**。“默认模式”作为当前开发重点，旨在提供一个高度封装、易于模块化组合的开发框架；而远期的“Genshin模式”则保留了深入 Desmos 底层、进行极限操作的灵活性。

## 内容目录

- [默认模式](./默认模式/) - 当前主推的默认模式，包含了“Expr DSL”与“双类型模式”等核心设计的详细方案。
- [Genshin模式](./Genshin模式/) - 远期的 Genshin 模式，旨在完整建模 Desmos 的所有底层机制。（待创建）
- [工程化与多版本并行开发方案](./工程化与多版本并行开发方案.md) - 项目为支持多版本并行开发而设计的工程化方案。目前暂时采用的简化版 Monorepo 架构，以独立的 Variant 为核心进行快速迭代。
- [工程化与多版本并行开发方案-旧版](./工程化与多版本并行开发方案-旧版.md) - 旧版工程化方案，包含了一些包括共享包、工具链等在内的完整、复杂的设计，但是目前暂时不使用，后面项目如果发展到一定规模再考虑参考它设计新的完整工程化方案。

---

## 技术方案概述

### 核心方案：基于模板字符串的 Expr DSL

为了实现数学表达的自然性，我们首先需要解决一个问题：如何在原生不支持运算符重载的 JavaScript 中，让用户能方便地书写数学公式？

我们的方案是利用 JavaScript 的**模板字符串**，创建一种“表达式领域特定语言 (`Expr DSL`)”。这是一种在 JS 社区经过充分实践的成熟范式。它允许用户这样编写代码：

```javascript
const a = expr`1 + 3`;
const b = expr`pi ^ 2`;
const c = expr`${a} + ${b}`;      // 使用插值语法来引用其他表达式，可让 Destra 记录表达式间的依赖关系
```

### `expr` 与 `expl` 的双类型模式

进一步分析 Desmos，我们发现并非所有公式的“类型”都相同。有些只是一个纯粹的数学表达式（如 `x^2+y^2=1` 绘制方程，或`nCr(2, 10)` 计算二项式分布），而另一些则是一个带名字的“变量/函数定义”（如 `a=5`，`f_1(x) = [1, ..., x]` 等）。

同时我们也不难想象到，在用户构建复杂数学逻辑的过程中，会需要复用一些表达式节点，但这些表达式节点也不一定需要在 Desmos 里成为有定义的变量，而是只在 JS/Destra 的模型里存在，在 Desmos 图表里把其中的内容复制代入到每一个引用它的公式里。

为了在我们的模型中精确地反映这种区别，我们引入了**双类型模式 (Dual-Type Pattern)**：

-   `expr` (expression): 用于表示一个纯粹的、无名的**表达式**。
-   `expl` (explicit statement): 用于表示一个带名字的**显式声明**。

```javascript
// a 既是一个可被后续引用的表达式，也是一个名为 "a" 的变量定义，“变量定义”型的公式，其内容是 1+3
const a = expl`a = 1 + 3`;

// eq 是一个方程型的公式，它没有名字，也无法被后续引用
const eq = expr`x^2 + y^2 = 4`;

// b 既是是一个纯粹的表达式，其内容是 a + 2 * x^2，没有名字，不会
const b = expr`${a} + 2 * x^2`;
```

这里需要澄清一下几个概念的范围，建议阅读 [03-公式类型与符号系统.md](../../Desmos建模/03-公式类型与符号系统.md) 以获得更完整的理解：

- 可作为 Desmos 一行公式的内容的类型，包括：变量/函数定义，方程/不等式等，纯表达式；
- 可不作为 Desmos 一行公式的内容的类型，包括：仅纯表达式；
- 可在 Destra 模型中被后续引用的类型：变量/函数定义（as expl），纯表达式（as expr）
    - 方程/不等式等类型在数学逻辑上也没有被后续引用的需求，可以认为它们"封顶"了
- 可在 Desmos 中被后续引用的类型：仅变量/函数定义
    - Destra 图表模型里的纯表达式节点在编译时会被内联 (inline)，其内容会被复制并重复代入到每一行公式引用它的地方。如果它没有进入公式列表成为公式，那么在 Desmos 里它就只会在各处以内联形式存在；但如果它进入了公式列表成为公式，那么在 Desmos 里会保留一条以它为内容的公式节点，带有用户在它身上设置的所有显示属性。
- expl 可创建的类型：变量/函数定义
- expr 可创建的类型：纯表达式，方程/不等式等

- 这些 Destra 对象类型是否进入公式列表、是否成为一条公式，取决于它们本身有没有加入 Destra 的一个最终公式列表对象中，以及也取决于它们的下游引用有没有加入公式列表中。
    - 方程/不等式等无法在 Destra 层后续引用，无法具名，如果它们没有进入公式列表成为公式，那么就会被完全忽略。
    - 变量/函数定义可以在 Destra 层被后续引用，必须具名（因为要能在 Desmos 层里继续被引用）；即使它们没有进入公式列表成为公式，如果下游有公式引用它们并进入公式列表，那么它们也会被一并加入公式列表，成为一条 Desmos 公式，以便以 Desmos 变量/函数的形式被下游引用。但如果它和它的所有下游引用都没有进入公式列表，那么它们就会被完全忽略。
    - 纯表达式可以在 Destra 层被后续引用，无法具名。在 Destra 层里它们可被下游引用，但编译至 Desmos 后会变成内联形式，其内容会被复制并重复代入到每一行公式引用它的地方。如果它和它的下游没有进入公式列表，那么它会被完全忽略。如果它没有进入公式列表成为公式，但它有下游进入公式列表，那么在 Desmos 里它就只会在各处以内联形式存在；但如果它进入了公式列表成为公式，那么除了各处内联形式之外，在 Desmos 里会保留一条以它为内容的公式节点，带有用户在它身上设置的所有显示属性，但它和其他位置的内联表达式内容之间已经没有任何关系。

| 是否进入公式列表 | 本体进入 | 本体未进入,下游进入 | 本体、下游都未进入 |
|----------------|:--------:|:-----------------:|:----------------:|
| **变量/函数定义 by expl** | ✅成为公式             | ✅成为公式        | ❌被忽略        |
| **纯表达式 by expr**     | ✅成为公式             |   内联            | ❌被忽略        |
| **方程/不等式等 by expr**| ✅成为公式             | ❌ 无下游，被忽略  | ❌ 被忽略       |


### 3. 体验优化：预处理器 与 “创作/标准”形式

``const a = expl`a = 1 + 3`;`` 的这种设计能够保证 Destra 知道这个表达式大致想要在 Desmos 里使用什么变量名称（即 `a`），但在日常开发中，变量名 `a` 出现了两次，显得很冗余。为了追求极致的开发者体验 (DevEx)，我们引入了**构建时预处理器 (Build-Time Preprocessor)**。

预处理器的引入，将我们的代码明确地划分为了两种形式：

-   **创作形式 (Creative Form)**：开发者在日常编写的、简洁直观的代码。它本身是语法合法的 JavaScript，但其“真实意图”需要通过预处理器来解读。
-   **标准形式 (Standard Form)**：经过预处理器转换后，生成的语义完备、供 Destra 核心 API 使用的规范化代码。

预处理器的工作就是将“创作形式”转换为“标准形式”，例如：

**场景1：变量定义的自动推断**
```javascript
// 创作形式：开发者只需这样写
const a = expl`1 + 3`;

// 标准形式：预处理器会自动转换为
const a = expl`a = 1 + 3`;
/*
注：这实际上不准确。
在默认模式方案（见后文）里实际上会转换为另一种形式：
const a = expl`a = 1 + 3`.id("a", true); 
这里仅作示例。
*/
```

**场景2：纯表达式保持不变**
```javascript
// 创作形式
const b = expr`pi ^ 2`;

// 标准形式
const b = expr`pi ^ 2`;
```

**场景3：函数定义的语法糖**
```javascript
// 创作形式：开发者可以使用风格更现代的箭头函数语法
const duplicate = expl`(L) => L.join(L)`;

// 标准形式：预处理器会将其转换为 DSL 字面量里包含函数名的函数定义语法
const duplicate = expl`duplicate(L) = L.join(L)`;
/*
注：默认模式方案里会转为：
const duplicate = expl`(L) => L.join(L)`.id("duplicate", true);
还是把箭头符号保留下来了 lol
其实 DSL 怎么设计都行看起来通顺就Ok
*/
```
通过这种方式，我们在不牺牲 API 严谨性的前提下，为开发者提供了最大程度的便利。

### 4. 路线分叉：默认模式 与 Genshin 模式

### 设计哲学分歧与双模式策略

在上述所有设计（Expr DSL, 双类型模式, 预处理器）之后，Destra 项目在设计哲学上遇到了一个重大的设计哲学分歧，为此我们当前的对策是实施“默认模式”与“Genshin模式”的双轨制策略。这一划分旨在平衡快速开发、框架易用性与保留 Desmos 底层操作的灵活性之间的关系。

#### 模式一：默认模式 (Default Mode)

**默认模式** 是 Destra 库的主要开发方向和推荐使用方式。其核心目标是提供一个**高度封装、专注于表达式组合与复用的工具框架**。它旨在简化 Desmos 图表的构建过程，让用户可以像编写模块化代码一样来组织复杂的数学逻辑。

- **当前状态**: **优先开发中**。
- **详情**: [./默认模式/](./默认模式/)

#### 模式二：Genshin 模式

**Genshin模式**（命名源于社区玩笑，意指追求极致的“黑科技”玩法）代表了 Destra 项目的探索性方向。其目标是提供一个能够从**各个细节深度操作 Desmos 表达式对象的底层工具集**，完整建模 Desmos 的所有机制。

该模式将致力于完整建模 Desmos 的所有机制，保留其全部的灵活性和自由度，包括：

-   支持悬空依赖与“事后补全”定义。
-   完整实现强上下文绑定语句（`with`, `for`）的强制替换功能。
-   探索并支持盲文模式等高级特性。

- **当前状态**: **概念和远期规划阶段**，待创建文档。它的设计和实现难度远高于默认模式，并且其高度的灵活性可能会与默认模式的封装框架产生冲突。在默认模式成熟之前，不会作为开发重点。

### 当前策略：优先开发默认模式

鉴于项目当前的紧迫需求和技术可行性，我们将**集中全部精力优先开发和完善“默认模式”**。这能让我们以最快的速度交付一个稳定、可用、能解决核心问题的 Destra 核心库；同时为未来的深度探索保留了空间。

### 待讨论和设计的技术问题

基于我们对 Desmos 声明式与动态上下文模型的深入理解，以下是 destra.js需要解决的关键技术问题。

#### 1. 表达式的动态与上下文相关性建模

Desmos 的核心是一种“延迟执行”的声明式系统，一个表达式节点的最终结构和值，会受到其下游节点的动态影响。这对我们的建模提出了严峻挑战。

-   **如何表示“不完整片段”**: Desmos 允许 `c = a + b` 这样的“不完整片段”作为一等公民存在，即便 `a` 和 `b` 当下未定义。我们的表达式对象需要能够优雅地表示这种“悬空依赖”的状态。

-   **如何实现“下游影响上游”**: `y = b with a = 100` 这样的下游节点，会逆着依赖图改变上游 `b = a * 2` 的解析。这意味着我们不能构建一个静态的、一次性求值的依赖图。求值过程必须是动态的，并且要感知完整的求值路径。

#### 2. 符号映射与作用域管理

此问题比最初设想的“长变量名缩写”要深刻得多。它关系到如何将 JavaScript 的词法作用域映射到 Desmos 独特的、由上下文动态修改的单一全局命名空间。

-   当用户在不同的 JS 函数中都使用了名为 `i` 的局部变量（如循环变量）时，我们的系统必须能将它们正确地映射到 Desmos 中不同的局部上下文变量 `i`，或转换为不会冲突的全局符号。
-   **待决策问题**: *默认模式应采用何种策略来管理JS变量名与Desmos符号名之间的映射，以避免冲突并保持可读性？是采用全局计数器，还是基于作用域的哈希命名，或是其他更复杂的机制？*

#### 3. 属性系统的集成

Desmos 公式的可视化属性（如颜色、线宽）本身也可以是表达式，动态依赖于其他公式。

-   我们的 `expl` 和 `expr` 对象不仅要能代表一个数学结构，还需要能附带这些可动态求值的属性。这意味着属性系统本身就是依赖图的一部分。
-   **待决策问题**: *默认模式的API应如何设计，以支持将表达式动态绑定到可视化属性上？是采用链式调用 `.setColor(expr`...`)`，还是通过配置对象 `{ ..., color: expr`...` }` 的方式？*

#### 4. 预处理器实现

预处理器的任务现在更加明确：它需要将用户编写的、符合直觉的 JavaScript 代码（如箭头函数），准确地转换为能够被我们上述动态表达式模型所理解的内部结构。

### 主要技术挑战

#### 1. 核心挑战：实现上下文动态绑定

这无疑是最大的技术挑战。我们需要设计并实现一个超越静态 DAG 的求值模型。在该模型中，一个节点的求值必须考虑到从它出发、直至最终输出节点的整条路径上所有的“上下文语句节点”（如 `with`, `for`, 函数调用等）。这在现有的前端框架或响应式系统中没有成熟的先例。

#### 2. API 设计：在封装与灵活性之间取得平衡

默认模式旨在简化操作、易于上手。我们必须在 API 设计上做出关键权衡：应该在多大程度上封装 Desmos 的底层复杂性？例如，完全隐藏“不完整片段”会使 API 更简单，但可能限制了高级用户实现某些创造性效果。这是默认模式设计的核心矛盾。

#### 3. 性能：管理复杂的依赖更新

由于“下游影响上游”，一个下游上下文的微小变化，可能会沿着依赖图向上触发大量节点的重新解析。一个朴素的实现可能会导致性能雪崩。我们需要设计高效的缓存策略和精确的“脏检查”算法，确保只有真正受影响的子图才会被重新计算。

## 相关文档

- [项目总览](../../项目总览.md) - Destra 项目的完整介绍
- [技术笔记](../index.md) - Destra 的技术概述
- [PSADestra 项目总览](../../PSADestra%20项目总览.md) - PSADestra 项目的介绍 