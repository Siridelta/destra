# Desmos 公式系统建模

本文档详细描述对 Desmos 公式系统的建模研究。由于 Desmos 并未开源，这些建模基于观察和推测，旨在为 ExprBuild 项目提供准确的设计基础。

## Bernard.jl 项目定位与建模范围

在深入建模之前，我们需要明确 Bernard.jl 的职责边界和建模范围。Bernard.jl 专注于提供公式对象的工程化、可编程化、可扩展性组合框架，其核心职责是帮助开发者通过编程方式管理大量表达式，克服 Desmos 原生界面在处理复杂图表时的局限性。

我们的建模重点集中在 Desmos 公式系统的静态特性上，包括符号系统、公式类型识别、依赖关系分析等方面。我们不涉及 Desmos 内部的动态求值过程，也不深入处理其计算机制的实现细节。这种定位决定了我们提供有限但必要的检查，主要包括基本的依赖关系检查和符号兼容性验证，而不关心用户在具体求值过程中可能犯下的错误。实际上，我们的设计原则是允许有目的地产生和保留某些错误状态，因为这些错误最终会在 Desmos 环境中得到适当的处理和反馈。而 Bernard.jl 可以在调试支持 (Debugging Support) 功能中将这些错误信息进行"符号还原"（Desmos 使用的是已经过 Bernard.jl 进行"符号重命名"的符号，需要还原，详见其他文档），反馈给用户。

## 基本术语定义

在 ExprBuild 中，我们对 Desmos 相关术语做出以下区分：

- **公式（Formula）**：指 Desmos 中的一行可编辑内容，包括变量定义、函数定义、方程等各种类型。Desmos 官方称之为"表达式"（Expression），但我们采用"公式"这一更广义的术语。

- **表达式（Expression）**：指可求值的数学表达式，是公式的一个子类型。

- **Expr**：在文档和代码里尽量用这个缩写来指代Julia语言的表达式概念，方便讨论和使用Julia语言的宏和元编程能力。

## 公式类型系统

Desmos 支持以下几种主要公式类型：

1. **表达式（Expression）**：
   - 形式：`2 + a`（其中 a 为已定义变量）
   - 特点：可以求值，但不定义任何新符号
   - 图形表现：不绘制任何图形，仅显示计算结果

2. **变量定义（Variable Definition）**：
   - 形式：`a = 3`
   - 特点：定义一个变量并占用该符号
   - 注意：x, y 为保留符号，不可定义
   - 图形表现：不绘制，但可能附带滑动条

3. **函数定义（Function Definition）**：
   - 形式：`f(x) = x^2`
   - 特点：定义一个函数并占用函数名
   - 图形表现：不绘制，但定义可在其他公式中使用

4. **临时函数（Temporary Function）**：
   - 形式：`x^2`、`sin(x)`、`y = g(x)`(g(x)已定义)、`V = (4/3)*pi*r^3`(V, r 未定义)
   - 特点：用于快速绘制函数图像而无需显式定义
   - 图形表现：根据不同形式和上下文绘制不同的图形

5. **方程/不等式（Equation/Inequality）**：
   - 形式：`x^2 + y^2 = 4`
   - 特点：关于x, y的方程/不等式
   - 图形表现：Desmos 会自动绘制其图像

6. **回归（Regression）**：
   - 形式：`Y ~ kX + b`
   - 特点：用于数据拟合，会自动计算参数值并引入新的变量定义
   - 图形表现：绘制拟合曲线

## 临时函数解析规则

临时函数是 Desmos 中一个特殊而强大的功能，它能自动识别和绘制多种形式的表达式。解析规则如下：

- **形如 `b = f(a)`，`y = f(a)` 和 `y = f(x)`**：
  - 绘制 y 轴为因变量的图像
  - a, b 为未定义的符号
  - 例：`y = sin(x)`、`y = a*x + b`

- **形如 `x = f(a)` 和 `x = f(y)`**：
  - 绘制 x 轴为因变量的图像
  - a 为未定义的符号
  - 例：`x = sin(y)`、`x = a*t`

- **形如 `f(x)`**：
  - 绘制 x 轴为自变量 / y 轴为因变量的图像
  - 表达式不得包含 x 以外的未定义符号
  - 例：`x^2`、`sin(x)`

## 符号系统

Desmos 公式系统中的符号有严格的规则：

1. **符号形式**：
   - 单个字符：如 `a`, `b`
   - 单个字符加下标：如 `a_{1}`, `b_{max}`
   - 下标可为多字符，但主字符只能是单个字符
   - 主字符范围包括大小写字母和希腊字母
   - 下标可以包括大小写字母和数字

> 补充说明：
> 在自建对象系统的设计中，无需担心用户输入下标等符号格式错误。Desmos 采用 Mathquill 作为所见即所得的数学公式编辑组件，用户在前端输入公式后，Mathquill 会将其转换为规范的 LaTeX 代码。Desmos 与 Mathquill 之间的数据交换也是基于 LaTeX 代码进行的，因此下标等语法结构在技术上是由 Mathquill 保证正确的。我们只需关注如何解析和建模这些规范的 LaTeX 公式即可，无需额外处理用户输入的语法错误。

2. **特殊符号**：
   - `x`, `y` 为保留符号，不可定义，用于临时函数和方程
   - 在 3D 计算器中，`z` 也是保留符号
   - `t` 与参数方程功能相关
   - 内置函数如 `sin`, `cos` 等是预定义的多字符符号

3. **符号类别**：
   - 已定义符号：用户显式定义的变量或函数
   - 未定义符号：尚未定义但在表达式中使用的符号
   - 内置符号：Desmos 预定义的符号，如 `sin`, `cos`, `e`, `π` 等
   - 保留符号：特殊用途的符号，如 `x`, `y`

4. **内置符号保护机制**：
   - 内置常数（如 `e`, `π`）不能被变量定义覆盖
   - 尝试定义 `e = 2` 会被解析为方程 `2.71828... = 2`，结果为不成立
   - 内置函数（如 `sin`, `cos`）不能被重新定义
   - 尝试定义 `sin(x) = 0.1x` 会被解析为关于 x 的方程，而非函数重定义
   - 命名空间分离：可以定义与内置符号同名的函数，如 `e(x) = x^2`，与常数 `e` 不冲突
   - 符号解析优先级：内置符号 > 用户定义符号，确保内置符号的语义不被破坏

## 符号计算能力观察

Desmos 展现出一定的符号计算能力，通过系统性的实验观察，我们能够了解其内部机制的一些重要特征。

### 代换处理机制

通过以下实验，我们观察到 Desmos 在符号代换和函数求值时的具体机制。这些实验揭示了 Desmos 如何处理符号间的依赖关系，以及在不同上下文中如何进行符号代换。

**示例1：符号代换与函数定义**
```
c = a + b
f(a, b) = c
```

在这个例子中，虽然 `c = a + b` 因为 a、b 未定义而报错，但 `f(a, b) = c` 却能成功解析。我们推测 Desmos 将 c 代换为 `a + b`，形成 `f(a, b) = a + b`，成功解析为函数定义。当执行 `y = f(x, x)` 时，绘制出 y = 2x 的斜线图像，证实了这种代换机制的存在。

**示例2：部分变量已定义的代换**
```
c = a + b
a = 2
f(a, b) = c
```

当外部变量 a 已定义时，`y = f(1, x)` 绘制为 y = 2 + x 的斜线，而 `y = f(x, 1)` 绘制为 y = 3 的水平线。这表明 Desmos 在函数定义阶段就进行部分代换，将 c = a + b 中的 a 替换为 2，得到 c = 2 + b。函数体中已定义的外部变量会直接代入其值，而函数参数保持符号形式。

**示例3：完全求值的情况**
```
c = a + b
a = 2
b = 1
f(a, b) = c
```

当所有外部变量都已定义时，所有的 `y = f(..., ...)` 调用都绘制为 y = 3 的水平线图像。此时函数体中的表达式被完全求值为常数，c = 2 + 1 = 3，因此 f(a, b) = 3，无论传入什么参数都返回常数 3。

这些观察揭示了 Desmos 函数定义时的符号代换机制：函数体中引用的外部变量会被替换为其定义，代换过程中优先使用已定义变量的具体值，未定义变量保持符号形式。函数参数与外部变量的作用域严格分离，符号解析时首先查找外部定义，然后才考虑函数参数。

### 条件表达式与依赖分析的重要发现

条件表达式为我们理解 Desmos 的错误处理机制提供了关键的洞察。通过以下实验，我们发现了 Desmos 在处理未定义依赖时的重要行为模式。

**关键实验：**
```
a = 2 (设置为滑动条，范围1到2，步长0.1)
f(x) = {x = ceil(x): 1, opq}  // 报错：变量太多。请尝试定义 opq。
f(a)                          // 报错：变量太多。请尝试定义 opq。
b = {a = ceil(a): 1, opq}     // 成功计算，b = 1
```

这个实验揭示了一个非常重要的行为：条件表达式将所有分支内容都视作依赖，无论具体求值时会选择哪个分支。在函数定义 `f(x) = {x = ceil(x): 1, opq}` 中，尽管条件 `x = ceil(x)` 总是成立（因为对于整数和正数，ceil(x) = x），实际求值永远不会到达 opq 分支，但 Desmos 仍然将 opq 视为函数的依赖项。由于 opq 未定义，函数定义失败。

相比之下，在一般表达式 `b = {a = ceil(a): 1, opq}` 中，相同的条件表达式却能成功计算出 b = 1。这表明 Desmos 在不同上下文中对未定义依赖的容忍度不同。

### 微积分处理观察

通过微积分操作的观察，我们可以了解 Desmos 如何处理符号运算和图结构修改。

**微积分实验：**
```
c = a + b           -> 报错: "变量太多。请尝试定义 a 和 b。"
\frac{d}{da} c      -> 计算为: 1
\frac{d}{db} c      -> 计算为: 1
\frac{d}{dc} c      -> 计算为: 1
\frac{d}{dc} a      -> 计算为: 0
\frac{d}{dc} (a + b)-> 计算为: 0
\frac{d}{dc} (2c)   -> 计算为: 2
\frac{d}{dc} (2c^2) -> 报错: "变量太多。请尝试定义 a 和 b。"
```

微积分操作会创建新的表达式节点，如 `\frac{d}{dc} (2c^2)` 生成新节点 `4c`。新生成的表达式仍然引用原有的符号节点，保持图结构的连通性。`\frac{d}{da} c` 成功是因为生成表达式 1 不包含未定义符号，而 `\frac{d}{dc} (2c^2)` 失败是因为生成的表达式 `4c` 在动态求值时发现 c 依赖未定义符号。

## Desmos 错误处理机制的精确理解

通过上述实验，我们对 Desmos 的错误处理机制有了更精确的理解。这种理解对 Bernard.jl 的设计具有重要的指导意义。

### 计算前容忍原则

Desmos 采用了一种"计算前容忍"的错误处理策略。在大多数情况下，Desmos 在具体计算开始前会容忍未定义依赖的存在，不会立即抛出错误。这种机制允许用户构建复杂的表达式网络，即使某些部分暂时存在未定义的依赖关系。

这个原则的核心在于区分两个不同的阶段：表达式构建阶段和具体计算阶段。在构建阶段，Desmos 专注于解析表达式的结构和建立依赖关系，对于未定义的符号采取宽容的态度。只有在需要对某个特定表达式进行具体数值计算时，才会检查其所有依赖是否已经定义并可求值。

### 函数定义的特殊性与阻断性错误

然而，函数定义是这个容忍原则的一个重要例外。在函数定义中，如果函数体包含未定义的依赖，Desmos 会立即抛出错误。这是因为函数定义本身需要建立一个可调用的实体，而包含未定义依赖的函数体无法形成有效的函数定义。

更重要的是，我们发现函数定义中的未定义依赖错误具有阻断性。当一个函数因为未定义依赖而定义失败时，所有试图调用该函数的后续表达式都无法绕开这个错误。这种错误会传播到整个依赖链中，影响所有依赖该函数的表达式。例如，如果 `f(x) = {x = ceil(x): 1, opq}` 因为 opq 未定义而失败，那么任何形如 `y = f(something)` 的表达式都无法成功计算，即使 something 本身是完全定义的。

这种阻断性错误的存在意味着在 Bernard.jl 的设计中，我们需要特别关注函数定义中的依赖检查，确保不会因为函数定义的错误而影响整个公式系统的可用性。

## 符号作用域和函数调用的建模

通过深入分析具体示例，我们发现了一个重要的建模问题。考虑这样的公式组合：
```
c = a + b
f(a, b) = c
y = f(1, x)
```

在这个例子中，我们面临一个符号指向的歧义问题：

在全局的 `c = a + b` 中，符号 a 和 b 是未定义的。按照常规理解，这些未定义符号应该指向某处的定义。但是，如果我们说它们指向函数 f 的参数，那么当我们有多个函数都有参数 a, b 时，这些全局的 a, b 应该指向哪个函数的参数呢？

这揭示了一个更深层的问题：**Desmos 的符号作用域机制与传统编程语言不同**。

### 符号作用域的正确理解

我们需要重新理解 Desmos 中的符号作用域：

**全局作用域中的未定义符号就是未定义符号**，它们不会自动指向任何函数的参数。在 `c = a + b` 中，a 和 b 就是全局未定义符号，这会导致这个公式报错。

**函数定义有自己的局部作用域**。在 `f(a, b) = c` 中：
- 左边的 a, b 是这个函数的局部参数
- 右边的 c 是对全局符号 c 的引用（因为 c 不在参数列表中）
- 符号查找遵循"局部优先，然后全局"的规则

**函数调用是一个独立的节点**。在 `y = f(1, x)` 中：
- 这里有一个函数调用节点（call node），它依赖于：
  - 函数 f（通过符号表）
  - 常数 1
  - 符号 x（保留符号）

### 依赖图模型

基于这种理解，我们可以建立依赖图模型：

**图结构**包含：
- **符号节点表**：记录全局定义的符号
- **公式节点表**：每个公式一个节点
- **函数调用节点**：每个函数调用一个节点（call node）
- **语法树片段**：每个公式内部的表达式结构

**依赖关系**：
- 公式节点指向语法树片段，再指向语法树片段依赖的符号表节点
- 语法树片段按照表达式结构连接
- 函数调用节点指向函数定义（符号表节点）和代入参数的各表达式节点

在函数调用处，依赖关系会有所中断：我们看不到一个直接的 "f = 1 + x" 结构，而是看到一个调用节点指向函数定义和参数。这就是函数调用的本质：它是一个间接的、通过参数绑定的依赖关系。

### 图结构示例

让我们分析之前的示例：

**示例公式组合：**
```
a = 2
b = a + 1  
c = sin(b) * pi
f(x, y) = c + x^2 + y
g(t) = f(t, b)
```

**符号表和公式的双向关系：**
- 符号a ←→ 公式1: "a = 2"
- 符号b ←→ 公式2: "b = a + 1"  
- 符号c ←→ 公式3: "c = sin(b) * pi"
- 函数f ←→ 公式4: "f(x, y) = c + x^2 + y"
- 函数g ←→ 公式5: "g(t) = f(t, b)"

**关键的依赖关系：**
- 公式2依赖符号a
- 公式3依赖符号b
- 公式4（函数f的定义）依赖符号c
- 公式5（函数g的定义）中有一个函数调用节点，这个调用节点依赖：
  - 函数f（通过符号表）
  - 参数t（g的局部参数）
  - 符号b（全局符号）

这样的模型简洁地反映了 Desmos 的实际工作机制，理解函数调用节点的特殊性：它在依赖图中创建了一个间接的连接。

## Desmos 解析流程建模

基于我们的观察和实验，我们可以推测 Desmos 的公式解析流程。这个流程模型有助于我们理解 Desmos 如何处理用户输入的公式，以及如何建立和维护复杂的依赖关系网络。

### 语法解析阶段

Desmos 从 Mathquill 模块接收公式的 LaTeX 代码，然后进行语法解析来识别表达式结构。在分词步骤中，特定的多字符符号（如内置函数）具有更高的优先级，而除了这些特定符号外，多字符组合默认被视为乘法关系。

### 语义分析和符号表建立

在这个阶段，Desmos 进行语义分析并建立符号表系统。任何形如 `a = expression(b)` 的表达式都会被识别为定义式，包括变量定义和函数定义。系统会检查定义式左边是否为内置符号，如果是则重新解析为方程。

Desmos 维护符号表和公式列表的双向关系：
- **符号表**：记录所有全局定义的符号（变量、函数名等）及其关联的表达式
- **公式列表**：记录每个公式的内容和属性
- **双向关联**：符号表和公式列表之间建立双向关联关系。符号表到公式列表的映射记录每个符号在哪个公式中被定义，而公式列表到符号表的映射记录每个公式引用了哪些符号。这一阶段先建立符号表到公式列表的映射（定义关系）。

同时，系统会为函数等具有局部作用域的结构建立独立的局部符号表（如函数参数）。在这个阶段，系统还会根据表达式结构初步确定公式类型，其中函数定义具有优先识别的特性。

### 跨公式依赖分析

在符号表建立之后，Desmos 进行跨公式的依赖分析。这个过程建立公式列表到符号表的映射（引用关系），完成双向关联关系的建立。

系统还会确定函数参数与外部符号的作用域关系，并构建图结构。这个图结构包含跨公式依赖关系和公式内语法树结构，边的方向约定采用"依赖指向被依赖"的方向，即从需要值的节点指向提供值的节点。

在跨公式层级，公式节点指向其依赖的符号节点；在公式内层级，表达式节点指向其操作数节点，符号引用节点指向符号表内对应的符号定义节点。系统同时维护反向索引以支持变更传播，当某个符号值变化时，能快速找到所有受影响的节点。

Desmos 还会进行循环依赖检测，识别图中的强连通分量，标记循环依赖的公式节点。系统为每个符号建立完整的依赖链，用于动态求值时的图遍历，并建立符号解析优先级：内置符号 > 外部定义 > 函数参数。

### 动态计算和求值

在依赖关系建立后，Desmos 通过图遍历进行动态求值计算，而不是进行预先的符号代换。系统会处理微分、积分等符号计算操作，必要时会修改图结构，并对可求值的表达式进行数值计算。

### 类型确定和可视化

最后，Desmos 根据计算结果重新确定公式类型（如临时函数识别），并生成最终的可视化指令。

## Bernard.jl 的设计启示

基于我们对 Desmos 公式系统的深入理解，我们可以为 Bernard.jl 的设计提供一些关键的指导原则，但具体的技术实现将在其他文档中详细讨论。

### 计算前容忍的错误处理策略

Bernard.jl 应该借鉴 Desmos 的"计算前容忍"原则，在表达式构建阶段对未定义依赖保持宽松的态度。这意味着用户可以先构建表达式的骨架，然后再逐步填充具体的定义。

同时，需要特别关注函数定义中的依赖检查，因为这类错误具有阻断性。系统应该提供明确的警告机制，帮助用户识别可能导致阻断的函数定义错误。

### 图模型的设计原则

基于我们对符号作用域和函数调用机制的理解，Bernard.jl 可以采用这样的图模型来处理依赖关系：

- 每个函数调用都是一个独立的节点，在依赖图中创建间接连接
- 符号作用域遵循"局部优先，然后全局"的规则
- 全局未定义符号就是未定义符号，不会自动指向函数参数

这种模型既简洁又准确，避免了过度复杂的建模。

## 公式属性系统

Desmos 为公式提供多种可设置的属性：

**绘图属性：**
- 颜色：可设置为常量或表达式
- 线宽：可设置为常量或表达式
- 透明度：可设置为常量或表达式
- 点样式：对于点集，可设置点的形状和大小
- 线条样式：可设置为实线、虚线等

**滑动条属性：**
- 最小值：可设置为常量或表达式
- 最大值：可设置为常量或表达式
- 步长：可设置为常量或表达式
- 播放设置：包括速度、方向等

**属性行为：**
- 属性保留：即使公式类型变化，属性也会被保留
- 属性可用性：某些属性可能因公式类型变化而变为不可用，但值会被记住
- 表达式属性：属性值可以是表达式，引用其他变量

## 公式列表特性

Desmos 中的公式列表具有以下特性：

**并列结构：**
- 所有公式在逻辑上并列存在，不分先后顺序
- 公式之间通过依赖关系隐式连接
- 列表顺序影响图像的视觉层叠顺序

**动态行为：**
- 用户编辑公式后图形计算器会动态响应，实时更新
- 用户可能引入的变动包括：
  - 公式内容的变化
  - 滑动条的拖动，以及播放的滑动条动画，引起对应变量值的变化
  - 动作的触发，引起对应变量值的变化
- 图形计算器会根据用户编辑的变动，实时更新：
  - 公式类型可以随着编辑动态变化
  - 依赖关系也随编辑实时更新
  - 公式的可视化表现会根据类型和上下文自动调整

**交互特性：**
- 可折叠/展开公式组
- 可临时隐藏公式（不影响依赖计算）
- 可为公式添加注释

## 待研究问题

以下是关于Desmos公式系统尚未完全清晰的问题：

**符号解析的精确规则：**
- 下标解析的完整规则
- 多字符符号优先级的精确列表
- 特殊符号处理（如希腊字母）的完整规则

**公式类型判定的精确算法：**
- Desmos 如何精确区分不同公式类型
- 歧义情况下的解析优先级
- 临时函数和方程类型的详细判定规则

**符号计算能力的边界：**
- 符号代换的精确行为和限制
- 微积分操作的支持范围
- 表达式简化的规则和程度

**特殊语法结构：**
- for, with 两类代换语句的处理机制
- 求和、连乘、积分等引入局部变量的操作
- 这些结构对依赖分析的影响

> 本文档将随着研究进展持续更新，欢迎补充新的观察和推测。 