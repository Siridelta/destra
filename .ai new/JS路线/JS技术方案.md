# Bernard JavaScript 技术方案

> 本文档记录 Bernard 项目的 JavaScript 技术设计，基于双重表达式对象模式。

## 已确定的设计

### 双重表达式对象模式

Bernard 采用两种不同的声明方式区分不同类型的节点：
-  expl explicit 显式的 变量/函数/action 有名字 必定是一种声明
- expr expression 普通表达式

，并利用 JavaScript 的模板字符串作为 DSL 载体：

```javascript
// 无预处理版本
const a = expl`a = 1 + 3`;        // 显式公式节点
const b = expr`pi ^ 2`;           // 纯表达式节点  
const c = expl`c = ${a} + ${b}`;  // 组合的显式公式节点
const eq = expr`x^2 + y^2 = 4`;   // 方程表达式节点

// 有预处理版本（预处理机制在后文解释，用于化简语法）
const a = expl`1 + 3`;            // 自动推断变量名
const b = expr`pi ^ 2`;           // 表达式节点无需变量名
const c = expl`${a} + ${b}`;      // 自动推断组合公式
```

### 函数声明的特殊语法

设计还包含了函数声明的特殊语法：

```javascript
// 无预处理版本
const duplicate = expl`duplicate(L) = L.join(L)`;

// 有预处理版本（箭头函数语法）
const duplicate = expl`(L) => L.join(L)`;
```

### 预处理转换模式

预处理版本需要处理不同的转换模式：

#### 模式1：变量定义的自动推断
```javascript
// 转换前
const a = expl`1 + 3`;

// 转换后
const a = expl`a = 1 + 3`;
```

#### 模式2：表达式节点保持不变
```javascript
// 转换前后完全相同
const b = expr`pi ^ 2`;
```

#### 模式3：函数声明的语法转换
```javascript
// 转换前
const duplicate = expl`(L) => L.join(L)`;

// 转换后
const duplicate = expl`duplicate(L) = L.join(L)`;
```

### 设计特性

这个设计有几个值得探讨的特性：

1. **明确的节点类型区分**：`expr`和`expl`区分了不同类型的节点
2. **自然的依赖表达**：通过`${a} + ${b}`自然地表达了表达式间的依赖关系
3. **JavaScript原生语法**：完全基于标准JavaScript语法，无需额外的解析器
4. **渐进增强**：从无预处理到有预处理，提供了渐进的开发体验改进路径
5. **现代化语法**：箭头函数语法符合JavaScript开发者习惯

## 优先实施：“默认模式”设计方案

根据项目最新的“双模式”设计哲学，我们当前优先实施“默认模式”。该模式的设计方案旨在提供一个稳定、易于封装和复用的框架，其核心设计决策如下：

### 1. 依赖管理：禁止悬空依赖

严格禁止任何形式的悬空依赖。一个表达式被创建时，它所依赖的所有符号必须已经定义。这确保了依赖图在任何时候都是完整和确定的，从而简化了分析和计算过程。

### 2. 上下文语句：统一为弱绑定回调模式

为了消除歧义并增强封装性，所有上下文语句（包括原版Desmos中具有强制替换功能的 `with` 和 `for`）都将采用统一的“弱绑定”实现模式。它们只负责为其内部作用域提供局部变量，而不影响任何上游表达式的结构。

推荐的实现语法将采用函数回调的形式，将局部变量通过上下文对象 (`ctx`) 注入：

```javascript
// 'For' 语句创建一个上下文，其中 a=3, b=expr`4`
// 然后将这个上下文作为参数 ctx 传递给回调函数
const c = For`a = 3, b = ${expr`4`}` (ctx => {
    // 回调函数返回一个新的表达式，其中使用了上下文提供的 a 和 b
    // ctx.a 和 ctx.b 是表达式对象，可以被直接嵌入
    return expr`${ctx.a}^2 + ${ctx.b}^2`;
}); 
```
这种模式确保了作用域的清晰隔离，上下文的提供方和使用方权责分明，杜绝了“下游影响上游”的复杂情况。

### 3. 特性范围：专注核心封装与复用

将优先实现命名空间、重命名策略等核心封装机制，暂时放弃对盲文模式等尚不明确或难以建模的高级特性，以确保核心功能的稳定和快速迭代。

### 4. 命名与封装机制：三层命名系统

为了在JavaScript的友好变量名和Desmos的符号限制之间建立桥梁，并提供强大的封装能力，我们引入一个三层命名系统：

-   **JS 变量名**: 用户在JavaScript代码中声明的变量名，如 `myCircleRadius`。
-   **Bernard 标识 (中间名)**: 一个用户可指定的、支持命名空间的字符串标识，作为在Bernard系统内部进行管理的唯一ID。
-   **Desmos 真名**: 最终生成到Desmos图表中的、符合其命名规则（通常是单字符+下标）的符号名。

这个系统通过以下API进行操作：

**a. 指定Bernard标识:**
使用 `.name()` 方法为表达式对象指定一个中间名。这通常与 `package` 结合使用。
```javascript
// 为一个表达式直接指定Bernard标识
const radius = expr`1`.name("myCircle.radius"); 
```

**b. 强制指定Desmos真名:**
使用 `.realname()` 方法可以强制为表达式指定最终的Desmos符号，Bernard会尽力转换使其合法化。
```javascript
// 建议Desmos真名为 r_mc
const radius = expr`1`.realname("r_myCircle"); 
```

**c. 包装与命名空间:**
`package()` 函数是实现封装和批量命名的核心。它将一组表达式打包，并可以通过 `.name()` 方法为包内所有未指定中间名的表达式批量赋予带命名空间的Bernard标识。
```javascript
const circleDefinition = package([
   expr`center_x = 0`,
   expr`center_y = 0`,
   expr`radius = 1`
]).name("myCircle"); // 为包内所有表达式赋予 "myCircle" 命名空间

// circleDefinition.center_x 的Bernard标识将是 "myCircle.center_x"
```
这个机制允许创建可复用的、无命名冲突的组件，是“默认模式”工程化能力的核心。

## 待讨论和设计的技术问题

### 1. 表达式建模系统

需要设计完整的表达式建模系统，包括：
- 数学表达式的解析和表示
- 变量、函数、运算符的识别
- 依赖关系的建立和分析

具体的实现方案需要进一步讨论。

### 2. 符号重命名策略

JavaScript允许任意长度的变量名，但Desmos只支持单字符+下标格式。需要设计符号映射策略：

```javascript
// JavaScript变量名 -> Desmos符号名映射示例
const exampleSymbolMaps = {
  'radius': 'r',
  'center_x': 'c_x', 
  'center_y': 'c_y',
  'my_very_long_variable_name': 'a_{1}'
};
```

具体的映射规则和实现方式需要进一步讨论。

### 3. 依赖图管理

需要设计依赖图管理系统，包括：
- 依赖关系的识别和构建
- 循环依赖的检测
- 拓扑排序的实现

具体的实现方案需要进一步讨论。

### 4. 预处理器实现

需要选择预处理器的实现方案：
- Babel插件方案
- 运行时处理方案
- 其他可能的方案

具体的实现方式需要进一步讨论。

### 5. 性能优化策略

需要考虑的性能优化策略：
- 表达式缓存机制
- 懒加载策略
- 增量更新机制

具体的实现方案需要进一步讨论。

## 主要技术挑战

### 1. 表达式建模复杂度

JavaScript路线面临的最大挑战是表达式建模的复杂度。需要自建完整的表达式解析系统，包括数学表达式的解析、变量和函数的识别、依赖关系的建立等。

### 2. 符号重命名策略

JavaScript允许任意长度的变量名，但Desmos只支持单字符+下标格式。需要设计从JavaScript变量名到Desmos符号名的映射策略。

### 3. 性能考虑

需要考虑延迟求值、缓存机制等性能优化策略，确保系统能够高效处理复杂的数学表达式。

## 设计模式的优势与限制

### 优势

1. **节点类型区分**：`expr`和`expl`明确区分了不同类型的节点
2. **自然的依赖表达**：`${a} + ${b}`直观地表达了依赖关系
3. **JavaScript原生支持**：无需学习新的语法
4. **渐进增强**：可以从简单版本逐步优化到复杂版本
5. **现代化语法**：箭头函数等语法符合JavaScript开发者习惯

### 限制

1. **表达建模复杂度**：仍需要解决JavaScript路线的核心挑战
2. **调试复杂性**：预处理可能使调试变得困难
3. **类型安全性**：缺乏编译时类型检查
4. **符号重命名复杂性**：需要处理JavaScript到Desmos的符号映射
5. **性能开销**：相比Julia的原生数学支持，需要更多的运行时处理

## 总结

双重表达式对象设计是一个清晰的API设计方案，通过`expr`和`expl`明确区分了不同类型的节点，并提供了符合JavaScript习惯的语法糖。这个设计在画布应用场景中具有潜力，主要因为可以避免前后端分离的架构复杂性。

然而，这个设计并不能解决JavaScript路线面临的核心技术挑战：表达式建模和依赖分析的复杂度。相比之下，Julia通过宏系统也可以很容易地实现类似的API区分，并且在数学表达自然性和符号计算能力方面具有显著优势。

建议的实施路径：
1. **先实现无预处理版本**，验证核心表达式建模的可行性
2. **重点解决依赖分析和符号重命名**，这是成功的关键
3. **在画布环境中测试架构简化的效果** 